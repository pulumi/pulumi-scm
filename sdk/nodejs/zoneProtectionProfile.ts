// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ZoneProtectionProfile resource
 */
export class ZoneProtectionProfile extends pulumi.CustomResource {
    /**
     * Get an existing ZoneProtectionProfile resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ZoneProtectionProfileState, opts?: pulumi.CustomResourceOptions): ZoneProtectionProfile {
        return new ZoneProtectionProfile(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'scm:index/zoneProtectionProfile:ZoneProtectionProfile';

    /**
     * Returns true if the given object is an instance of ZoneProtectionProfile.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ZoneProtectionProfile {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ZoneProtectionProfile.__pulumiType;
    }

    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     */
    declare public readonly asymmetricPath: pulumi.Output<string | undefined>;
    /**
     * The description of the profile
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * The device in which the resource is defined
     */
    declare public readonly device: pulumi.Output<string | undefined>;
    /**
     * Discard ICMP packets that are embedded with an error message.
     */
    declare public readonly discardIcmpEmbeddedError: pulumi.Output<boolean | undefined>;
    /**
     * Flood
     */
    declare public readonly flood: pulumi.Output<outputs.ZoneProtectionProfileFlood | undefined>;
    /**
     * The folder in which the resource is defined
     */
    declare public readonly folder: pulumi.Output<string | undefined>;
    /**
     * Discard fragmented IP packets.
     */
    declare public readonly fragmentedTrafficDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets that consist of ICMP fragments.
     */
    declare public readonly icmpFragDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     */
    declare public readonly icmpLargePacketDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     */
    declare public readonly icmpPingZeroIdDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Ipv6
     */
    declare public readonly ipv6: pulumi.Output<outputs.ZoneProtectionProfileIpv6 | undefined>;
    /**
     * L2 sec group tag protection
     */
    declare public readonly l2SecGroupTagProtection: pulumi.Output<outputs.ZoneProtectionProfileL2SecGroupTagProtection | undefined>;
    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     */
    declare public readonly looseSourceRoutingDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     */
    declare public readonly malformedOptionDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Drop packets with mismatched overlapping TCP segments.
     */
    declare public readonly mismatchedOverlappingTcpSegmentDiscard: pulumi.Output<boolean | undefined>;
    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     */
    declare public readonly mptcpOptionStrip: pulumi.Output<string>;
    /**
     * The profile name
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Non ip protocol
     */
    declare public readonly nonIpProtocol: pulumi.Output<outputs.ZoneProtectionProfileNonIpProtocol | undefined>;
    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     */
    declare public readonly recordRouteDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     */
    declare public readonly rejectNonSynTcp: pulumi.Output<string | undefined>;
    /**
     * Scan white list
     */
    declare public readonly scanWhiteLists: pulumi.Output<outputs.ZoneProtectionProfileScanWhiteList[] | undefined>;
    /**
     * Scan
     */
    declare public readonly scans: pulumi.Output<outputs.ZoneProtectionProfileScan[] | undefined>;
    /**
     * Discard packets if the security option is defined.
     */
    declare public readonly securityDiscard: pulumi.Output<boolean | undefined>;
    /**
     * The snippet in which the resource is defined
     */
    declare public readonly snippet: pulumi.Output<string | undefined>;
    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     */
    declare public readonly spoofedIpDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets if the Stream ID option is defined.
     */
    declare public readonly streamIdDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     * If either condition is not true, discard the packet.
     */
    declare public readonly strictIpCheck: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     */
    declare public readonly strictSourceRoutingDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     */
    declare public readonly suppressIcmpNeedfrag: pulumi.Output<boolean | undefined>;
    /**
     * Stop sending ICMP TTL expired messages.
     */
    declare public readonly suppressIcmpTimeexceeded: pulumi.Output<boolean | undefined>;
    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     */
    declare public readonly tcpFastOpenAndDataStrip: pulumi.Output<boolean | undefined>;
    /**
     * Drop packets with split handshakes.
     */
    declare public readonly tcpHandshakeDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     */
    declare public readonly tcpSynWithDataDiscard: pulumi.Output<boolean>;
    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     */
    declare public readonly tcpSynackWithDataDiscard: pulumi.Output<boolean>;
    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     */
    declare public readonly tcpTimestampStrip: pulumi.Output<boolean | undefined>;
    declare public /*out*/ readonly tfid: pulumi.Output<string>;
    /**
     * Discard packets with the Timestamp IP option set.
     */
    declare public readonly timestampDiscard: pulumi.Output<boolean | undefined>;
    /**
     * Discard packets if the class and number are unknown.
     */
    declare public readonly unknownOptionDiscard: pulumi.Output<boolean | undefined>;

    /**
     * Create a ZoneProtectionProfile resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: ZoneProtectionProfileArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ZoneProtectionProfileArgs | ZoneProtectionProfileState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ZoneProtectionProfileState | undefined;
            resourceInputs["asymmetricPath"] = state?.asymmetricPath;
            resourceInputs["description"] = state?.description;
            resourceInputs["device"] = state?.device;
            resourceInputs["discardIcmpEmbeddedError"] = state?.discardIcmpEmbeddedError;
            resourceInputs["flood"] = state?.flood;
            resourceInputs["folder"] = state?.folder;
            resourceInputs["fragmentedTrafficDiscard"] = state?.fragmentedTrafficDiscard;
            resourceInputs["icmpFragDiscard"] = state?.icmpFragDiscard;
            resourceInputs["icmpLargePacketDiscard"] = state?.icmpLargePacketDiscard;
            resourceInputs["icmpPingZeroIdDiscard"] = state?.icmpPingZeroIdDiscard;
            resourceInputs["ipv6"] = state?.ipv6;
            resourceInputs["l2SecGroupTagProtection"] = state?.l2SecGroupTagProtection;
            resourceInputs["looseSourceRoutingDiscard"] = state?.looseSourceRoutingDiscard;
            resourceInputs["malformedOptionDiscard"] = state?.malformedOptionDiscard;
            resourceInputs["mismatchedOverlappingTcpSegmentDiscard"] = state?.mismatchedOverlappingTcpSegmentDiscard;
            resourceInputs["mptcpOptionStrip"] = state?.mptcpOptionStrip;
            resourceInputs["name"] = state?.name;
            resourceInputs["nonIpProtocol"] = state?.nonIpProtocol;
            resourceInputs["recordRouteDiscard"] = state?.recordRouteDiscard;
            resourceInputs["rejectNonSynTcp"] = state?.rejectNonSynTcp;
            resourceInputs["scanWhiteLists"] = state?.scanWhiteLists;
            resourceInputs["scans"] = state?.scans;
            resourceInputs["securityDiscard"] = state?.securityDiscard;
            resourceInputs["snippet"] = state?.snippet;
            resourceInputs["spoofedIpDiscard"] = state?.spoofedIpDiscard;
            resourceInputs["streamIdDiscard"] = state?.streamIdDiscard;
            resourceInputs["strictIpCheck"] = state?.strictIpCheck;
            resourceInputs["strictSourceRoutingDiscard"] = state?.strictSourceRoutingDiscard;
            resourceInputs["suppressIcmpNeedfrag"] = state?.suppressIcmpNeedfrag;
            resourceInputs["suppressIcmpTimeexceeded"] = state?.suppressIcmpTimeexceeded;
            resourceInputs["tcpFastOpenAndDataStrip"] = state?.tcpFastOpenAndDataStrip;
            resourceInputs["tcpHandshakeDiscard"] = state?.tcpHandshakeDiscard;
            resourceInputs["tcpSynWithDataDiscard"] = state?.tcpSynWithDataDiscard;
            resourceInputs["tcpSynackWithDataDiscard"] = state?.tcpSynackWithDataDiscard;
            resourceInputs["tcpTimestampStrip"] = state?.tcpTimestampStrip;
            resourceInputs["tfid"] = state?.tfid;
            resourceInputs["timestampDiscard"] = state?.timestampDiscard;
            resourceInputs["unknownOptionDiscard"] = state?.unknownOptionDiscard;
        } else {
            const args = argsOrState as ZoneProtectionProfileArgs | undefined;
            resourceInputs["asymmetricPath"] = args?.asymmetricPath;
            resourceInputs["description"] = args?.description;
            resourceInputs["device"] = args?.device;
            resourceInputs["discardIcmpEmbeddedError"] = args?.discardIcmpEmbeddedError;
            resourceInputs["flood"] = args?.flood;
            resourceInputs["folder"] = args?.folder;
            resourceInputs["fragmentedTrafficDiscard"] = args?.fragmentedTrafficDiscard;
            resourceInputs["icmpFragDiscard"] = args?.icmpFragDiscard;
            resourceInputs["icmpLargePacketDiscard"] = args?.icmpLargePacketDiscard;
            resourceInputs["icmpPingZeroIdDiscard"] = args?.icmpPingZeroIdDiscard;
            resourceInputs["ipv6"] = args?.ipv6;
            resourceInputs["l2SecGroupTagProtection"] = args?.l2SecGroupTagProtection;
            resourceInputs["looseSourceRoutingDiscard"] = args?.looseSourceRoutingDiscard;
            resourceInputs["malformedOptionDiscard"] = args?.malformedOptionDiscard;
            resourceInputs["mismatchedOverlappingTcpSegmentDiscard"] = args?.mismatchedOverlappingTcpSegmentDiscard;
            resourceInputs["mptcpOptionStrip"] = args?.mptcpOptionStrip;
            resourceInputs["name"] = args?.name;
            resourceInputs["nonIpProtocol"] = args?.nonIpProtocol;
            resourceInputs["recordRouteDiscard"] = args?.recordRouteDiscard;
            resourceInputs["rejectNonSynTcp"] = args?.rejectNonSynTcp;
            resourceInputs["scanWhiteLists"] = args?.scanWhiteLists;
            resourceInputs["scans"] = args?.scans;
            resourceInputs["securityDiscard"] = args?.securityDiscard;
            resourceInputs["snippet"] = args?.snippet;
            resourceInputs["spoofedIpDiscard"] = args?.spoofedIpDiscard;
            resourceInputs["streamIdDiscard"] = args?.streamIdDiscard;
            resourceInputs["strictIpCheck"] = args?.strictIpCheck;
            resourceInputs["strictSourceRoutingDiscard"] = args?.strictSourceRoutingDiscard;
            resourceInputs["suppressIcmpNeedfrag"] = args?.suppressIcmpNeedfrag;
            resourceInputs["suppressIcmpTimeexceeded"] = args?.suppressIcmpTimeexceeded;
            resourceInputs["tcpFastOpenAndDataStrip"] = args?.tcpFastOpenAndDataStrip;
            resourceInputs["tcpHandshakeDiscard"] = args?.tcpHandshakeDiscard;
            resourceInputs["tcpSynWithDataDiscard"] = args?.tcpSynWithDataDiscard;
            resourceInputs["tcpSynackWithDataDiscard"] = args?.tcpSynackWithDataDiscard;
            resourceInputs["tcpTimestampStrip"] = args?.tcpTimestampStrip;
            resourceInputs["timestampDiscard"] = args?.timestampDiscard;
            resourceInputs["unknownOptionDiscard"] = args?.unknownOptionDiscard;
            resourceInputs["tfid"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ZoneProtectionProfile.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ZoneProtectionProfile resources.
 */
export interface ZoneProtectionProfileState {
    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     */
    asymmetricPath?: pulumi.Input<string>;
    /**
     * The description of the profile
     */
    description?: pulumi.Input<string>;
    /**
     * The device in which the resource is defined
     */
    device?: pulumi.Input<string>;
    /**
     * Discard ICMP packets that are embedded with an error message.
     */
    discardIcmpEmbeddedError?: pulumi.Input<boolean>;
    /**
     * Flood
     */
    flood?: pulumi.Input<inputs.ZoneProtectionProfileFlood>;
    /**
     * The folder in which the resource is defined
     */
    folder?: pulumi.Input<string>;
    /**
     * Discard fragmented IP packets.
     */
    fragmentedTrafficDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets that consist of ICMP fragments.
     */
    icmpFragDiscard?: pulumi.Input<boolean>;
    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     */
    icmpLargePacketDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     */
    icmpPingZeroIdDiscard?: pulumi.Input<boolean>;
    /**
     * Ipv6
     */
    ipv6?: pulumi.Input<inputs.ZoneProtectionProfileIpv6>;
    /**
     * L2 sec group tag protection
     */
    l2SecGroupTagProtection?: pulumi.Input<inputs.ZoneProtectionProfileL2SecGroupTagProtection>;
    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     */
    looseSourceRoutingDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     */
    malformedOptionDiscard?: pulumi.Input<boolean>;
    /**
     * Drop packets with mismatched overlapping TCP segments.
     */
    mismatchedOverlappingTcpSegmentDiscard?: pulumi.Input<boolean>;
    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     */
    mptcpOptionStrip?: pulumi.Input<string>;
    /**
     * The profile name
     */
    name?: pulumi.Input<string>;
    /**
     * Non ip protocol
     */
    nonIpProtocol?: pulumi.Input<inputs.ZoneProtectionProfileNonIpProtocol>;
    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     */
    recordRouteDiscard?: pulumi.Input<boolean>;
    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     */
    rejectNonSynTcp?: pulumi.Input<string>;
    /**
     * Scan white list
     */
    scanWhiteLists?: pulumi.Input<pulumi.Input<inputs.ZoneProtectionProfileScanWhiteList>[]>;
    /**
     * Scan
     */
    scans?: pulumi.Input<pulumi.Input<inputs.ZoneProtectionProfileScan>[]>;
    /**
     * Discard packets if the security option is defined.
     */
    securityDiscard?: pulumi.Input<boolean>;
    /**
     * The snippet in which the resource is defined
     */
    snippet?: pulumi.Input<string>;
    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     */
    spoofedIpDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the Stream ID option is defined.
     */
    streamIdDiscard?: pulumi.Input<boolean>;
    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     * If either condition is not true, discard the packet.
     */
    strictIpCheck?: pulumi.Input<boolean>;
    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     */
    strictSourceRoutingDiscard?: pulumi.Input<boolean>;
    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     */
    suppressIcmpNeedfrag?: pulumi.Input<boolean>;
    /**
     * Stop sending ICMP TTL expired messages.
     */
    suppressIcmpTimeexceeded?: pulumi.Input<boolean>;
    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     */
    tcpFastOpenAndDataStrip?: pulumi.Input<boolean>;
    /**
     * Drop packets with split handshakes.
     */
    tcpHandshakeDiscard?: pulumi.Input<boolean>;
    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     */
    tcpSynWithDataDiscard?: pulumi.Input<boolean>;
    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     */
    tcpSynackWithDataDiscard?: pulumi.Input<boolean>;
    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     */
    tcpTimestampStrip?: pulumi.Input<boolean>;
    tfid?: pulumi.Input<string>;
    /**
     * Discard packets with the Timestamp IP option set.
     */
    timestampDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the class and number are unknown.
     */
    unknownOptionDiscard?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a ZoneProtectionProfile resource.
 */
export interface ZoneProtectionProfileArgs {
    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     */
    asymmetricPath?: pulumi.Input<string>;
    /**
     * The description of the profile
     */
    description?: pulumi.Input<string>;
    /**
     * The device in which the resource is defined
     */
    device?: pulumi.Input<string>;
    /**
     * Discard ICMP packets that are embedded with an error message.
     */
    discardIcmpEmbeddedError?: pulumi.Input<boolean>;
    /**
     * Flood
     */
    flood?: pulumi.Input<inputs.ZoneProtectionProfileFlood>;
    /**
     * The folder in which the resource is defined
     */
    folder?: pulumi.Input<string>;
    /**
     * Discard fragmented IP packets.
     */
    fragmentedTrafficDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets that consist of ICMP fragments.
     */
    icmpFragDiscard?: pulumi.Input<boolean>;
    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     */
    icmpLargePacketDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     */
    icmpPingZeroIdDiscard?: pulumi.Input<boolean>;
    /**
     * Ipv6
     */
    ipv6?: pulumi.Input<inputs.ZoneProtectionProfileIpv6>;
    /**
     * L2 sec group tag protection
     */
    l2SecGroupTagProtection?: pulumi.Input<inputs.ZoneProtectionProfileL2SecGroupTagProtection>;
    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     */
    looseSourceRoutingDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     */
    malformedOptionDiscard?: pulumi.Input<boolean>;
    /**
     * Drop packets with mismatched overlapping TCP segments.
     */
    mismatchedOverlappingTcpSegmentDiscard?: pulumi.Input<boolean>;
    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     */
    mptcpOptionStrip?: pulumi.Input<string>;
    /**
     * The profile name
     */
    name?: pulumi.Input<string>;
    /**
     * Non ip protocol
     */
    nonIpProtocol?: pulumi.Input<inputs.ZoneProtectionProfileNonIpProtocol>;
    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     */
    recordRouteDiscard?: pulumi.Input<boolean>;
    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     */
    rejectNonSynTcp?: pulumi.Input<string>;
    /**
     * Scan white list
     */
    scanWhiteLists?: pulumi.Input<pulumi.Input<inputs.ZoneProtectionProfileScanWhiteList>[]>;
    /**
     * Scan
     */
    scans?: pulumi.Input<pulumi.Input<inputs.ZoneProtectionProfileScan>[]>;
    /**
     * Discard packets if the security option is defined.
     */
    securityDiscard?: pulumi.Input<boolean>;
    /**
     * The snippet in which the resource is defined
     */
    snippet?: pulumi.Input<string>;
    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     */
    spoofedIpDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the Stream ID option is defined.
     */
    streamIdDiscard?: pulumi.Input<boolean>;
    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     * If either condition is not true, discard the packet.
     */
    strictIpCheck?: pulumi.Input<boolean>;
    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     */
    strictSourceRoutingDiscard?: pulumi.Input<boolean>;
    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     */
    suppressIcmpNeedfrag?: pulumi.Input<boolean>;
    /**
     * Stop sending ICMP TTL expired messages.
     */
    suppressIcmpTimeexceeded?: pulumi.Input<boolean>;
    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     */
    tcpFastOpenAndDataStrip?: pulumi.Input<boolean>;
    /**
     * Drop packets with split handshakes.
     */
    tcpHandshakeDiscard?: pulumi.Input<boolean>;
    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     */
    tcpSynWithDataDiscard?: pulumi.Input<boolean>;
    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     */
    tcpSynackWithDataDiscard?: pulumi.Input<boolean>;
    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     */
    tcpTimestampStrip?: pulumi.Input<boolean>;
    /**
     * Discard packets with the Timestamp IP option set.
     */
    timestampDiscard?: pulumi.Input<boolean>;
    /**
     * Discard packets if the class and number are unknown.
     */
    unknownOptionDiscard?: pulumi.Input<boolean>;
}
