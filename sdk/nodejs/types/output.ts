// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AddressGroupDynamic {
    /**
     * Tag based filter defining group membership
     */
    filter: string;
}

export interface AggregateInterfaceLayer2 {
    /**
     * Lacp
     */
    lacp?: outputs.AggregateInterfaceLayer2Lacp;
    /**
     * VLAN tag
     */
    vlanTag?: string;
}

export interface AggregateInterfaceLayer2Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface AggregateInterfaceLayer3 {
    /**
     * Aggregate Ethernet ARP configuration
     */
    arps?: outputs.AggregateInterfaceLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Aggregate Interface.
     */
    ddnsConfig?: outputs.AggregateInterfaceLayer3DdnsConfig;
    /**
     * Aggregate Ethernet DHCP Client Object
     */
    dhcpClient?: outputs.AggregateInterfaceLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile?: string;
    /**
     * Aggregate Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    ips?: outputs.AggregateInterfaceLayer3Ip[];
    /**
     * Lacp
     */
    lacp?: outputs.AggregateInterfaceLayer3Lacp;
    /**
     * MTU
     */
    mtu: number;
}

export interface AggregateInterfaceLayer3Arp {
    /**
     * MAC address
     */
    hwAddress?: string;
    /**
     * IP address
     */
    name?: string;
}

export interface AggregateInterfaceLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp?: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface AggregateInterfaceLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Aggregate Ethernet DHCP Client Send hostname
     */
    sendHostname?: outputs.AggregateInterfaceLayer3DhcpClientSendHostname;
}

export interface AggregateInterfaceLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface AggregateInterfaceLayer3Ip {
    /**
     * Aggregate Interface IP addresses name
     */
    name: string;
}

export interface AggregateInterfaceLayer3Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface AntiSpywareProfileMicaEngineSpywareEnabled {
    /**
     * Inline policy action
     */
    inlinePolicyAction: string;
    /**
     * Name
     */
    name?: string;
}

export interface AntiSpywareProfileRule {
    /**
     * anti spyware profiles rules default action
     */
    action?: outputs.AntiSpywareProfileRuleAction;
    /**
     * Category
     */
    category?: string;
    /**
     * Name
     */
    name?: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
    /**
     * Severity
     */
    severities?: string[];
    /**
     * Threat name
     */
    threatName: string;
}

export interface AntiSpywareProfileRuleAction {
    /**
     * Alert
     */
    alert?: outputs.AntiSpywareProfileRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.AntiSpywareProfileRuleActionAllow;
    /**
     * anti spyware profiles rules action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.AntiSpywareProfileRuleActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.AntiSpywareProfileRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.AntiSpywareProfileRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.AntiSpywareProfileRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.AntiSpywareProfileRuleActionResetServer;
}

export interface AntiSpywareProfileRuleActionAlert {
}

export interface AntiSpywareProfileRuleActionAllow {
}

export interface AntiSpywareProfileRuleActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface AntiSpywareProfileRuleActionDrop {
}

export interface AntiSpywareProfileRuleActionResetBoth {
}

export interface AntiSpywareProfileRuleActionResetClient {
}

export interface AntiSpywareProfileRuleActionResetServer {
}

export interface AntiSpywareProfileThreatException {
    /**
     * anti spyware profiles threat exception default action
     */
    action?: outputs.AntiSpywareProfileThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps?: outputs.AntiSpywareProfileThreatExceptionExemptIp[];
    /**
     * Name
     */
    name?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
}

export interface AntiSpywareProfileThreatExceptionAction {
    /**
     * Alert
     */
    alert?: outputs.AntiSpywareProfileThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.AntiSpywareProfileThreatExceptionActionAllow;
    /**
     * anti spyware profiles threat exception action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.AntiSpywareProfileThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default?: outputs.AntiSpywareProfileThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.AntiSpywareProfileThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.AntiSpywareProfileThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.AntiSpywareProfileThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.AntiSpywareProfileThreatExceptionActionResetServer;
}

export interface AntiSpywareProfileThreatExceptionActionAlert {
}

export interface AntiSpywareProfileThreatExceptionActionAllow {
}

export interface AntiSpywareProfileThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface AntiSpywareProfileThreatExceptionActionDefault {
}

export interface AntiSpywareProfileThreatExceptionActionDrop {
}

export interface AntiSpywareProfileThreatExceptionActionResetBoth {
}

export interface AntiSpywareProfileThreatExceptionActionResetClient {
}

export interface AntiSpywareProfileThreatExceptionActionResetServer {
}

export interface AntiSpywareProfileThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface AntiSpywareSignatureDefaultAction {
    /**
     * Alert
     */
    alert?: outputs.AntiSpywareSignatureDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.AntiSpywareSignatureDefaultActionAllow;
    /**
     * anti spyware signature block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.AntiSpywareSignatureDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.AntiSpywareSignatureDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.AntiSpywareSignatureDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.AntiSpywareSignatureDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.AntiSpywareSignatureDefaultActionResetServer;
}

export interface AntiSpywareSignatureDefaultActionAlert {
}

export interface AntiSpywareSignatureDefaultActionAllow {
}

export interface AntiSpywareSignatureDefaultActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface AntiSpywareSignatureDefaultActionDrop {
}

export interface AntiSpywareSignatureDefaultActionResetBoth {
}

export interface AntiSpywareSignatureDefaultActionResetClient {
}

export interface AntiSpywareSignatureDefaultActionResetServer {
}

export interface AntiSpywareSignatureSignature {
    /**
     * anti spyware signature combination
     */
    combination?: outputs.AntiSpywareSignatureSignatureCombination;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards?: outputs.AntiSpywareSignatureSignatureStandard[];
}

export interface AntiSpywareSignatureSignatureCombination {
    /**
     * And condition
     */
    andConditions?: outputs.AntiSpywareSignatureSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * anti spyware time attribute
     */
    timeAttribute?: outputs.AntiSpywareSignatureSignatureCombinationTimeAttribute;
}

export interface AntiSpywareSignatureSignatureCombinationAndCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * Or condition
     */
    orConditions?: outputs.AntiSpywareSignatureSignatureCombinationAndConditionOrCondition[];
}

export interface AntiSpywareSignatureSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * Threat id
     */
    threatId?: string;
}

export interface AntiSpywareSignatureSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval?: number;
    /**
     * Threshold
     */
    threshold?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface AntiSpywareSignatureSignatureStandard {
    /**
     * And condition
     */
    andConditions?: outputs.AntiSpywareSignatureSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope?: string;
}

export interface AntiSpywareSignatureSignatureStandardAndCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * Or condition
     */
    orConditions?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrCondition[];
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * Operator
     */
    operator?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperator;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     */
    greaterThan?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     */
    lessThan?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     */
    patternMatch?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context?: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Qualifier
     */
    qualifiers?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context?: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context?: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context?: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern?: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface ApplicationDefault {
    /**
     * Ident by icmp6 type
     */
    identByIcmp6Type?: outputs.ApplicationDefaultIdentByIcmp6Type;
    /**
     * Ident by icmp type
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIcmpType?: outputs.ApplicationDefaultIdentByIcmpType;
    /**
     * Ident by ip protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIpProtocol?: string;
    /**
     * Port
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    ports?: string[];
}

export interface ApplicationDefaultIdentByIcmp6Type {
    /**
     * Code
     */
    code?: string;
    /**
     * Type
     */
    type: string;
}

export interface ApplicationDefaultIdentByIcmpType {
    /**
     * Code
     */
    code?: string;
    /**
     * Type
     */
    type: string;
}

export interface ApplicationFilterTagging {
    /**
     * No tag
     */
    noTag?: boolean;
    /**
     * Tag
     *
     * > ℹ️ **Note:** You must specify exactly one of `noTag` and `tag`.
     */
    tags?: string[];
}

export interface ApplicationSignature {
    /**
     * And condition
     */
    andConditions?: outputs.ApplicationSignatureAndCondition[];
    /**
     * Comment
     */
    comment?: string;
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface ApplicationSignatureAndCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Or condition
     */
    orConditions?: outputs.ApplicationSignatureAndConditionOrCondition[];
}

export interface ApplicationSignatureAndConditionOrCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Operator
     */
    operator: outputs.ApplicationSignatureAndConditionOrConditionOperator;
}

export interface ApplicationSignatureAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo?: outputs.ApplicationSignatureAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    greaterThan?: outputs.ApplicationSignatureAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    lessThan?: outputs.ApplicationSignatureAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    patternMatch?: outputs.ApplicationSignatureAndConditionOrConditionOperatorPatternMatch;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * 4-byte hex value
     */
    mask?: string;
    /**
     * Position
     */
    position?: string;
    /**
     * Value
     */
    value: string;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface ApplicationSignatureAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * Qualifier
     */
    qualifiers?: outputs.ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface AuthenticationProfileLockout {
    /**
     * Lockout object - failedAttempts of authentication profile
     */
    failedAttempts?: number;
    /**
     * Lockout object - lockout-time of authentication profile
     */
    lockoutTime?: number;
}

export interface AuthenticationProfileMethod {
    /**
     * Cloud
     */
    cloud?: outputs.AuthenticationProfileMethodCloud;
    /**
     * Kerberos
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    kerberos?: outputs.AuthenticationProfileMethodKerberos;
    /**
     * Ldap
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    ldap?: outputs.AuthenticationProfileMethodLdap;
    /**
     * Local database
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    localDatabase?: outputs.AuthenticationProfileMethodLocalDatabase;
    /**
     * Radius
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    radius?: outputs.AuthenticationProfileMethodRadius;
    /**
     * Saml idp
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    samlIdp?: outputs.AuthenticationProfileMethodSamlIdp;
    /**
     * Tacplus
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    tacplus?: outputs.AuthenticationProfileMethodTacplus;
}

export interface AuthenticationProfileMethodCloud {
    /**
     * The tenant profile name
     */
    profileName?: string;
}

export interface AuthenticationProfileMethodKerberos {
    /**
     * method kerberos object realm of authentication profile
     */
    realm?: string;
    /**
     * method kerberos object server profile of authentication profile
     */
    serverProfile?: string;
}

export interface AuthenticationProfileMethodLdap {
    /**
     * Login attribute
     */
    loginAttribute?: string;
    /**
     * Passwd exp days
     */
    passwdExpDays?: number;
    /**
     * Server profile
     */
    serverProfile?: string;
}

export interface AuthenticationProfileMethodLocalDatabase {
}

export interface AuthenticationProfileMethodRadius {
    /**
     * method radius object check group of authentication profile
     */
    checkgroup?: boolean;
    /**
     * method radius object server profile of authentication profile
     */
    serverProfile?: string;
}

export interface AuthenticationProfileMethodSamlIdp {
    /**
     * Attribute name usergroup
     */
    attributeNameUsergroup?: string;
    /**
     * Attribute name username
     */
    attributeNameUsername?: string;
    /**
     * method object saml idp certificate profile of authentication profile
     */
    certificateProfile?: string;
    /**
     * Enable single logout
     */
    enableSingleLogout?: boolean;
    /**
     * Request signing certificate
     */
    requestSigningCertificate?: string;
    /**
     * method object saml idp server profile of authentication profile
     */
    serverProfile?: string;
}

export interface AuthenticationProfileMethodTacplus {
    /**
     * method tacplus object check group of authentication profile
     */
    checkgroup?: boolean;
    /**
     * method tacplus object check group of authentication profile
     */
    serverProfile?: string;
}

export interface AuthenticationProfileMultiFactorAuth {
    /**
     * Factors
     */
    factors?: string[];
    /**
     * Mfa enable
     */
    mfaEnable?: boolean;
}

export interface AuthenticationProfileSingleSignOn {
    /**
     * Kerberos keytab
     */
    kerberosKeytab?: string;
    /**
     * Realm
     */
    realm?: string;
}

export interface AuthenticationSettingAuthentication {
    /**
     * Accounting server profile
     */
    accountingServerProfile?: string;
    /**
     * Authentication profile
     */
    authenticationProfile?: string;
    /**
     * Certificate profile
     */
    certificateProfile?: string;
}

export interface AutoVpnClusterBranch {
    /**
     * BGP redistribution profile
     */
    bgpRedistributionProfile?: string;
    /**
     * Interfaces
     */
    interfaces?: outputs.AutoVpnClusterBranchInterface[];
    /**
     * Router
     */
    logicalRouter?: string;
    /**
     * Branch firewall serial number
     */
    name?: string;
    /**
     * Private interfaces
     */
    privateInterfaces?: outputs.AutoVpnClusterBranchPrivateInterface[];
    /**
     * Site name
     */
    site?: string;
}

export interface AutoVpnClusterBranchInterface {
    /**
     * DHCP IP
     */
    dhcpIp?: string;
    /**
     * Ethernet interface
     */
    name?: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings?: outputs.AutoVpnClusterBranchInterfaceSdwanLinkSettings;
}

export interface AutoVpnClusterBranchInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway?: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile?: string;
    /**
     * Upstream nat
     */
    upstreamNat?: outputs.AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp?: outputs.AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn?: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress?: string;
}

export interface AutoVpnClusterBranchPrivateInterface {
    /**
     * Ethernet interface
     */
    name?: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings?: outputs.AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettings;
}

export interface AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway?: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile?: string;
    /**
     * Upstream nat
     */
    upstreamNat?: outputs.AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp?: outputs.AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn?: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress?: string;
}

export interface AutoVpnClusterGateway {
    /**
     * Allow DIA to VPN failover on branch device for the hub?
     */
    allowDiaVpnFailover?: boolean;
    /**
     * BGP redistribution file
     */
    bgpRedistributionProfile?: string;
    /**
     * Interfaces
     */
    interfaces?: outputs.AutoVpnClusterGatewayInterface[];
    /**
     * Router
     */
    logicalRouter?: string;
    /**
     * Hub firewall serial number
     */
    name?: string;
    /**
     * Priority
     */
    priority?: string;
    /**
     * Private interfaces
     */
    privateInterfaces?: outputs.AutoVpnClusterGatewayPrivateInterface[];
    /**
     * Site name
     */
    site?: string;
}

export interface AutoVpnClusterGatewayInterface {
    /**
     * DHCP IP
     */
    dhcpIp?: string;
    /**
     * Ethernet interface
     */
    name?: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings?: outputs.AutoVpnClusterGatewayInterfaceSdwanLinkSettings;
}

export interface AutoVpnClusterGatewayInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway?: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile?: string;
    /**
     * Upstream nat
     */
    upstreamNat?: outputs.AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable?: boolean;
    /**
     * Static ip
     */
    staticIp?: outputs.AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn?: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress?: string;
}

export interface AutoVpnClusterGatewayPrivateInterface {
    /**
     * Ethernet interface
     */
    name?: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings?: outputs.AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettings;
}

export interface AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway?: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile?: string;
    /**
     * Upstream nat
     */
    upstreamNat?: outputs.AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable?: boolean;
    /**
     * Static ip
     */
    staticIp?: outputs.AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn?: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress?: string;
}

export interface AutoVpnSettingAsRange {
    /**
     * End
     */
    end?: number;
    /**
     * Start
     */
    start?: number;
}

export interface BandwidthAllocationQos {
    /**
     * Customized
     */
    customized: boolean;
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Guaranteed ratio
     */
    guaranteedRatio: number;
    /**
     * Profile
     */
    profile: string;
}

export interface BgpAddressFamilyProfileIpv4 {
    /**
     * Multicast
     */
    multicast?: outputs.BgpAddressFamilyProfileIpv4Multicast;
    /**
     * Unicast
     */
    unicast?: outputs.BgpAddressFamilyProfileIpv4Unicast;
}

export interface BgpAddressFamilyProfileIpv4Multicast {
    /**
     * Add path
     */
    addPath?: outputs.BgpAddressFamilyProfileIpv4MulticastAddPath;
    /**
     * Allowas in
     */
    allowasIn?: outputs.BgpAddressFamilyProfileIpv4MulticastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride?: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate?: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap?: string;
    /**
     * Enable?
     */
    enable?: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix?: outputs.BgpAddressFamilyProfileIpv4MulticastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpAddressFamilyProfileIpv4MulticastNextHop;
    /**
     * Orf
     */
    orf?: outputs.BgpAddressFamilyProfileIpv4MulticastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs?: outputs.BgpAddressFamilyProfileIpv4MulticastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient?: boolean;
    /**
     * Send community
     */
    sendCommunity?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo?: boolean;
}

export interface BgpAddressFamilyProfileIpv4MulticastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths?: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs?: boolean;
}

export interface BgpAddressFamilyProfileIpv4MulticastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence?: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin?: outputs.BgpAddressFamilyProfileIpv4MulticastAllowasInOrigin;
}

export interface BgpAddressFamilyProfileIpv4MulticastAllowasInOrigin {
}

export interface BgpAddressFamilyProfileIpv4MulticastMaximumPrefix {
    /**
     * Action
     */
    action?: outputs.BgpAddressFamilyProfileIpv4MulticastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes?: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold?: number;
}

export interface BgpAddressFamilyProfileIpv4MulticastMaximumPrefixAction {
    /**
     * Restart
     */
    restart?: outputs.BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly?: outputs.BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnly;
}

export interface BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval?: number;
}

export interface BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnly {
}

export interface BgpAddressFamilyProfileIpv4MulticastNextHop {
    /**
     * Self
     */
    self?: outputs.BgpAddressFamilyProfileIpv4MulticastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce?: outputs.BgpAddressFamilyProfileIpv4MulticastNextHopSelfForce;
}

export interface BgpAddressFamilyProfileIpv4MulticastNextHopSelf {
}

export interface BgpAddressFamilyProfileIpv4MulticastNextHopSelfForce {
}

export interface BgpAddressFamilyProfileIpv4MulticastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList?: string;
}

export interface BgpAddressFamilyProfileIpv4MulticastRemovePrivateAs {
    /**
     * All
     */
    all?: outputs.BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs?: outputs.BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAs;
}

export interface BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAll {
}

export interface BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAs {
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunity {
    /**
     * All
     */
    all?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard?: outputs.BgpAddressFamilyProfileIpv4MulticastSendCommunityStandard;
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunityAll {
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunityBoth {
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunityExtended {
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunityLarge {
}

export interface BgpAddressFamilyProfileIpv4MulticastSendCommunityStandard {
}

export interface BgpAddressFamilyProfileIpv4Unicast {
    /**
     * Add path
     */
    addPath?: outputs.BgpAddressFamilyProfileIpv4UnicastAddPath;
    /**
     * Allowas in
     */
    allowasIn?: outputs.BgpAddressFamilyProfileIpv4UnicastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride?: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate?: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap?: string;
    /**
     * Enable?
     */
    enable?: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix?: outputs.BgpAddressFamilyProfileIpv4UnicastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpAddressFamilyProfileIpv4UnicastNextHop;
    /**
     * Orf
     */
    orf?: outputs.BgpAddressFamilyProfileIpv4UnicastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs?: outputs.BgpAddressFamilyProfileIpv4UnicastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient?: boolean;
    /**
     * Send community
     */
    sendCommunity?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo?: boolean;
}

export interface BgpAddressFamilyProfileIpv4UnicastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths?: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs?: boolean;
}

export interface BgpAddressFamilyProfileIpv4UnicastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence?: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin?: outputs.BgpAddressFamilyProfileIpv4UnicastAllowasInOrigin;
}

export interface BgpAddressFamilyProfileIpv4UnicastAllowasInOrigin {
}

export interface BgpAddressFamilyProfileIpv4UnicastMaximumPrefix {
    /**
     * Action
     */
    action?: outputs.BgpAddressFamilyProfileIpv4UnicastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes?: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold?: number;
}

export interface BgpAddressFamilyProfileIpv4UnicastMaximumPrefixAction {
    /**
     * Restart
     */
    restart?: outputs.BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly?: outputs.BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnly;
}

export interface BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval?: number;
}

export interface BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnly {
}

export interface BgpAddressFamilyProfileIpv4UnicastNextHop {
    /**
     * Self
     */
    self?: outputs.BgpAddressFamilyProfileIpv4UnicastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce?: outputs.BgpAddressFamilyProfileIpv4UnicastNextHopSelfForce;
}

export interface BgpAddressFamilyProfileIpv4UnicastNextHopSelf {
}

export interface BgpAddressFamilyProfileIpv4UnicastNextHopSelfForce {
}

export interface BgpAddressFamilyProfileIpv4UnicastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList?: string;
}

export interface BgpAddressFamilyProfileIpv4UnicastRemovePrivateAs {
    /**
     * All
     */
    all?: outputs.BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs?: outputs.BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAs;
}

export interface BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAll {
}

export interface BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAs {
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunity {
    /**
     * All
     */
    all?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard?: outputs.BgpAddressFamilyProfileIpv4UnicastSendCommunityStandard;
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunityAll {
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunityBoth {
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunityExtended {
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunityLarge {
}

export interface BgpAddressFamilyProfileIpv4UnicastSendCommunityStandard {
}

export interface BgpFilteringProfileIpv4 {
    /**
     * Multicast
     */
    multicast?: outputs.BgpFilteringProfileIpv4Multicast;
    /**
     * Unicast
     */
    unicast?: outputs.BgpFilteringProfileIpv4Unicast;
}

export interface BgpFilteringProfileIpv4Multicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement?: outputs.BgpFilteringProfileIpv4MulticastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList?: outputs.BgpFilteringProfileIpv4MulticastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters?: outputs.BgpFilteringProfileIpv4MulticastInboundNetworkFilters;
    /**
     * Inherit from unicast
     */
    inherit?: boolean;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters?: outputs.BgpFilteringProfileIpv4MulticastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps?: outputs.BgpFilteringProfileIpv4MulticastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap?: string;
}

export interface BgpFilteringProfileIpv4MulticastConditionalAdvertisement {
    /**
     * Exist
     */
    exist?: outputs.BgpFilteringProfileIpv4MulticastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist?: outputs.BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExist;
}

export interface BgpFilteringProfileIpv4MulticastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap?: string;
    /**
     * Exist map
     */
    existMap?: string;
}

export interface BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap?: string;
    /**
     * Non exist map
     */
    nonExistMap?: string;
}

export interface BgpFilteringProfileIpv4MulticastFilterList {
    /**
     * Inbound
     */
    inbound?: string;
    /**
     * Outbound
     */
    outbound?: string;
}

export interface BgpFilteringProfileIpv4MulticastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpFilteringProfileIpv4MulticastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpFilteringProfileIpv4MulticastRouteMaps {
    /**
     * Inbound
     */
    inbound?: string;
    /**
     * Outbound
     */
    outbound?: string;
}

export interface BgpFilteringProfileIpv4Unicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement?: outputs.BgpFilteringProfileIpv4UnicastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList?: outputs.BgpFilteringProfileIpv4UnicastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters?: outputs.BgpFilteringProfileIpv4UnicastInboundNetworkFilters;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters?: outputs.BgpFilteringProfileIpv4UnicastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps?: outputs.BgpFilteringProfileIpv4UnicastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap?: string;
}

export interface BgpFilteringProfileIpv4UnicastConditionalAdvertisement {
    /**
     * Exist
     */
    exist?: outputs.BgpFilteringProfileIpv4UnicastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist?: outputs.BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExist;
}

export interface BgpFilteringProfileIpv4UnicastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap?: string;
    /**
     * Exist map
     */
    existMap?: string;
}

export interface BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap?: string;
    /**
     * Non exist map
     */
    nonExistMap?: string;
}

export interface BgpFilteringProfileIpv4UnicastFilterList {
    /**
     * Inbound
     */
    inbound?: string;
    /**
     * Outbound
     */
    outbound?: string;
}

export interface BgpFilteringProfileIpv4UnicastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpFilteringProfileIpv4UnicastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpFilteringProfileIpv4UnicastRouteMaps {
    /**
     * Inbound
     */
    inbound?: string;
    /**
     * Outbound
     */
    outbound?: string;
}

export interface BgpRedistributionProfileIpv4 {
    /**
     * Unicast
     */
    unicast?: outputs.BgpRedistributionProfileIpv4Unicast;
}

export interface BgpRedistributionProfileIpv4Unicast {
    /**
     * Connected
     */
    connected?: outputs.BgpRedistributionProfileIpv4UnicastConnected;
    /**
     * Ospf
     */
    ospf?: outputs.BgpRedistributionProfileIpv4UnicastOspf;
    /**
     * Static
     */
    static?: outputs.BgpRedistributionProfileIpv4UnicastStatic;
}

export interface BgpRedistributionProfileIpv4UnicastConnected {
    /**
     * Enable connected route redistribution?
     */
    enable?: boolean;
    /**
     * Route metric
     */
    metric?: number;
    /**
     * Route map
     */
    routeMap?: string;
}

export interface BgpRedistributionProfileIpv4UnicastOspf {
    /**
     * Enable OSPF route redistribution?
     */
    enable?: boolean;
    /**
     * Route metric
     */
    metric?: number;
    /**
     * Route map
     */
    routeMap?: string;
}

export interface BgpRedistributionProfileIpv4UnicastStatic {
    /**
     * Enable static route redistribution?
     */
    enable?: boolean;
    /**
     * Route metric
     */
    metric?: number;
    /**
     * Route map
     */
    routeMap?: string;
}

export interface BgpRouteMapRedistributionBgp {
    /**
     * Ospf
     */
    ospf?: outputs.BgpRouteMapRedistributionBgpOspf;
    /**
     * BGP Root RIB
     *
     * > ℹ️ **Note:** You must specify exactly one of `ospf` and `rib`.
     */
    rib?: outputs.BgpRouteMapRedistributionBgpRib;
}

export interface BgpRouteMapRedistributionBgpOspf {
    /**
     * BGP Root OSPF Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionBgpOspfRouteMap[];
}

export interface BgpRouteMapRedistributionBgpOspfRouteMap {
    /**
     * BGP Root OSPF Route maps Action
     */
    action?: string;
    /**
     * BGP Root OSPF Route maps Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapMatch;
    /**
     * BGP Root OSPF Route maps Sequence number
     */
    name?: number;
    /**
     * BGP Root OSPF Set
     */
    set?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapSet;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapMatch {
    /**
     * BGP Root OSPF Route maps match AS path access list
     */
    asPathAccessList?: string;
    /**
     * EBGP Root OSPF Route maps match xtended community
     */
    extendedCommunity?: string;
    /**
     * BGP Root OSPF Route maps match Interface
     */
    interface?: string;
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
     */
    ipv4?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4;
    /**
     * BGP Root OSPF Route maps match Large community
     */
    largeCommunity?: string;
    /**
     * BGP Root OSPF Route maps match Local preference
     */
    localPreference?: number;
    /**
     * BGP Root OSPF Route maps match Metric
     */
    metric?: number;
    /**
     * BGP Root OSPF Route maps match Origin
     */
    origin?: string;
    /**
     * BGP Root OSPF Route maps match Peer
     */
    peer?: string;
    /**
     * BGP Root OSPF Route maps match Regular community
     */
    regularCommunity?: string;
    /**
     * BGP Root OSPF Route maps match Tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4 {
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
     */
    address?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Address;
    /**
     * BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHop;
    /**
     * BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
     */
    routeSource?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSource;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Address {
    /**
     * BGP Root OSPF Route maps match ipv4 Access list
     */
    accessList?: string;
    /**
     * BGP Root OSPF Route maps match ipv4 Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHop {
    /**
     * BGP Root OSPF Route maps ipv4 nextVr hop Access list
     */
    accessList?: string;
    /**
     * BGP Root OSPF Route maps ipv4 next hop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root OSPF Route maps ipv4 route source Access list
     */
    accessList?: string;
    /**
     * BGP Root OSPF Route maps ipv4 route source Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapSet {
    /**
     * Metric
     */
    metric?: outputs.BgpRouteMapRedistributionBgpOspfRouteMapSetMetric;
    /**
     * BGP Root OSPF Route maps set Metric type
     */
    metricType?: string;
    /**
     * BGP Root OSPF Route maps set Tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionBgpOspfRouteMapSetMetric {
    /**
     * BGP Root OSPF Route maps set Metric action
     */
    action?: string;
    /**
     * BGP Root OSPF Route maps set Metric value
     */
    value?: number;
}

export interface BgpRouteMapRedistributionBgpRib {
    /**
     * BGP Root RIB Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionBgpRibRouteMap[];
}

export interface BgpRouteMapRedistributionBgpRibRouteMap {
    /**
     * BGP Root RIB Route maps Action
     */
    action?: string;
    /**
     * BGP Root RIB Route maps Description
     */
    description?: string;
    /**
     * match attribute for BG Rib route map
     */
    match?: outputs.BgpRouteMapRedistributionBgpRibRouteMapMatch;
    /**
     * BGP Root RIB Route maps Sequence number
     */
    name?: number;
    /**
     * Set attributes for BGP route map
     */
    set?: outputs.BgpRouteMapRedistributionBgpRibRouteMapSet;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapMatch {
    /**
     * BGP Root RIB Route maps match AS path access list
     */
    asPathAccessList?: string;
    /**
     * BGP Root RIB Route maps match Extended community
     */
    extendedCommunity?: string;
    /**
     * BGP Root RIB Route maps match Interface
     */
    interface?: string;
    /**
     * BGP Route Map Redistributions Root BGP rib Route Map IPv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4;
    /**
     * BGP Root RIB Route maps match Large community
     */
    largeCommunity?: string;
    /**
     * BGP Root RIB Route maps match Local preference
     */
    localPreference?: number;
    /**
     * BGP Root RIB Route maps match Metric
     */
    metric?: number;
    /**
     * BGP Root RIB Route maps match Origin
     */
    origin?: string;
    /**
     * BGP Root RIB Route maps match Peer
     */
    peer?: string;
    /**
     * BGP Root RIB Route maps match Regular community
     */
    regularCommunity?: string;
    /**
     * BGP Root RIB Route maps match Tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4 {
    /**
     * bgp-route-map-redistributions ipv4 rib object address
     */
    address?: outputs.BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Address;
    /**
     * bgp-route-map-redistributions ipv4 rib object next*hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource?: outputs.BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSource;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Address {
    /**
     * BGP Root RIB Route maps match ipv Access list
     */
    accessList?: string;
    /**
     * BGP Root RIB Route maps match ipv Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHop {
    /**
     * BGP Root RIB Route maps match ipv next hop Access list
     */
    accessList?: string;
    /**
     * BGP Root RIB Route maps match ipv next hop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root RIB Route maps match ipv route source Access list
     */
    accessList?: string;
    /**
     * BGP Root RIB Route maps match ipv route source Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionBgpRibRouteMapSet {
    /**
     * BGP Root RIB Route maps set Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRedistributionConnectedStatic {
    /**
     * Connected Static Root BGP
     */
    bgp?: outputs.BgpRouteMapRedistributionConnectedStaticBgp;
    /**
     * Ospf
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    ospf?: outputs.BgpRouteMapRedistributionConnectedStaticOspf;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    rib?: outputs.BgpRouteMapRedistributionConnectedStaticRib;
}

export interface BgpRouteMapRedistributionConnectedStaticBgp {
    /**
     * Connected Static BGP Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMap[];
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMap {
    /**
     * Connected Static BGP Route maps Action
     */
    action?: string;
    /**
     * Connected Static BGP Route maps Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatch;
    /**
     * Connected Static BGP Route maps Sequence number
     */
    name?: number;
    /**
     * Set
     */
    set?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapSet;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatch {
    /**
     * Connected Static BGP Route maps match Interface
     */
    interface?: string;
    /**
     * bgp-route-map-redistributions connected-static ipv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4;
    /**
     * Connected Static BGP Route maps match Metric
     */
    metric?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4 {
    /**
     * Address
     */
    address?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHop;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Route maps match ip4 Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP Route maps match ip4  Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Route maps match ip4 next hop Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP Route maps match ip4 next hop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions connected*static aggregator
     */
    aggregator?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregator;
    /**
     * Connected Static BGP Route maps set AS numbers
     */
    aspathPrepends?: number[];
    /**
     * Connected Static BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate?: boolean;
    /**
     * Ipv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4;
    /**
     * Connected Static  BGP Route maps set Large communities
     */
    largeCommunities?: string[];
    /**
     * Connected Static BGP Route maps set Local preference
     */
    localPreference?: number;
    /**
     * Metric
     */
    metric?: outputs.BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetric;
    /**
     * Connected Static BGP Route maps set Origin
     */
    origin?: string;
    /**
     * Connected Static BGP Route maps set Originator ID
     */
    originatorId?: string;
    /**
     * Connected Static  BGP Route maps set Regular communities
     */
    regularCommunities?: string[];
    /**
     * Connected Static BGP Route maps set Tag
     */
    tag?: number;
    /**
     * Connected Static BGP Route maps set Weight
     */
    weight?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregator {
    /**
     * Connected Static BGP Route maps set Aggregator AS
     */
    as?: number;
    /**
     * Connected Static BGP Route maps set Router ID
     */
    routerId?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4 {
    /**
     * Connected Static BGP Route maps set Next ipv4 hop
     */
    nextHop?: string;
    /**
     * Connected Static BGP Route maps set ipv4 Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetric {
    /**
     * Connected Static BGP Route maps set Metric action
     */
    action?: string;
    /**
     * Connected Static BGP Route maps set Metric value
     */
    value?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticOspf {
    /**
     * Connected Static  BGP OSPF Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMap[];
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMap {
    /**
     * Connected Static BGP OSPF Route map Action
     */
    action?: string;
    /**
     * Connected Static BGP OSPF Route map Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatch;
    /**
     * Connected Static BGP OSPF Route map Sequence number
     */
    name?: number;
    /**
     * Connected Static Root OSPF Set
     */
    set?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapSet;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatch {
    /**
     * Connected Static BGP OSPF Route map Interface
     */
    interface?: string;
    /**
     * bgp-route-map-redistributions connected-static match ipv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4;
    /**
     * Connected Static BGP OSPF Route map Metric
     */
    metric?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4 {
    /**
     * Connected Static Root OSPF Address
     */
    address?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHop;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP OSPF Route map ipv4 Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapSet {
    /**
     * Metric
     */
    metric?: outputs.BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetric;
    /**
     * Connected Static BGP OSPF Route map set Metric type
     */
    metricType?: string;
    /**
     * Connected Static BGP OSPF Route map set Tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetric {
    /**
     * Connected Static BGP OSPF Route map set Metric action
     */
    action?: string;
    /**
     * Connected Static BGP OSPF Route map set Metric value
     */
    value?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticRib {
    /**
     * Connected Static BGP Rib Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMap[];
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMap {
    /**
     * Connected Static BGP Rib Route maps Action
     */
    action?: string;
    /**
     * Connected Static BGP Rib Route maps Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMapMatch;
    /**
     * Connected Static BGP Rib Route maps Sequence number
     */
    name?: number;
    /**
     * Connected Static Root RIB set
     */
    set?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMapSet;
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMapMatch {
    /**
     * Connected Static BGP Rib Route maps Interface
     */
    interface?: string;
    /**
     * Ipv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4;
    /**
     * Connected Static BGP Rib Route maps Metric
     */
    metric?: number;
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4 {
    /**
     * Connected Static BGP Rib Route maps ipv4 address
     */
    address?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHop;
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Rib Route maps ipv4 Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Rib Route maps ipv4 nect hop Access list
     */
    accessList?: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 next hop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionConnectedStaticRibRouteMapSet {
    /**
     * Connected Static BGP Rib Route Map Distribution Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRedistributionOspf {
    /**
     * OSPF Root BGP
     */
    bgp?: outputs.BgpRouteMapRedistributionOspfBgp;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp` and `rib`.
     */
    rib?: outputs.BgpRouteMapRedistributionOspfRib;
}

export interface BgpRouteMapRedistributionOspfBgp {
    /**
     * OSPF BGP Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionOspfBgpRouteMap[];
}

export interface BgpRouteMapRedistributionOspfBgpRouteMap {
    /**
     * OSPF BGP Route maps Action
     */
    action?: string;
    /**
     * OSPF BGP Route maps Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapMatch;
    /**
     * OSPF BGP Route maps Sequence number
     */
    name?: number;
    /**
     * OSPF Root Set
     */
    set?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapSet;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapMatch {
    /**
     * bgp-route-map-redistributions ospf address
     */
    address?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapMatchAddress;
    /**
     * OSPF BGP Route maps Interface
     */
    interface?: string;
    /**
     * OSPF BGP Route maps Metric
     */
    metric?: number;
    /**
     * bgp-route-map-redistributions ospf next*hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHop;
    /**
     * OSPF BGP Route maps Tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapMatchAddress {
    /**
     * OSPF BGP Route maps match Access list
     */
    accessList?: string;
    /**
     * OSPF BGP Route maps match Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHop {
    /**
     * OSPF BGP Route maps nextHop Access list
     */
    accessList?: string;
    /**
     * OSPF BGP Route maps nextHop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions set aggregator
     */
    aggregator?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapSetAggregator;
    /**
     * OSPF BGP Route maps set AS numbers
     */
    aspathPrepends?: number[];
    /**
     * OSPF BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate?: boolean;
    /**
     * Ipv4
     */
    ipv4?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4;
    /**
     * OSPF BGP Route maps set Large communities
     */
    largeCommunities?: string[];
    /**
     * OSPF BGP Route maps set Local preference
     */
    localPreference?: number;
    /**
     * Metric
     */
    metric?: outputs.BgpRouteMapRedistributionOspfBgpRouteMapSetMetric;
    /**
     * OSPF BGP Route maps set Origin
     */
    origin?: string;
    /**
     * OSPF BGP Route maps set Originator ID
     */
    originatorId?: string;
    /**
     * OSPF BGP Route maps set Regular communities
     */
    regularCommunities?: string[];
    /**
     * OSPF BGP Route maps set Tag
     */
    tag?: number;
    /**
     * OSPF BGP Route maps set Weight
     */
    weight?: number;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapSetAggregator {
    /**
     * OSPF BGP Route maps set Aggregator AS
     */
    as?: number;
    /**
     * OSPF BGP Route maps set Router ID
     */
    routerId?: string;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4 {
    /**
     * OSPF BGP Route maps set ipv4 Next hop
     */
    nextHop?: string;
    /**
     * OSPF BGP Route maps set ipv4 Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRedistributionOspfBgpRouteMapSetMetric {
    /**
     * OSPF BGP Route maps set Metric action
     */
    action?: string;
    /**
     * OSPF BGP Route maps set Metric value
     */
    value?: number;
}

export interface BgpRouteMapRedistributionOspfRib {
    /**
     * OSPF RIB Route maps set Route maps
     */
    routeMaps?: outputs.BgpRouteMapRedistributionOspfRibRouteMap[];
}

export interface BgpRouteMapRedistributionOspfRibRouteMap {
    /**
     * OSPF RIB Route maps Action
     */
    action?: string;
    /**
     * OSPF RIB Route maps Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRedistributionOspfRibRouteMapMatch;
    /**
     * OSPF RIB Route mapsSequence number
     */
    name?: number;
    /**
     * OSPF RIB Route maps set
     */
    set?: outputs.BgpRouteMapRedistributionOspfRibRouteMapSet;
}

export interface BgpRouteMapRedistributionOspfRibRouteMapMatch {
    /**
     * OSPF RIB Route maps address
     */
    address?: outputs.BgpRouteMapRedistributionOspfRibRouteMapMatchAddress;
    /**
     * OSPF RIB Route maps Interface
     */
    interface?: string;
    /**
     * OSPF RIB Route maps Metric
     */
    metric?: number;
    /**
     * OSPF RIB Route maps next*hop
     */
    nextHop?: outputs.BgpRouteMapRedistributionOspfRibRouteMapMatchNextHop;
    /**
     * OSPF RIB Route maps tag
     */
    tag?: number;
}

export interface BgpRouteMapRedistributionOspfRibRouteMapMatchAddress {
    /**
     * OSPF RIB Route maps address Access list
     */
    accessList?: string;
    /**
     * OSPF RIB Route maps address Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionOspfRibRouteMapMatchNextHop {
    /**
     * OSPF RIB Route maps nextHop Access list
     */
    accessList?: string;
    /**
     * OSPF RIB Route maps nextHop Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRedistributionOspfRibRouteMapSet {
    /**
     * OSPF RIB Route maps set Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRouteMap {
    /**
     * Action
     */
    action?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Match
     */
    match?: outputs.BgpRouteMapRouteMapMatch;
    /**
     * Sequence number
     */
    name?: number;
    /**
     * Set
     */
    set?: outputs.BgpRouteMapRouteMapSet;
}

export interface BgpRouteMapRouteMapMatch {
    /**
     * AS path access list
     */
    asPathAccessList?: string;
    /**
     * Extended community
     */
    extendedCommunity?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * bgp-route-maps ipv4 object
     */
    ipv4?: outputs.BgpRouteMapRouteMapMatchIpv4;
    /**
     * Large community
     */
    largeCommunity?: string;
    /**
     * Local preference
     */
    localPreference?: number;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Origin
     */
    origin?: string;
    /**
     * Peer
     */
    peer?: string;
    /**
     * Regular community
     */
    regularCommunity?: string;
    /**
     * Tag
     */
    tag?: number;
}

export interface BgpRouteMapRouteMapMatchIpv4 {
    /**
     * Address
     */
    address?: outputs.BgpRouteMapRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop?: outputs.BgpRouteMapRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource?: outputs.BgpRouteMapRouteMapMatchIpv4RouteSource;
}

export interface BgpRouteMapRouteMapMatchIpv4Address {
    /**
     * Access list
     */
    accessList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRouteMapMatchIpv4NextHop {
    /**
     * Access list
     */
    accessList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRouteMapMatchIpv4RouteSource {
    /**
     * Access list
     */
    accessList?: string;
    /**
     * Prefix list
     */
    prefixList?: string;
}

export interface BgpRouteMapRouteMapSet {
    /**
     * bgp-route-maps aggregator
     */
    aggregator?: outputs.BgpRouteMapRouteMapSetAggregator;
    /**
     * Aspath exclude
     */
    aspathExcludes?: number[];
    /**
     * Aspath prepend
     */
    aspathPrepends?: number[];
    /**
     * Enable BGP atomic aggregate?
     */
    atomicAggregate?: boolean;
    /**
     * Ipv4
     */
    ipv4?: outputs.BgpRouteMapRouteMapSetIpv4;
    /**
     * Large community
     */
    largeCommunities?: string[];
    /**
     * Local preference
     */
    localPreference?: number;
    /**
     * Metric
     */
    metric?: outputs.BgpRouteMapRouteMapSetMetric;
    /**
     * Origin
     */
    origin?: string;
    /**
     * Originator ID
     */
    originatorId?: string;
    /**
     * Overwrite large community?
     */
    overwriteLargeCommunity?: boolean;
    /**
     * Overwrite regular community?
     */
    overwriteRegularCommunity?: boolean;
    /**
     * Regular community
     */
    regularCommunities?: string[];
    /**
     * Remove large community name
     */
    removeLargeCommunity?: string;
    /**
     * Remove regular community name
     */
    removeRegularCommunity?: string;
    /**
     * Tag
     */
    tag?: number;
    /**
     * Weight
     */
    weight?: number;
}

export interface BgpRouteMapRouteMapSetAggregator {
    /**
     * Aggregator AS
     */
    as?: number;
    /**
     * Router ID
     */
    routerId?: string;
}

export interface BgpRouteMapRouteMapSetIpv4 {
    /**
     * Next hop
     */
    nextHop?: string;
    /**
     * Source address
     */
    sourceAddress?: string;
}

export interface BgpRouteMapRouteMapSetMetric {
    /**
     * Metric action
     */
    action?: string;
    /**
     * Metric value
     */
    value?: number;
}

export interface BgpRoutingRoutingPreference {
    /**
     * Default
     */
    default?: outputs.BgpRoutingRoutingPreferenceDefault;
    /**
     * Hot potato routing
     *
     * > ℹ️ **Note:** You must specify exactly one of `default` and `hotPotatoRouting`.
     */
    hotPotatoRouting?: outputs.BgpRoutingRoutingPreferenceHotPotatoRouting;
}

export interface BgpRoutingRoutingPreferenceDefault {
}

export interface BgpRoutingRoutingPreferenceHotPotatoRouting {
}

export interface CertificateProfileCaCertificate {
    /**
     * Default OCSP URL
     */
    defaultOcspUrl?: string;
    /**
     * CA certificate name
     */
    name: string;
    /**
     * OCSP verify certificate
     */
    ocspVerifyCert?: string;
    /**
     * Template name/OID
     */
    templateName?: string;
}

export interface CertificateProfileUsernameField {
    /**
     * Common name
     */
    subject?: string;
    /**
     * Email address
     */
    subjectAlt?: string;
}

export interface ContentIdSettingContentId {
    /**
     * Allow forward decrypted content
     */
    allowForwardDecryptedContent: boolean;
    /**
     * Allow http range
     */
    allowHttpRange: boolean;
    /**
     * Application
     */
    application?: outputs.ContentIdSettingContentIdApplication;
    /**
     * Extended capture segment
     */
    extendedCaptureSegment: number;
    /**
     * Strip x fwd for
     */
    stripXFwdFor: boolean;
    /**
     * Tcp bypass exceed queue
     */
    tcpBypassExceedQueue: boolean;
    /**
     * Udp bypass exceed queue
     */
    udpBypassExceedQueue: boolean;
    /**
     * X forwarded for
     */
    xForwardedFor: string;
}

export interface ContentIdSettingContentIdApplication {
    /**
     * Bypass exceed queue
     */
    bypassExceedQueue: boolean;
}

export interface DecryptionProfileSslForwardProxy {
    /**
     * Auto include altname
     */
    autoIncludeAltname: boolean;
    /**
     * Block client cert
     */
    blockClientCert: boolean;
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block timeout cert
     */
    blockTimeoutCert: boolean;
    /**
     * Block tls13 downgrade no resource
     */
    blockTls13DowngradeNoResource: boolean;
    /**
     * Block unknown cert
     */
    blockUnknownCert: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
    /**
     * Restrict cert exts
     */
    restrictCertExts: boolean;
    /**
     * Strip alpn
     */
    stripAlpn: boolean;
}

export interface DecryptionProfileSslInboundProxy {
    /**
     * Block if hsm unavailable
     */
    blockIfHsmUnavailable: boolean;
    /**
     * Block if no resource
     */
    blockIfNoResource: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
}

export interface DecryptionProfileSslNoProxy {
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
}

export interface DecryptionProfileSslProtocolSettings {
    /**
     * Auth algo md5
     */
    authAlgoMd5: boolean;
    /**
     * Auth algo sha1
     */
    authAlgoSha1: boolean;
    /**
     * Auth algo sha256
     */
    authAlgoSha256: boolean;
    /**
     * Auth algo sha384
     */
    authAlgoSha384: boolean;
    /**
     * Enc algo3des
     */
    encAlgo3des: boolean;
    /**
     * Enc algo aes128 cbc
     */
    encAlgoAes128Cbc: boolean;
    /**
     * Enc algo aes128 gcm
     */
    encAlgoAes128Gcm: boolean;
    /**
     * Enc algo aes256 cbc
     */
    encAlgoAes256Cbc: boolean;
    /**
     * Enc algo aes256 gcm
     */
    encAlgoAes256Gcm: boolean;
    /**
     * Enc algo chacha20 poly1305
     */
    encAlgoChacha20Poly1305: boolean;
    /**
     * Enc algo rc4
     */
    encAlgoRc4: boolean;
    /**
     * Keyxchg algo dhe
     */
    keyxchgAlgoDhe: boolean;
    /**
     * Keyxchg algo ecdhe
     */
    keyxchgAlgoEcdhe: boolean;
    /**
     * Keyxchg algo rsa
     */
    keyxchgAlgoRsa: boolean;
    /**
     * Max version
     */
    maxVersion: string;
    /**
     * Min version
     */
    minVersion: string;
}

export interface DecryptionRuleType {
    /**
     * Ssl forward proxy
     */
    sslForwardProxy?: outputs.DecryptionRuleTypeSslForwardProxy;
    /**
     * add the certificate name for SSL inbound inspection
     *
     * > ℹ️ **Note:** You must specify exactly one of `sslForwardProxy` and `sslInboundInspection`.
     */
    sslInboundInspection?: outputs.DecryptionRuleTypeSslInboundInspection;
}

export interface DecryptionRuleTypeSslForwardProxy {
}

export interface DecryptionRuleTypeSslInboundInspection {
    /**
     * List of certificate names for SSL inbound inspection
     */
    certificates?: string[];
}

export interface DeviceRedistributionCollectorRedistributionCollector {
    /**
     * User-ID collector interface
     */
    interface?: string;
}

export interface DhcpInterfaceRelay {
    /**
     * Ip
     */
    ip: outputs.DhcpInterfaceRelayIp;
}

export interface DhcpInterfaceRelayIp {
    /**
     * Enabled?
     */
    enabled: boolean;
    /**
     * Server
     */
    servers: string[];
}

export interface DhcpInterfaceServer {
    /**
     * List of IP address pools
     */
    ipPools?: string[];
    /**
     * DHCP server mode
     */
    mode?: string;
    /**
     * Option
     */
    option?: outputs.DhcpInterfaceServerOption;
    /**
     * Ping IP before allocating?
     */
    probeIp?: boolean;
    /**
     * List of IP reservations
     */
    reserveds?: outputs.DhcpInterfaceServerReserved[];
}

export interface DhcpInterfaceServerOption {
    /**
     * Dns
     */
    dns?: outputs.DhcpInterfaceServerOptionDns;
    /**
     * DNS suffix
     */
    dnsSuffix?: string;
    /**
     * Default gateway
     */
    gateway?: string;
    /**
     * Inheritance
     */
    inheritance?: outputs.DhcpInterfaceServerOptionInheritance;
    /**
     * Lease
     */
    lease?: outputs.DhcpInterfaceServerOptionLease;
    /**
     * Nis
     */
    nis?: outputs.DhcpInterfaceServerOptionNis;
    /**
     * Ntp
     */
    ntp?: outputs.DhcpInterfaceServerOptionNtp;
    /**
     * POP3 server
     */
    pop3Server?: string;
    /**
     * SMTP server
     */
    smtpServer?: string;
    /**
     * Subnet mask
     */
    subnetMask?: string;
    /**
     * Custom DHCP options
     */
    userDefineds?: outputs.DhcpInterfaceServerOptionUserDefined[];
    /**
     * Wins
     */
    wins?: outputs.DhcpInterfaceServerOptionWins;
}

export interface DhcpInterfaceServerOptionDns {
    /**
     * Primary DNS server
     */
    primary?: string;
    /**
     * Secondary DNS server
     */
    secondary?: string;
}

export interface DhcpInterfaceServerOptionInheritance {
    /**
     * Interface from which to inherit lease options
     */
    source?: string;
}

export interface DhcpInterfaceServerOptionLease {
    /**
     * DHCP lease timeout (minutes)
     */
    timeout?: number;
    /**
     * Unlimited
     *
     * > ℹ️ **Note:** You must specify exactly one of `timeout` and `unlimited`.
     */
    unlimited?: outputs.DhcpInterfaceServerOptionLeaseUnlimited;
}

export interface DhcpInterfaceServerOptionLeaseUnlimited {
}

export interface DhcpInterfaceServerOptionNis {
    /**
     * Primary NIS server
     */
    primary?: string;
    /**
     * Secondary NIS server
     */
    secondary?: string;
}

export interface DhcpInterfaceServerOptionNtp {
    /**
     * Primary NTP server
     */
    primary?: string;
    /**
     * Secondary NTP server
     */
    secondary?: string;
}

export interface DhcpInterfaceServerOptionUserDefined {
    /**
     * Ascii
     */
    asciis?: string[];
    /**
     * Option code
     */
    code?: number;
    /**
     * Hex
     */
    hexes?: string[];
    /**
     * Inherited from DHCP server inheritance source?
     */
    inherited: boolean;
    /**
     * Ip
     */
    ips?: string[];
    /**
     * Option name
     */
    name: string;
}

export interface DhcpInterfaceServerOptionWins {
    /**
     * Primary WINS server
     */
    primary?: string;
    /**
     * Secondary WINS server
     */
    secondary?: string;
}

export interface DhcpInterfaceServerReserved {
    /**
     * Reservation description
     */
    description?: string;
    /**
     * Reserved MAC address
     */
    mac?: string;
    /**
     * Reserved IP address
     */
    name?: string;
}

export interface DnsProxyCache {
    /**
     * Cache EDNS UDP response
     */
    cacheEdns: boolean;
    /**
     * Turn on caching for this DNS object
     */
    enabled: boolean;
    /**
     * Max ttl
     */
    maxTtl?: outputs.DnsProxyCacheMaxTtl;
}

export interface DnsProxyCacheMaxTtl {
    /**
     * Enable max ttl for this DNS object
     */
    enabled: boolean;
    /**
     * Time in seconds after which entry is cleared
     */
    timeToLive?: number;
}

export interface DnsProxyDefault {
    /**
     * Inheritance
     */
    inheritance?: outputs.DnsProxyDefaultInheritance;
    /**
     * Primary DNS Name server IP address
     */
    primary: string;
    /**
     * Secondary DNS Name server IP address
     */
    secondary?: string;
}

export interface DnsProxyDefaultInheritance {
    /**
     * Dynamic interface
     */
    source?: string;
}

export interface DnsProxyDomainServer {
    /**
     * Enable caching for this DNS proxy rule?
     */
    cacheable?: boolean;
    /**
     * Domain names(s) that will be matched
     */
    domainNames?: string[];
    /**
     * Proxy rule name
     */
    name: string;
    /**
     * Primary DNS server IP address
     */
    primary: string;
    /**
     * Secondary DNS server IP address
     */
    secondary?: string;
}

export interface DnsProxyStaticEntry {
    /**
     * Address
     */
    addresses: string[];
    /**
     * Fully qualified domain name
     */
    domain: string;
    /**
     * Static entry name
     */
    name: string;
}

export interface DnsProxyTcpQueries {
    /**
     * Turn on forwarding of TCP DNS queries?
     */
    enabled: boolean;
    /**
     * Upper limit on number of concurrent TCP DNS requests
     */
    maxPendingRequests: number;
}

export interface DnsProxyUdpQueries {
    /**
     * Retries
     */
    retries?: outputs.DnsProxyUdpQueriesRetries;
}

export interface DnsProxyUdpQueriesRetries {
    /**
     * Maximum number of retries before trying next name server
     */
    attempts: number;
    /**
     * Time in seconds for another request to be sent
     */
    interval: number;
}

export interface DnsSecurityProfileBotnetDomains {
    /**
     * DNS categories
     */
    dnsSecurityCategories?: outputs.DnsSecurityProfileBotnetDomainsDnsSecurityCategory[];
    /**
     * Dynamic lists of DNS domains
     */
    lists?: outputs.DnsSecurityProfileBotnetDomainsList[];
    /**
     * DNS sinkhole settings
     */
    sinkhole?: outputs.DnsSecurityProfileBotnetDomainsSinkhole;
    /**
     * DNS security overrides
     */
    whitelists?: outputs.DnsSecurityProfileBotnetDomainsWhitelist[];
}

export interface DnsSecurityProfileBotnetDomainsDnsSecurityCategory {
    /**
     * Action
     */
    action: string;
    /**
     * Log level
     */
    logLevel: string;
    /**
     * Name
     */
    name?: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
}

export interface DnsSecurityProfileBotnetDomainsList {
    /**
     * Action
     */
    action?: outputs.DnsSecurityProfileBotnetDomainsListAction;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
}

export interface DnsSecurityProfileBotnetDomainsListAction {
    /**
     * Alert
     */
    alert?: outputs.DnsSecurityProfileBotnetDomainsListActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    allow?: outputs.DnsSecurityProfileBotnetDomainsListActionAllow;
    /**
     * Block
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    block?: outputs.DnsSecurityProfileBotnetDomainsListActionBlock;
    /**
     * Sinkhole
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    sinkhole?: outputs.DnsSecurityProfileBotnetDomainsListActionSinkhole;
}

export interface DnsSecurityProfileBotnetDomainsListActionAlert {
}

export interface DnsSecurityProfileBotnetDomainsListActionAllow {
}

export interface DnsSecurityProfileBotnetDomainsListActionBlock {
}

export interface DnsSecurityProfileBotnetDomainsListActionSinkhole {
}

export interface DnsSecurityProfileBotnetDomainsSinkhole {
    /**
     * Ipv4 address
     */
    ipv4Address?: string;
    /**
     * Ipv6 address
     */
    ipv6Address?: string;
}

export interface DnsSecurityProfileBotnetDomainsWhitelist {
    /**
     * Description
     */
    description?: string;
    /**
     * DNS domain or FQDN to be whitelisted
     */
    name: string;
}

export interface DosProtectionProfileFlood {
    /**
     * Icmp
     */
    icmp?: outputs.DosProtectionProfileFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6?: outputs.DosProtectionProfileFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp?: outputs.DosProtectionProfileFloodOtherIp;
    /**
     * Tcp syn
     */
    tcpSyn?: outputs.DosProtectionProfileFloodTcpSyn;
    /**
     * Udp
     */
    udp?: outputs.DosProtectionProfileFloodUdp;
}

export interface DosProtectionProfileFloodIcmp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red?: outputs.DosProtectionProfileFloodIcmpRed;
}

export interface DosProtectionProfileFloodIcmpRed {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodIcmpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodIcmpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface DosProtectionProfileFloodIcmpv6 {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red?: outputs.DosProtectionProfileFloodIcmpv6Red;
}

export interface DosProtectionProfileFloodIcmpv6Red {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodIcmpv6RedBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodIcmpv6RedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface DosProtectionProfileFloodOtherIp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red?: outputs.DosProtectionProfileFloodOtherIpRed;
}

export interface DosProtectionProfileFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodOtherIpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodOtherIpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface DosProtectionProfileFloodTcpSyn {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.DosProtectionProfileFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies?: outputs.DosProtectionProfileFloodTcpSynSynCookies;
}

export interface DosProtectionProfileFloodTcpSynRed {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodTcpSynRedBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodTcpSynRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface DosProtectionProfileFloodTcpSynSynCookies {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodTcpSynSynCookiesBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodTcpSynSynCookiesBlock {
    /**
     * Duration
     */
    duration?: number;
}

export interface DosProtectionProfileFloodUdp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red?: outputs.DosProtectionProfileFloodUdpRed;
}

export interface DosProtectionProfileFloodUdpRed {
    /**
     * Activate rate
     */
    activateRate?: number;
    /**
     * Alarm rate
     */
    alarmRate?: number;
    /**
     * Block
     */
    block?: outputs.DosProtectionProfileFloodUdpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate?: number;
}

export interface DosProtectionProfileFloodUdpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface DosProtectionProfileResource {
    /**
     * Sessions
     */
    sessions?: outputs.DosProtectionProfileResourceSessions;
}

export interface DosProtectionProfileResourceSessions {
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Max concurrent limit
     */
    maxConcurrentLimit?: number;
}

export interface DosProtectionRuleAction {
    /**
     * Allow
     */
    allow?: outputs.DosProtectionRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    deny?: outputs.DosProtectionRuleActionDeny;
    /**
     * Protect
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    protect?: outputs.DosProtectionRuleActionProtect;
}

export interface DosProtectionRuleActionAllow {
}

export interface DosProtectionRuleActionDeny {
}

export interface DosProtectionRuleActionProtect {
}

export interface DosProtectionRuleProtection {
    /**
     * Aggregate
     */
    aggregate?: outputs.DosProtectionRuleProtectionAggregate;
    /**
     * Classified
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregate` and `classified`.
     */
    classified?: outputs.DosProtectionRuleProtectionClassified;
}

export interface DosProtectionRuleProtectionAggregate {
    /**
     * Aggregate DoS protection profile
     */
    profile: string;
}

export interface DosProtectionRuleProtectionClassified {
    /**
     * Classification criteria
     */
    classificationCriteria?: outputs.DosProtectionRuleProtectionClassifiedClassificationCriteria;
    /**
     * Classified DoS protection profile
     */
    profile: string;
}

export interface DosProtectionRuleProtectionClassifiedClassificationCriteria {
    /**
     * Address
     */
    address?: string;
}

export interface EthernetInterfaceLayer2 {
    /**
     * LLDP Settings
     */
    lldp?: outputs.EthernetInterfaceLayer2Lldp;
    /**
     * Assign interface to VLAN tag
     */
    vlanTag?: string;
}

export interface EthernetInterfaceLayer2Lldp {
    /**
     * Enable LLDP on Interface
     */
    enable: boolean;
}

export interface EthernetInterfaceLayer3 {
    /**
     * Ethernet Interfaces ARP configuration
     */
    arps?: outputs.EthernetInterfaceLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Ethernet Interfaces.
     */
    ddnsConfig?: outputs.EthernetInterfaceLayer3DdnsConfig;
    /**
     * Ethernet Interfaces DHCP Client Object
     */
    dhcpClient?: outputs.EthernetInterfaceLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile?: string;
    /**
     * Ethernet Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    ips?: outputs.EthernetInterfaceLayer3Ip[];
    /**
     * MTU
     */
    mtu: number;
    /**
     * Pppoe
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    pppoe?: outputs.EthernetInterfaceLayer3Pppoe;
}

export interface EthernetInterfaceLayer3Arp {
    /**
     * MAC address
     */
    hwAddress?: string;
    /**
     * IP address
     */
    name?: string;
}

export interface EthernetInterfaceLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp?: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface EthernetInterfaceLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Ethernet Interfaces DHCP ClientSend hostname
     */
    sendHostname?: outputs.EthernetInterfaceLayer3DhcpClientSendHostname;
}

export interface EthernetInterfaceLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface EthernetInterfaceLayer3Ip {
    /**
     * Ethernet Interface IP addresses name
     */
    name: string;
}

export interface EthernetInterfaceLayer3Pppoe {
    /**
     * Access concentrator
     */
    accessConcentrator?: string;
    /**
     * Authentication protocol
     */
    authentication?: string;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Passive
     */
    passive?: outputs.EthernetInterfaceLayer3PppoePassive;
    /**
     * Password
     */
    password: string;
    /**
     * Service
     */
    service?: string;
    /**
     * Static address
     */
    staticAddress?: outputs.EthernetInterfaceLayer3PppoeStaticAddress;
    /**
     * Username
     */
    username: string;
}

export interface EthernetInterfaceLayer3PppoePassive {
    /**
     * Passive Mode enabled
     */
    enable: boolean;
}

export interface EthernetInterfaceLayer3PppoeStaticAddress {
    /**
     * Static IP address
     */
    ip: string;
}

export interface EthernetInterfacePoe {
    /**
     * Enabled PoE?
     */
    poeEnabled: boolean;
    /**
     * PoE reserved power
     */
    poeRsvdPwr: number;
}

export interface EthernetInterfaceTap {
}

export interface ExternalDynamicListType {
    /**
     * Domain settings for Custom Domain type
     */
    domain?: outputs.ExternalDynamicListTypeDomain;
    /**
     * IMEI Configuration settings
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imei?: outputs.ExternalDynamicListTypeImei;
    /**
     * IMSI Config for Custom IMSI type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imsi?: outputs.ExternalDynamicListTypeImsi;
    /**
     * IP settings for Custom IP type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    ip?: outputs.ExternalDynamicListTypeIp;
    /**
     * Predefined IP settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedIp?: outputs.ExternalDynamicListTypePredefinedIp;
    /**
     * Predefined URL settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedUrl?: outputs.ExternalDynamicListTypePredefinedUrl;
    /**
     * URL settings for Custom URL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    url?: outputs.ExternalDynamicListTypeUrl;
}

export interface ExternalDynamicListTypeDomain {
    /**
     * Authentication settings for Custom Domain type
     */
    auth?: outputs.ExternalDynamicListTypeDomainAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Domain Exception List for Custom Domain type
     */
    exceptionLists?: string[];
    /**
     * Enable/Disable expand domain
     */
    expandDomain: boolean;
    /**
     * Update Schedule for Custom Domain type
     */
    recurring: outputs.ExternalDynamicListTypeDomainRecurring;
    /**
     * External URL for Custom Domain type
     */
    url: string;
}

export interface ExternalDynamicListTypeDomainAuth {
    /**
     * Password for Custom Domain authentication
     */
    password: string;
    /**
     * Username for Custom Domain authentication
     */
    username: string;
}

export interface ExternalDynamicListTypeDomainRecurring {
    /**
     * Daily settings for Domain recurring
     */
    daily?: outputs.ExternalDynamicListTypeDomainRecurringDaily;
    /**
     * Five minute settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute?: outputs.ExternalDynamicListTypeDomainRecurringFiveMinute;
    /**
     * Hourly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly?: outputs.ExternalDynamicListTypeDomainRecurringHourly;
    /**
     * Monthly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly?: outputs.ExternalDynamicListTypeDomainRecurringMonthly;
    /**
     * Weekly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly?: outputs.ExternalDynamicListTypeDomainRecurringWeekly;
}

export interface ExternalDynamicListTypeDomainRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for Domain
     */
    at: string;
}

export interface ExternalDynamicListTypeDomainRecurringFiveMinute {
}

export interface ExternalDynamicListTypeDomainRecurringHourly {
}

export interface ExternalDynamicListTypeDomainRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for domain
     */
    at: string;
    /**
     * Day setting for monthly Domain updates
     */
    dayOfMonth: number;
}

export interface ExternalDynamicListTypeDomainRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for Domain
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface ExternalDynamicListTypeImei {
    /**
     * IMEI Auth Cnfig for Custom IMEI type
     */
    auth?: outputs.ExternalDynamicListTypeImeiAuth;
    /**
     * IMEI Certificate Profile for Custom IMEI type
     */
    certificateProfile: string;
    /**
     * IMEI Description for Custom IMEI type
     */
    description?: string;
    /**
     * IMEI Exception List for Custom IMEI type
     */
    exceptionLists?: string[];
    /**
     * Recurring interval for IMEI updates
     */
    recurring: outputs.ExternalDynamicListTypeImeiRecurring;
    /**
     * IMEI URL for Custom IMEI type
     */
    url: string;
}

export interface ExternalDynamicListTypeImeiAuth {
    /**
     * IMEI Auth Password for Custom IMEI type
     */
    password: string;
    /**
     * IMEI Auth username for Custom IMEI type
     */
    username: string;
}

export interface ExternalDynamicListTypeImeiRecurring {
    /**
     * Daily interval settings for IMEI updates
     */
    daily?: outputs.ExternalDynamicListTypeImeiRecurringDaily;
    /**
     * Five-minute interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute?: outputs.ExternalDynamicListTypeImeiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly?: outputs.ExternalDynamicListTypeImeiRecurringHourly;
    /**
     * Monthly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly?: outputs.ExternalDynamicListTypeImeiRecurringMonthly;
    /**
     * Weekly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly?: outputs.ExternalDynamicListTypeImeiRecurringWeekly;
}

export interface ExternalDynamicListTypeImeiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMEI
     */
    at: string;
}

export interface ExternalDynamicListTypeImeiRecurringFiveMinute {
}

export interface ExternalDynamicListTypeImeiRecurringHourly {
}

export interface ExternalDynamicListTypeImeiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of month for IMEI updates
     */
    dayOfMonth: number;
}

export interface ExternalDynamicListTypeImeiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface ExternalDynamicListTypeImsi {
    /**
     * IMSI Auth Config for Custom IMSI type
     */
    auth?: outputs.ExternalDynamicListTypeImsiAuth;
    /**
     * IMSI Certificate Profile for Custom IMSI type
     */
    certificateProfile: string;
    /**
     * IMSI Description for Custom IMSI type
     */
    description?: string;
    /**
     * IMSI Exception List for Custom IMSI type
     */
    exceptionLists?: string[];
    /**
     * IMSI Recuring Config for Custom IMSI type
     */
    recurring: outputs.ExternalDynamicListTypeImsiRecurring;
    /**
     * IMSI URL for Custom IMSI type
     */
    url: string;
}

export interface ExternalDynamicListTypeImsiAuth {
    /**
     * IMSI Auth Password for Custom IMSI type
     */
    password: string;
    /**
     * IMSI Auth Username for Custom IMSI type
     */
    username: string;
}

export interface ExternalDynamicListTypeImsiRecurring {
    /**
     * Daily interval settings for IMSI updates
     */
    daily?: outputs.ExternalDynamicListTypeImsiRecurringDaily;
    /**
     * Five-minute interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute?: outputs.ExternalDynamicListTypeImsiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly?: outputs.ExternalDynamicListTypeImsiRecurringHourly;
    /**
     * Monthly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly?: outputs.ExternalDynamicListTypeImsiRecurringMonthly;
    /**
     * Weekly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly?: outputs.ExternalDynamicListTypeImsiRecurringWeekly;
}

export interface ExternalDynamicListTypeImsiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMSI
     */
    at: string;
}

export interface ExternalDynamicListTypeImsiRecurringFiveMinute {
}

export interface ExternalDynamicListTypeImsiRecurringHourly {
}

export interface ExternalDynamicListTypeImsiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of the month for monthly IMSI updates
     */
    dayOfMonth: number;
}

export interface ExternalDynamicListTypeImsiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface ExternalDynamicListTypeIp {
    /**
     * Authentication settings for Custom IP type
     */
    auth?: outputs.ExternalDynamicListTypeIpAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description?: string;
    /**
     * IP Exception List for Custom IP type
     */
    exceptionLists?: string[];
    /**
     * Update Schedule for Custom IP type
     */
    recurring: outputs.ExternalDynamicListTypeIpRecurring;
    /**
     * External URL for Custom IP type
     */
    url: string;
}

export interface ExternalDynamicListTypeIpAuth {
    /**
     * Password for Custom IP authentication
     */
    password: string;
    /**
     * Username for Custom IP authentication
     */
    username: string;
}

export interface ExternalDynamicListTypeIpRecurring {
    /**
     * Daily settings for IP recurring
     */
    daily?: outputs.ExternalDynamicListTypeIpRecurringDaily;
    /**
     * Five minute settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute?: outputs.ExternalDynamicListTypeIpRecurringFiveMinute;
    /**
     * Hourly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly?: outputs.ExternalDynamicListTypeIpRecurringHourly;
    /**
     * Monthly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly?: outputs.ExternalDynamicListTypeIpRecurringMonthly;
    /**
     * Weekly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly?: outputs.ExternalDynamicListTypeIpRecurringWeekly;
}

export interface ExternalDynamicListTypeIpRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IP
     */
    at: string;
}

export interface ExternalDynamicListTypeIpRecurringFiveMinute {
}

export interface ExternalDynamicListTypeIpRecurringHourly {
}

export interface ExternalDynamicListTypeIpRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day setting for monthly IP updates
     */
    dayOfMonth: number;
}

export interface ExternalDynamicListTypeIpRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface ExternalDynamicListTypePredefinedIp {
    /**
     * Description
     */
    description?: string;
    /**
     * IP Exception List for Predefined IP type
     */
    exceptionLists?: string[];
    /**
     * URL source for Predefined IP type
     */
    url: string;
}

export interface ExternalDynamicListTypePredefinedUrl {
    /**
     * Description
     */
    description?: string;
    /**
     * URL Exception List for Predefined URL type
     */
    exceptionLists?: string[];
    /**
     * URL source for Predefined URL type
     */
    url: string;
}

export interface ExternalDynamicListTypeUrl {
    /**
     * Authentication settings for Custom URL type
     */
    auth?: outputs.ExternalDynamicListTypeUrlAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description?: string;
    /**
     * URL Exception List for Custom URL type
     */
    exceptionLists?: string[];
    /**
     * Update Schedule for Custom URL type
     */
    recurring: outputs.ExternalDynamicListTypeUrlRecurring;
    /**
     * External URL for Custom URL type
     */
    url: string;
}

export interface ExternalDynamicListTypeUrlAuth {
    /**
     * Password for Custom URL authentication
     */
    password: string;
    /**
     * Username for Custom URL authentication
     */
    username: string;
}

export interface ExternalDynamicListTypeUrlRecurring {
    /**
     * Daily settings for URL recurring
     */
    daily?: outputs.ExternalDynamicListTypeUrlRecurringDaily;
    /**
     * Five minute settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute?: outputs.ExternalDynamicListTypeUrlRecurringFiveMinute;
    /**
     * Hourly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly?: outputs.ExternalDynamicListTypeUrlRecurringHourly;
    /**
     * Monthly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly?: outputs.ExternalDynamicListTypeUrlRecurringMonthly;
    /**
     * Weekly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly?: outputs.ExternalDynamicListTypeUrlRecurringWeekly;
}

export interface ExternalDynamicListTypeUrlRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for URL
     */
    at: string;
}

export interface ExternalDynamicListTypeUrlRecurringFiveMinute {
}

export interface ExternalDynamicListTypeUrlRecurringHourly {
}

export interface ExternalDynamicListTypeUrlRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day setting for monthly URL updates
     */
    dayOfMonth: number;
}

export interface ExternalDynamicListTypeUrlRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface FileBlockingProfileRule {
    /**
     * The action to take when the rule match criteria is met
     */
    action: string;
    /**
     * The application transferring the files (App-ID naming)
     */
    applications: string[];
    /**
     * The direction of the file transfer
     */
    direction: string;
    /**
     * The file type
     */
    fileTypes: string[];
    /**
     * The name of the file blocking rule
     */
    name: string;
}

export interface GeneralSettingGeneral {
    /**
     * Force admins to acknowledge login banner
     */
    ackLoginBanner: boolean;
    /**
     * DNS domain
     */
    domain?: string;
    /**
     * Geographic coordinates
     */
    geoLocation?: outputs.GeneralSettingGeneralGeoLocation;
    /**
     * Locale
     */
    locale: string;
    /**
     * Logon banner
     */
    loginBanner?: string;
    /**
     * Setting
     */
    setting?: outputs.GeneralSettingGeneralSetting;
    /**
     * SSL/TLS service profile
     */
    sslTlsServiceProfile?: string;
    /**
     * Timezone
     */
    timezone?: string;
}

export interface GeneralSettingGeneralGeoLocation {
    /**
     * Latitude
     */
    latitude: string;
    /**
     * Longitude
     */
    longitude: string;
}

export interface GeneralSettingGeneralSetting {
    /**
     * Use hypervisor assigned MAC addresses
     */
    autoMacDetect: boolean;
    /**
     * Fail open
     */
    failOpen: boolean;
    /**
     * Management
     */
    management?: outputs.GeneralSettingGeneralSettingManagement;
    /**
     * Tunnel acceleration
     */
    tunnelAcceleration: boolean;
}

export interface GeneralSettingGeneralSettingManagement {
    /**
     * Automatically acquire commit lock
     */
    autoAcquireCommitLock: boolean;
    /**
     * Certificate expiration check
     */
    enableCertificateExpirationCheck: boolean;
}

export interface GetAddressGroupDynamic {
    /**
     * Tag based filter defining group membership
     */
    filter: string;
}

export interface GetAddressGroupListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Dynamic
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic` and `static`.
     */
    dynamic: outputs.GetAddressGroupListDataDynamic;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the address group
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Static
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic` and `static`.
     */
    statics: string[];
    /**
     * Tags for address group object
     */
    tags: string[];
    tfid: string;
}

export interface GetAddressGroupListDataDynamic {
    /**
     * Tag based filter defining group membership
     */
    filter: string;
}

export interface GetAddressListData {
    /**
     * The description of the address object
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Fully qualified domain name
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn`, `ipNetmask`, `ipRange`, and `ipWildcard`.
     */
    fqdn: string;
    /**
     * The UUID of the address object
     */
    id: string;
    /**
     * IP address with or without CIDR notation
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn`, `ipNetmask`, `ipRange`, and `ipWildcard`.
     */
    ipNetmask: string;
    /**
     * Ip range
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn`, `ipNetmask`, `ipRange`, and `ipWildcard`.
     */
    ipRange: string;
    /**
     * IP wildcard mask
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn`, `ipNetmask`, `ipRange`, and `ipWildcard`.
     */
    ipWildcard: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tags assocaited with the address object
     */
    tags: string[];
    tfid: string;
}

export interface GetAggregateInterfaceLayer2 {
    /**
     * Lacp
     */
    lacp: outputs.GetAggregateInterfaceLayer2Lacp;
    /**
     * VLAN tag
     */
    vlanTag: string;
}

export interface GetAggregateInterfaceLayer2Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface GetAggregateInterfaceLayer3 {
    /**
     * Aggregate Ethernet ARP configuration
     */
    arps: outputs.GetAggregateInterfaceLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Aggregate Interface.
     */
    ddnsConfig: outputs.GetAggregateInterfaceLayer3DdnsConfig;
    /**
     * Aggregate Ethernet DHCP Client Object
     */
    dhcpClient: outputs.GetAggregateInterfaceLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Aggregate Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    ips: outputs.GetAggregateInterfaceLayer3Ip[];
    /**
     * Lacp
     */
    lacp: outputs.GetAggregateInterfaceLayer3Lacp;
    /**
     * MTU
     */
    mtu: number;
}

export interface GetAggregateInterfaceLayer3Arp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetAggregateInterfaceLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetAggregateInterfaceLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Aggregate Ethernet DHCP Client Send hostname
     */
    sendHostname: outputs.GetAggregateInterfaceLayer3DhcpClientSendHostname;
}

export interface GetAggregateInterfaceLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetAggregateInterfaceLayer3Ip {
    /**
     * Aggregate Interface IP addresses name
     */
    name: string;
}

export interface GetAggregateInterfaceLayer3Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface GetAggregateInterfaceListData {
    /**
     * Aggregate interface description
     */
    comment: string;
    /**
     * Default interface assignment
     */
    defaultValue: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Layer2
     *
     * > ℹ️ **Note:** You must specify exactly one of `layer2` and `layer3`.
     */
    layer2: outputs.GetAggregateInterfaceListDataLayer2;
    /**
     * Aggregate Interface Layer 3 configuration
     *
     * > ℹ️ **Note:** You must specify exactly one of `layer2` and `layer3`.
     */
    layer3: outputs.GetAggregateInterfaceListDataLayer3;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetAggregateInterfaceListDataLayer2 {
    /**
     * Lacp
     */
    lacp: outputs.GetAggregateInterfaceListDataLayer2Lacp;
    /**
     * VLAN tag
     */
    vlanTag: string;
}

export interface GetAggregateInterfaceListDataLayer2Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface GetAggregateInterfaceListDataLayer3 {
    /**
     * Aggregate Ethernet ARP configuration
     */
    arps: outputs.GetAggregateInterfaceListDataLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Aggregate Interface.
     */
    ddnsConfig: outputs.GetAggregateInterfaceListDataLayer3DdnsConfig;
    /**
     * Aggregate Ethernet DHCP Client Object
     */
    dhcpClient: outputs.GetAggregateInterfaceListDataLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Aggregate Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    ips: outputs.GetAggregateInterfaceListDataLayer3Ip[];
    /**
     * Lacp
     */
    lacp: outputs.GetAggregateInterfaceListDataLayer3Lacp;
    /**
     * MTU
     */
    mtu: number;
}

export interface GetAggregateInterfaceListDataLayer3Arp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetAggregateInterfaceListDataLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetAggregateInterfaceListDataLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Aggregate Ethernet DHCP Client Send hostname
     */
    sendHostname: outputs.GetAggregateInterfaceListDataLayer3DhcpClientSendHostname;
}

export interface GetAggregateInterfaceListDataLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetAggregateInterfaceListDataLayer3Ip {
    /**
     * Aggregate Interface IP addresses name
     */
    name: string;
}

export interface GetAggregateInterfaceListDataLayer3Lacp {
    /**
     * Enable LACP?
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Maximum number of physical ports bundled in the LAG
     */
    maxPorts: number;
    /**
     * Mode
     */
    mode: string;
    /**
     * LACP system priority in system ID
     */
    systemPriority: number;
    /**
     * Transmission mode
     */
    transmissionRate: string;
}

export interface GetAntiSpywareProfileListData {
    /**
     * Cloud inline analysis
     */
    cloudInlineAnalysis: boolean;
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the anti-spyware profile
     */
    id: string;
    /**
     * Inline exception edl url
     */
    inlineExceptionEdlUrls: string[];
    /**
     * Inline exception ip address
     */
    inlineExceptionIpAddresses: string[];
    /**
     * Mica engine spyware enabled
     */
    micaEngineSpywareEnableds: outputs.GetAntiSpywareProfileListDataMicaEngineSpywareEnabled[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Rules
     */
    rules: outputs.GetAntiSpywareProfileListDataRule[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Threat exception
     */
    threatExceptions: outputs.GetAntiSpywareProfileListDataThreatException[];
}

export interface GetAntiSpywareProfileListDataMicaEngineSpywareEnabled {
    /**
     * Inline policy action
     */
    inlinePolicyAction: string;
    /**
     * Name
     */
    name: string;
}

export interface GetAntiSpywareProfileListDataRule {
    /**
     * anti spyware profiles rules default action
     */
    action: outputs.GetAntiSpywareProfileListDataRuleAction;
    /**
     * Category
     */
    category: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * Severity
     */
    severities: string[];
    /**
     * Threat name
     */
    threatName: string;
}

export interface GetAntiSpywareProfileListDataRuleAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareProfileListDataRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareProfileListDataRuleActionAllow;
    /**
     * anti spyware profiles rules action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareProfileListDataRuleActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareProfileListDataRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareProfileListDataRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareProfileListDataRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareProfileListDataRuleActionResetServer;
}

export interface GetAntiSpywareProfileListDataRuleActionAlert {
}

export interface GetAntiSpywareProfileListDataRuleActionAllow {
}

export interface GetAntiSpywareProfileListDataRuleActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareProfileListDataRuleActionDrop {
}

export interface GetAntiSpywareProfileListDataRuleActionResetBoth {
}

export interface GetAntiSpywareProfileListDataRuleActionResetClient {
}

export interface GetAntiSpywareProfileListDataRuleActionResetServer {
}

export interface GetAntiSpywareProfileListDataThreatException {
    /**
     * anti spyware profiles threat exception default action
     */
    action: outputs.GetAntiSpywareProfileListDataThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps: outputs.GetAntiSpywareProfileListDataThreatExceptionExemptIp[];
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetAntiSpywareProfileListDataThreatExceptionAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareProfileListDataThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareProfileListDataThreatExceptionActionAllow;
    /**
     * anti spyware profiles threat exception action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareProfileListDataThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetAntiSpywareProfileListDataThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareProfileListDataThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareProfileListDataThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareProfileListDataThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareProfileListDataThreatExceptionActionResetServer;
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionAlert {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionAllow {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionDefault {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionDrop {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionResetBoth {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionResetClient {
}

export interface GetAntiSpywareProfileListDataThreatExceptionActionResetServer {
}

export interface GetAntiSpywareProfileListDataThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface GetAntiSpywareProfileMicaEngineSpywareEnabled {
    /**
     * Inline policy action
     */
    inlinePolicyAction: string;
    /**
     * Name
     */
    name: string;
}

export interface GetAntiSpywareProfileRule {
    /**
     * anti spyware profiles rules default action
     */
    action: outputs.GetAntiSpywareProfileRuleAction;
    /**
     * Category
     */
    category: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * Severity
     */
    severities: string[];
    /**
     * Threat name
     */
    threatName: string;
}

export interface GetAntiSpywareProfileRuleAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareProfileRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareProfileRuleActionAllow;
    /**
     * anti spyware profiles rules action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareProfileRuleActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareProfileRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareProfileRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareProfileRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareProfileRuleActionResetServer;
}

export interface GetAntiSpywareProfileRuleActionAlert {
}

export interface GetAntiSpywareProfileRuleActionAllow {
}

export interface GetAntiSpywareProfileRuleActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareProfileRuleActionDrop {
}

export interface GetAntiSpywareProfileRuleActionResetBoth {
}

export interface GetAntiSpywareProfileRuleActionResetClient {
}

export interface GetAntiSpywareProfileRuleActionResetServer {
}

export interface GetAntiSpywareProfileThreatException {
    /**
     * anti spyware profiles threat exception default action
     */
    action: outputs.GetAntiSpywareProfileThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps: outputs.GetAntiSpywareProfileThreatExceptionExemptIp[];
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetAntiSpywareProfileThreatExceptionAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareProfileThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareProfileThreatExceptionActionAllow;
    /**
     * anti spyware profiles threat exception action block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareProfileThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetAntiSpywareProfileThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareProfileThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareProfileThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareProfileThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareProfileThreatExceptionActionResetServer;
}

export interface GetAntiSpywareProfileThreatExceptionActionAlert {
}

export interface GetAntiSpywareProfileThreatExceptionActionAllow {
}

export interface GetAntiSpywareProfileThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareProfileThreatExceptionActionDefault {
}

export interface GetAntiSpywareProfileThreatExceptionActionDrop {
}

export interface GetAntiSpywareProfileThreatExceptionActionResetBoth {
}

export interface GetAntiSpywareProfileThreatExceptionActionResetClient {
}

export interface GetAntiSpywareProfileThreatExceptionActionResetServer {
}

export interface GetAntiSpywareProfileThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface GetAntiSpywareSignatureDefaultAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareSignatureDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareSignatureDefaultActionAllow;
    /**
     * anti spyware signature block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareSignatureDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareSignatureDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareSignatureDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareSignatureDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareSignatureDefaultActionResetServer;
}

export interface GetAntiSpywareSignatureDefaultActionAlert {
}

export interface GetAntiSpywareSignatureDefaultActionAllow {
}

export interface GetAntiSpywareSignatureDefaultActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareSignatureDefaultActionDrop {
}

export interface GetAntiSpywareSignatureDefaultActionResetBoth {
}

export interface GetAntiSpywareSignatureDefaultActionResetClient {
}

export interface GetAntiSpywareSignatureDefaultActionResetServer {
}

export interface GetAntiSpywareSignatureListData {
    /**
     * Bugtraq
     */
    bugtraqs: string[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Cve
     */
    cves: string[];
    /**
     * anti spyware signature default action
     */
    defaultAction: outputs.GetAntiSpywareSignatureListDataDefaultAction;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Direction
     */
    direction: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Reference
     */
    references: string[];
    /**
     * Severity
     */
    severity: string;
    /**
     * anti spyware signature
     */
    signature: outputs.GetAntiSpywareSignatureListDataSignature;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * threat id range <15000-18000> and <6900001-7000000>
     */
    threatId: string;
    /**
     * Threatname
     */
    threatname: string;
    /**
     * Vendor
     */
    vendors: string[];
}

export interface GetAntiSpywareSignatureListDataDefaultAction {
    /**
     * Alert
     */
    alert: outputs.GetAntiSpywareSignatureListDataDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetAntiSpywareSignatureListDataDefaultActionAllow;
    /**
     * anti spyware signature block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetAntiSpywareSignatureListDataDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetAntiSpywareSignatureListDataDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetAntiSpywareSignatureListDataDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetAntiSpywareSignatureListDataDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetAntiSpywareSignatureListDataDefaultActionResetServer;
}

export interface GetAntiSpywareSignatureListDataDefaultActionAlert {
}

export interface GetAntiSpywareSignatureListDataDefaultActionAllow {
}

export interface GetAntiSpywareSignatureListDataDefaultActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareSignatureListDataDefaultActionDrop {
}

export interface GetAntiSpywareSignatureListDataDefaultActionResetBoth {
}

export interface GetAntiSpywareSignatureListDataDefaultActionResetClient {
}

export interface GetAntiSpywareSignatureListDataDefaultActionResetServer {
}

export interface GetAntiSpywareSignatureListDataSignature {
    /**
     * anti spyware signature combination
     */
    combination: outputs.GetAntiSpywareSignatureListDataSignatureCombination;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards: outputs.GetAntiSpywareSignatureListDataSignatureStandard[];
}

export interface GetAntiSpywareSignatureListDataSignatureCombination {
    /**
     * And condition
     */
    andConditions: outputs.GetAntiSpywareSignatureListDataSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * anti spyware time attribute
     */
    timeAttribute: outputs.GetAntiSpywareSignatureListDataSignatureCombinationTimeAttribute;
}

export interface GetAntiSpywareSignatureListDataSignatureCombinationAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetAntiSpywareSignatureListDataSignatureCombinationAndConditionOrCondition[];
}

export interface GetAntiSpywareSignatureListDataSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Threat id
     */
    threatId: string;
}

export interface GetAntiSpywareSignatureListDataSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareSignatureListDataSignatureStandard {
    /**
     * And condition
     */
    andConditions: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrCondition[];
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Operator
     */
    operator: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperator;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     */
    greaterThan: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     */
    lessThan: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     */
    patternMatch: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetAntiSpywareSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureSignature {
    /**
     * anti spyware signature combination
     */
    combination: outputs.GetAntiSpywareSignatureSignatureCombination;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards: outputs.GetAntiSpywareSignatureSignatureStandard[];
}

export interface GetAntiSpywareSignatureSignatureCombination {
    /**
     * And condition
     */
    andConditions: outputs.GetAntiSpywareSignatureSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * anti spyware time attribute
     */
    timeAttribute: outputs.GetAntiSpywareSignatureSignatureCombinationTimeAttribute;
}

export interface GetAntiSpywareSignatureSignatureCombinationAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetAntiSpywareSignatureSignatureCombinationAndConditionOrCondition[];
}

export interface GetAntiSpywareSignatureSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Threat id
     */
    threatId: string;
}

export interface GetAntiSpywareSignatureSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetAntiSpywareSignatureSignatureStandard {
    /**
     * And condition
     */
    andConditions: outputs.GetAntiSpywareSignatureSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetAntiSpywareSignatureSignatureStandardAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrCondition[];
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Operator
     */
    operator: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperator;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     */
    greaterThan: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     */
    lessThan: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     */
    patternMatch: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetAntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAppOverrideRuleListData {
    /**
     * Application
     */
    application: string;
    /**
     * Description
     */
    description: string;
    /**
     * Destination
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Disabled
     */
    disabled: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * From
     */
    froms: string[];
    /**
     * Group tag
     */
    groupTag: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Negate destination
     */
    negateDestination: boolean;
    /**
     * Negate source
     */
    negateSource: boolean;
    /**
     * Port
     */
    port: string;
    /**
     * The position of a security rule
     */
    position: string;
    /**
     * Protocol
     */
    protocol: string;
    /**
     * Relative positioning rule. String must be one of these: `"before"`, `"after"`, `"top"`, `"bottom"`. If not specified, rule is created at the bottom of the ruleset.
     */
    relativePosition: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Source
     */
    sources: string[];
    /**
     * Tag
     */
    tags: string[];
    /**
     * The name or UUID of the rule to position this rule relative to. Required when `relativePosition` is `"before"` or `"after"`.
     */
    targetRule: string;
    tfid: string;
    /**
     * To
     */
    tos: string[];
}

export interface GetApplicationDefault {
    /**
     * Ident by icmp6 type
     */
    identByIcmp6Type: outputs.GetApplicationDefaultIdentByIcmp6Type;
    /**
     * Ident by icmp type
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIcmpType: outputs.GetApplicationDefaultIdentByIcmpType;
    /**
     * Ident by ip protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIpProtocol: string;
    /**
     * Port
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    ports: string[];
}

export interface GetApplicationDefaultIdentByIcmp6Type {
    /**
     * Code
     */
    code: string;
    /**
     * Type
     */
    type: string;
}

export interface GetApplicationDefaultIdentByIcmpType {
    /**
     * Code
     */
    code: string;
    /**
     * Type
     */
    type: string;
}

export interface GetApplicationFilterListData {
    /**
     * Category
     */
    categories: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * only True is a valid value
     */
    evasive: boolean;
    /**
     * only True is a valid value
     */
    excessiveBandwidthUse: boolean;
    /**
     * Exclude
     */
    excludes: string[];
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * only True is a valid value
     */
    hasKnownVulnerabilities: boolean;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * only True is a valid value
     */
    isSaas: boolean;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * only True is a valid value
     */
    newAppid: boolean;
    /**
     * only True is a valid value
     */
    pervasive: boolean;
    /**
     * only True is a valid value
     */
    proneToMisuse: boolean;
    /**
     * Risk
     */
    risks: number[];
    /**
     * Saas certifications
     */
    saasCertifications: string[];
    /**
     * Saas risk
     */
    saasRisks: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Subcategory
     */
    subcategories: string[];
    /**
     * Tagging
     */
    tagging: outputs.GetApplicationFilterListDataTagging;
    /**
     * Technology
     */
    technologies: string[];
    tfid: string;
    /**
     * only True is a valid value
     */
    transfersFiles: boolean;
    /**
     * only True is a valid value
     */
    tunnelsOtherApps: boolean;
    /**
     * only True is a valid value
     */
    usedByMalware: boolean;
}

export interface GetApplicationFilterListDataTagging {
    /**
     * No tag
     */
    noTag: boolean;
    /**
     * Tag
     *
     * > ℹ️ **Note:** You must specify exactly one of `noTag` and `tag`.
     */
    tags: string[];
}

export interface GetApplicationFilterTagging {
    /**
     * No tag
     */
    noTag: boolean;
    /**
     * Tag
     *
     * > ℹ️ **Note:** You must specify exactly one of `noTag` and `tag`.
     */
    tags: string[];
}

export interface GetApplicationGroupListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Members
     */
    members: string[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetApplicationListData {
    /**
     * Able to transfer file
     */
    ableToTransferFile: boolean;
    /**
     * Alg disable capability
     */
    algDisableCapability: string;
    /**
     * Category
     */
    category: string;
    /**
     * Consume big bandwidth
     */
    consumeBigBandwidth: boolean;
    /**
     * Data ident
     */
    dataIdent: boolean;
    /**
     * Default
     */
    default: outputs.GetApplicationListDataDefault;
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Evasive behavior
     */
    evasiveBehavior: boolean;
    /**
     * File type ident
     */
    fileTypeIdent: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Has known vulnerability
     */
    hasKnownVulnerability: boolean;
    /**
     * The UUID of the application
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * No appid caching
     */
    noAppidCaching: boolean;
    /**
     * Parent app
     */
    parentApp: string;
    /**
     * Pervasive use
     */
    pervasiveUse: boolean;
    /**
     * Prone to misuse
     */
    proneToMisuse: boolean;
    /**
     * Risk
     */
    risk: string;
    /**
     * Signature
     */
    signatures: outputs.GetApplicationListDataSignature[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Subcategory
     */
    subcategory: string;
    /**
     * timeout for half-close session in seconds
     */
    tcpHalfClosedTimeout: number;
    /**
     * timeout for session in timeWait state in seconds
     */
    tcpTimeWaitTimeout: number;
    /**
     * timeout in seconds
     */
    tcpTimeout: number;
    /**
     * Technology
     */
    technology: string;
    tfid: string;
    /**
     * timeout in seconds
     */
    timeout: number;
    /**
     * Tunnel applications
     */
    tunnelApplications: boolean;
    /**
     * Tunnel other application
     */
    tunnelOtherApplication: boolean;
    /**
     * timeout in seconds
     */
    udpTimeout: number;
    /**
     * Used by malware
     */
    usedByMalware: boolean;
    /**
     * Virus ident
     */
    virusIdent: boolean;
}

export interface GetApplicationListDataDefault {
    /**
     * Ident by icmp6 type
     */
    identByIcmp6Type: outputs.GetApplicationListDataDefaultIdentByIcmp6Type;
    /**
     * Ident by icmp type
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIcmpType: outputs.GetApplicationListDataDefaultIdentByIcmpType;
    /**
     * Ident by ip protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    identByIpProtocol: string;
    /**
     * Port
     *
     * > ℹ️ **Note:** You must specify exactly one of `identByIcmp6Type`, `identByIcmpType`, `identByIpProtocol`, and `port`.
     */
    ports: string[];
}

export interface GetApplicationListDataDefaultIdentByIcmp6Type {
    /**
     * Code
     */
    code: string;
    /**
     * Type
     */
    type: string;
}

export interface GetApplicationListDataDefaultIdentByIcmpType {
    /**
     * Code
     */
    code: string;
    /**
     * Type
     */
    type: string;
}

export interface GetApplicationListDataSignature {
    /**
     * And condition
     */
    andConditions: outputs.GetApplicationListDataSignatureAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetApplicationListDataSignatureAndCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetApplicationListDataSignatureAndConditionOrCondition[];
}

export interface GetApplicationListDataSignatureAndConditionOrCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Operator
     */
    operator: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperator;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    greaterThan: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    lessThan: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    patternMatch: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorPatternMatch;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * 4-byte hex value
     */
    mask: string;
    /**
     * Position
     */
    position: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationListDataSignatureAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetApplicationListDataSignatureAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationSignature {
    /**
     * And condition
     */
    andConditions: outputs.GetApplicationSignatureAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetApplicationSignatureAndCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Or condition
     */
    orConditions: outputs.GetApplicationSignatureAndConditionOrCondition[];
}

export interface GetApplicationSignatureAndConditionOrCondition {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Operator
     */
    operator: outputs.GetApplicationSignatureAndConditionOrConditionOperator;
}

export interface GetApplicationSignatureAndConditionOrConditionOperator {
    /**
     * Equal to
     */
    equalTo: outputs.GetApplicationSignatureAndConditionOrConditionOperatorEqualTo;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    greaterThan: outputs.GetApplicationSignatureAndConditionOrConditionOperatorGreaterThan;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    lessThan: outputs.GetApplicationSignatureAndConditionOrConditionOperatorLessThan;
    /**
     * Pattern match
     *
     * > ℹ️ **Note:** You must specify exactly one of `equalTo`, `greaterThan`, `lessThan`, and `patternMatch`.
     */
    patternMatch: outputs.GetApplicationSignatureAndConditionOrConditionOperatorPatternMatch;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * 4-byte hex value
     */
    mask: string;
    /**
     * Position
     */
    position: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationSignatureAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * Qualifier
     */
    qualifiers: outputs.GetApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Alphanumeric string [ 0-9a-zA-Z._-]
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetAuthenticationProfileListData {
    /**
     * The allowList of the authentication profile
     */
    allowLists: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the authentication profile
     */
    id: string;
    /**
     * Lockout object of the authentication profile
     */
    lockout: outputs.GetAuthenticationProfileListDataLockout;
    /**
     * method object of authentication profile
     */
    method: outputs.GetAuthenticationProfileListDataMethod;
    /**
     * Multi factor auth
     */
    multiFactorAuth: outputs.GetAuthenticationProfileListDataMultiFactorAuth;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Single sign on
     */
    singleSignOn: outputs.GetAuthenticationProfileListDataSingleSignOn;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * User domain
     */
    userDomain: string;
    /**
     * Username modifier
     */
    usernameModifier: string;
}

export interface GetAuthenticationProfileListDataLockout {
    /**
     * Lockout object - failedAttempts of authentication profile
     */
    failedAttempts: number;
    /**
     * Lockout object - lockout-time of authentication profile
     */
    lockoutTime: number;
}

export interface GetAuthenticationProfileListDataMethod {
    /**
     * Cloud
     */
    cloud: outputs.GetAuthenticationProfileListDataMethodCloud;
    /**
     * Kerberos
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    kerberos: outputs.GetAuthenticationProfileListDataMethodKerberos;
    /**
     * Ldap
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    ldap: outputs.GetAuthenticationProfileListDataMethodLdap;
    /**
     * Local database
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    localDatabase: outputs.GetAuthenticationProfileListDataMethodLocalDatabase;
    /**
     * Radius
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    radius: outputs.GetAuthenticationProfileListDataMethodRadius;
    /**
     * Saml idp
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    samlIdp: outputs.GetAuthenticationProfileListDataMethodSamlIdp;
    /**
     * Tacplus
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    tacplus: outputs.GetAuthenticationProfileListDataMethodTacplus;
}

export interface GetAuthenticationProfileListDataMethodCloud {
    /**
     * The tenant profile name
     */
    profileName: string;
}

export interface GetAuthenticationProfileListDataMethodKerberos {
    /**
     * method kerberos object realm of authentication profile
     */
    realm: string;
    /**
     * method kerberos object server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileListDataMethodLdap {
    /**
     * Login attribute
     */
    loginAttribute: string;
    /**
     * Passwd exp days
     */
    passwdExpDays: number;
    /**
     * Server profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileListDataMethodLocalDatabase {
}

export interface GetAuthenticationProfileListDataMethodRadius {
    /**
     * method radius object check group of authentication profile
     */
    checkgroup: boolean;
    /**
     * method radius object server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileListDataMethodSamlIdp {
    /**
     * Attribute name usergroup
     */
    attributeNameUsergroup: string;
    /**
     * Attribute name username
     */
    attributeNameUsername: string;
    /**
     * method object saml idp certificate profile of authentication profile
     */
    certificateProfile: string;
    /**
     * Enable single logout
     */
    enableSingleLogout: boolean;
    /**
     * Request signing certificate
     */
    requestSigningCertificate: string;
    /**
     * method object saml idp server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileListDataMethodTacplus {
    /**
     * method tacplus object check group of authentication profile
     */
    checkgroup: boolean;
    /**
     * method tacplus object check group of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileListDataMultiFactorAuth {
    /**
     * Factors
     */
    factors: string[];
    /**
     * Mfa enable
     */
    mfaEnable: boolean;
}

export interface GetAuthenticationProfileListDataSingleSignOn {
    /**
     * Kerberos keytab
     */
    kerberosKeytab: string;
    /**
     * Realm
     */
    realm: string;
}

export interface GetAuthenticationProfileLockout {
    /**
     * Lockout object - failedAttempts of authentication profile
     */
    failedAttempts: number;
    /**
     * Lockout object - lockout-time of authentication profile
     */
    lockoutTime: number;
}

export interface GetAuthenticationProfileMethod {
    /**
     * Cloud
     */
    cloud: outputs.GetAuthenticationProfileMethodCloud;
    /**
     * Kerberos
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    kerberos: outputs.GetAuthenticationProfileMethodKerberos;
    /**
     * Ldap
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    ldap: outputs.GetAuthenticationProfileMethodLdap;
    /**
     * Local database
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    localDatabase: outputs.GetAuthenticationProfileMethodLocalDatabase;
    /**
     * Radius
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    radius: outputs.GetAuthenticationProfileMethodRadius;
    /**
     * Saml idp
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    samlIdp: outputs.GetAuthenticationProfileMethodSamlIdp;
    /**
     * Tacplus
     *
     * > ℹ️ **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `localDatabase`, `radius`, `samlIdp`, and `tacplus`.
     */
    tacplus: outputs.GetAuthenticationProfileMethodTacplus;
}

export interface GetAuthenticationProfileMethodCloud {
    /**
     * The tenant profile name
     */
    profileName: string;
}

export interface GetAuthenticationProfileMethodKerberos {
    /**
     * method kerberos object realm of authentication profile
     */
    realm: string;
    /**
     * method kerberos object server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileMethodLdap {
    /**
     * Login attribute
     */
    loginAttribute: string;
    /**
     * Passwd exp days
     */
    passwdExpDays: number;
    /**
     * Server profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileMethodLocalDatabase {
}

export interface GetAuthenticationProfileMethodRadius {
    /**
     * method radius object check group of authentication profile
     */
    checkgroup: boolean;
    /**
     * method radius object server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileMethodSamlIdp {
    /**
     * Attribute name usergroup
     */
    attributeNameUsergroup: string;
    /**
     * Attribute name username
     */
    attributeNameUsername: string;
    /**
     * method object saml idp certificate profile of authentication profile
     */
    certificateProfile: string;
    /**
     * Enable single logout
     */
    enableSingleLogout: boolean;
    /**
     * Request signing certificate
     */
    requestSigningCertificate: string;
    /**
     * method object saml idp server profile of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileMethodTacplus {
    /**
     * method tacplus object check group of authentication profile
     */
    checkgroup: boolean;
    /**
     * method tacplus object check group of authentication profile
     */
    serverProfile: string;
}

export interface GetAuthenticationProfileMultiFactorAuth {
    /**
     * Factors
     */
    factors: string[];
    /**
     * Mfa enable
     */
    mfaEnable: boolean;
}

export interface GetAuthenticationProfileSingleSignOn {
    /**
     * Kerberos keytab
     */
    kerberosKeytab: string;
    /**
     * Realm
     */
    realm: string;
}

export interface GetAuthenticationRuleListData {
    /**
     * The authentication profile name
     */
    authenticationEnforcement: string;
    /**
     * The destination URL categories
     */
    categories: string[];
    /**
     * The description of the authentication rule
     */
    description: string;
    /**
     * The destination Host Integrity Profile (HIP)
     */
    destinationHips: string[];
    /**
     * The destination addresses
     */
    destinations: string[];
    /**
     * Device
     */
    device: string;
    /**
     * Is the authentication rule disabled?
     */
    disabled: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The source security zones
     */
    froms: string[];
    /**
     * Group tag
     */
    groupTag: string;
    /**
     * The source Host Integrity Profile (HIP)
     */
    hipProfiles: string[];
    /**
     * The UUID of the authentication rule
     */
    id: string;
    /**
     * Log authentication timeouts?
     */
    logAuthenticationTimeout: boolean;
    /**
     * The log forwarding profile name
     */
    logSetting: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Are the destination addresses negated?
     */
    negateDestination: boolean;
    /**
     * Are the source addresses negated?
     */
    negateSource: boolean;
    /**
     * The relative position of the rule
     */
    position: string;
    /**
     * Relative positioning rule. String must be one of these: `"before"`, `"after"`, `"top"`, `"bottom"`. If not specified, rule is created at the bottom of the ruleset.
     */
    relativePosition: string;
    /**
     * The destination ports
     */
    services: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * The source Host Integrity Profile (HIP)
     */
    sourceHips: string[];
    /**
     * The source users
     */
    sourceUsers: string[];
    /**
     * The source addresses
     */
    sources: string[];
    /**
     * The authentication rule tags
     */
    tags: string[];
    /**
     * The name or UUID of the rule to position this rule relative to. Required when `relativePosition` is `"before"` or `"after"`.
     */
    targetRule: string;
    tfid: string;
    /**
     * The authentication session timeout (seconds)
     */
    timeout: number;
    /**
     * The destination security zones
     */
    tos: string[];
}

export interface GetAuthenticationSequenceListData {
    /**
     * An ordered list of authentication profiles
     */
    authenticationProfiles: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the authentication sequence
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Use domain to determine authentication profile?
     */
    useDomainFindProfile: boolean;
}

export interface GetAuthenticationSettingAuthentication {
    /**
     * Accounting server profile
     */
    accountingServerProfile: string;
    /**
     * Authentication profile
     */
    authenticationProfile: string;
    /**
     * Certificate profile
     */
    certificateProfile: string;
}

export interface GetAuthenticationSettingListData {
    /**
     * Authentication
     */
    authentication: outputs.GetAuthenticationSettingListDataAuthentication;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetAuthenticationSettingListDataAuthentication {
    /**
     * Accounting server profile
     */
    accountingServerProfile: string;
    /**
     * Authentication profile
     */
    authenticationProfile: string;
    /**
     * Certificate profile
     */
    certificateProfile: string;
}

export interface GetAutoVpnClusterBranch {
    /**
     * BGP redistribution profile
     */
    bgpRedistributionProfile: string;
    /**
     * Interfaces
     */
    interfaces: outputs.GetAutoVpnClusterBranchInterface[];
    /**
     * Router
     */
    logicalRouter: string;
    /**
     * Branch firewall serial number
     */
    name: string;
    /**
     * Private interfaces
     */
    privateInterfaces: outputs.GetAutoVpnClusterBranchPrivateInterface[];
    /**
     * Site name
     */
    site: string;
}

export interface GetAutoVpnClusterBranchInterface {
    /**
     * DHCP IP
     */
    dhcpIp: string;
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterBranchInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterBranchInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterBranchPrivateInterface {
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterGateway {
    /**
     * Allow DIA to VPN failover on branch device for the hub?
     */
    allowDiaVpnFailover: boolean;
    /**
     * BGP redistribution file
     */
    bgpRedistributionProfile: string;
    /**
     * Interfaces
     */
    interfaces: outputs.GetAutoVpnClusterGatewayInterface[];
    /**
     * Router
     */
    logicalRouter: string;
    /**
     * Hub firewall serial number
     */
    name: string;
    /**
     * Priority
     */
    priority: string;
    /**
     * Private interfaces
     */
    privateInterfaces: outputs.GetAutoVpnClusterGatewayPrivateInterface[];
    /**
     * Site name
     */
    site: string;
}

export interface GetAutoVpnClusterGatewayInterface {
    /**
     * DHCP IP
     */
    dhcpIp: string;
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterGatewayInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterGatewayInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterGatewayPrivateInterface {
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterListData {
    /**
     * Branches
     */
    branches: outputs.GetAutoVpnClusterListDataBranch[];
    /**
     * Enable mesh between hubs?
     */
    enableMeshBetweenHubs: boolean;
    /**
     * Enable mesh interconnect?
     */
    enableMeshInterconnect: boolean;
    /**
     * Enable SD-WAN?
     */
    enableSdwan: boolean;
    /**
     * Hubs
     */
    gateways: outputs.GetAutoVpnClusterListDataGateway[];
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * VPN cluster name
     */
    name: string;
    tfid: string;
    /**
     * VPN cluster type
     */
    type: string;
}

export interface GetAutoVpnClusterListDataBranch {
    /**
     * BGP redistribution profile
     */
    bgpRedistributionProfile: string;
    /**
     * Interfaces
     */
    interfaces: outputs.GetAutoVpnClusterListDataBranchInterface[];
    /**
     * Router
     */
    logicalRouter: string;
    /**
     * Branch firewall serial number
     */
    name: string;
    /**
     * Private interfaces
     */
    privateInterfaces: outputs.GetAutoVpnClusterListDataBranchPrivateInterface[];
    /**
     * Site name
     */
    site: string;
}

export interface GetAutoVpnClusterListDataBranchInterface {
    /**
     * DHCP IP
     */
    dhcpIp: string;
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterListDataBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterListDataBranchPrivateInterface {
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterListDataBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterListDataGateway {
    /**
     * Allow DIA to VPN failover on branch device for the hub?
     */
    allowDiaVpnFailover: boolean;
    /**
     * BGP redistribution file
     */
    bgpRedistributionProfile: string;
    /**
     * Interfaces
     */
    interfaces: outputs.GetAutoVpnClusterListDataGatewayInterface[];
    /**
     * Router
     */
    logicalRouter: string;
    /**
     * Hub firewall serial number
     */
    name: string;
    /**
     * Priority
     */
    priority: string;
    /**
     * Private interfaces
     */
    privateInterfaces: outputs.GetAutoVpnClusterListDataGatewayPrivateInterface[];
    /**
     * Site name
     */
    site: string;
}

export interface GetAutoVpnClusterListDataGatewayInterface {
    /**
     * DHCP IP
     */
    dhcpIp: string;
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterListDataGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnClusterListDataGatewayPrivateInterface {
    /**
     * Ethernet interface
     */
    name: string;
    /**
     * Sdwan link settings
     */
    sdwanLinkSettings: outputs.GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettings;
}

export interface GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettings {
    /**
     * Next hop gateway
     */
    sdwanGateway: string;
    /**
     * SD-WAN interface profile
     */
    sdwanInterfaceProfile: string;
    /**
     * Upstream nat
     */
    upstreamNat: outputs.GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat;
}

export interface GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNat {
    /**
     * Upstream NAT?
     */
    enable: boolean;
    /**
     * Static ip
     */
    staticIp: outputs.GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp;
}

export interface GetAutoVpnClusterListDataGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIp {
    /**
     * FQDN
     */
    fqdn: string;
    /**
     * IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetAutoVpnSettingAsRange {
    /**
     * End
     */
    end: number;
    /**
     * Start
     */
    start: number;
}

export interface GetBandwidthAllocationListData {
    /**
     * bandwidth to allocate in Mbps
     */
    allocatedBandwidth: number;
    /**
     * name of the aggregated bandwidth region
     */
    name: string;
    /**
     * Qos
     */
    qos: outputs.GetBandwidthAllocationListDataQos;
    /**
     * Spn name list
     */
    spnNameLists: string[];
    tfid: string;
}

export interface GetBandwidthAllocationListDataQos {
    /**
     * Customized
     */
    customized: boolean;
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Guaranteed ratio
     */
    guaranteedRatio: number;
    /**
     * Profile
     */
    profile: string;
}

export interface GetBandwidthAllocationQos {
    /**
     * Customized
     */
    customized: boolean;
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Guaranteed ratio
     */
    guaranteedRatio: number;
    /**
     * Profile
     */
    profile: string;
}

export interface GetBgpAddressFamilyProfileIpv4 {
    /**
     * Multicast
     */
    multicast: outputs.GetBgpAddressFamilyProfileIpv4Multicast;
    /**
     * Unicast
     */
    unicast: outputs.GetBgpAddressFamilyProfileIpv4Unicast;
}

export interface GetBgpAddressFamilyProfileIpv4Multicast {
    /**
     * Add path
     */
    addPath: outputs.GetBgpAddressFamilyProfileIpv4MulticastAddPath;
    /**
     * Allowas in
     */
    allowasIn: outputs.GetBgpAddressFamilyProfileIpv4MulticastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap: string;
    /**
     * Enable?
     */
    enable: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix: outputs.GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpAddressFamilyProfileIpv4MulticastNextHop;
    /**
     * Orf
     */
    orf: outputs.GetBgpAddressFamilyProfileIpv4MulticastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs: outputs.GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient: boolean;
    /**
     * Send community
     */
    sendCommunity: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo: boolean;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs: boolean;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin: outputs.GetBgpAddressFamilyProfileIpv4MulticastAllowasInOrigin;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastAllowasInOrigin {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefix {
    /**
     * Action
     */
    action: outputs.GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold: number;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixAction {
    /**
     * Restart
     */
    restart: outputs.GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly: outputs.GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnly;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval: number;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnly {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastNextHop {
    /**
     * Self
     */
    self: outputs.GetBgpAddressFamilyProfileIpv4MulticastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce: outputs.GetBgpAddressFamilyProfileIpv4MulticastNextHopSelfForce;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastNextHopSelf {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastNextHopSelfForce {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList: string;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAs {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs: outputs.GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAs;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAll {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAs {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunity {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard: outputs.GetBgpAddressFamilyProfileIpv4MulticastSendCommunityStandard;
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunityAll {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunityBoth {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunityExtended {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunityLarge {
}

export interface GetBgpAddressFamilyProfileIpv4MulticastSendCommunityStandard {
}

export interface GetBgpAddressFamilyProfileIpv4Unicast {
    /**
     * Add path
     */
    addPath: outputs.GetBgpAddressFamilyProfileIpv4UnicastAddPath;
    /**
     * Allowas in
     */
    allowasIn: outputs.GetBgpAddressFamilyProfileIpv4UnicastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap: string;
    /**
     * Enable?
     */
    enable: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix: outputs.GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpAddressFamilyProfileIpv4UnicastNextHop;
    /**
     * Orf
     */
    orf: outputs.GetBgpAddressFamilyProfileIpv4UnicastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs: outputs.GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient: boolean;
    /**
     * Send community
     */
    sendCommunity: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo: boolean;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs: boolean;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin: outputs.GetBgpAddressFamilyProfileIpv4UnicastAllowasInOrigin;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastAllowasInOrigin {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefix {
    /**
     * Action
     */
    action: outputs.GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold: number;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixAction {
    /**
     * Restart
     */
    restart: outputs.GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly: outputs.GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnly;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval: number;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnly {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastNextHop {
    /**
     * Self
     */
    self: outputs.GetBgpAddressFamilyProfileIpv4UnicastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce: outputs.GetBgpAddressFamilyProfileIpv4UnicastNextHopSelfForce;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastNextHopSelf {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastNextHopSelfForce {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList: string;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAs {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs: outputs.GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAs;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAll {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAs {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunity {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard: outputs.GetBgpAddressFamilyProfileIpv4UnicastSendCommunityStandard;
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunityAll {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunityBoth {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunityExtended {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunityLarge {
}

export interface GetBgpAddressFamilyProfileIpv4UnicastSendCommunityStandard {
}

export interface GetBgpAddressFamilyProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * IPv4 Address Family
     */
    ipv4: outputs.GetBgpAddressFamilyProfileListDataIpv4;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpAddressFamilyProfileListDataIpv4 {
    /**
     * Multicast
     */
    multicast: outputs.GetBgpAddressFamilyProfileListDataIpv4Multicast;
    /**
     * Unicast
     */
    unicast: outputs.GetBgpAddressFamilyProfileListDataIpv4Unicast;
}

export interface GetBgpAddressFamilyProfileListDataIpv4Multicast {
    /**
     * Add path
     */
    addPath: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastAddPath;
    /**
     * Allowas in
     */
    allowasIn: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap: string;
    /**
     * Enable?
     */
    enable: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastNextHop;
    /**
     * Orf
     */
    orf: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient: boolean;
    /**
     * Send community
     */
    sendCommunity: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo: boolean;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs: boolean;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastAllowasInOrigin;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastAllowasInOrigin {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefix {
    /**
     * Action
     */
    action: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold: number;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixAction {
    /**
     * Restart
     */
    restart: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixActionWarningOnly;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval: number;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastMaximumPrefixActionWarningOnly {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastNextHop {
    /**
     * Self
     */
    self: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastNextHopSelfForce;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastNextHopSelf {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastNextHopSelfForce {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList: string;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAs {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAsReplaceAs;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAsAll {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastRemovePrivateAsReplaceAs {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunity {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard: outputs.GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityStandard;
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityAll {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityBoth {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityExtended {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityLarge {
}

export interface GetBgpAddressFamilyProfileListDataIpv4MulticastSendCommunityStandard {
}

export interface GetBgpAddressFamilyProfileListDataIpv4Unicast {
    /**
     * Add path
     */
    addPath: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastAddPath;
    /**
     * Allowas in
     */
    allowasIn: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastAllowasIn;
    /**
     * Override ASNs in outbound updates if AS-Path equals Remote-AS?
     */
    asOverride: boolean;
    /**
     * Originate default route?
     */
    defaultOriginate: boolean;
    /**
     * Default originate route map
     */
    defaultOriginateMap: string;
    /**
     * Enable?
     */
    enable: boolean;
    /**
     * Maximum prefix
     */
    maximumPrefix: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefix;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastNextHop;
    /**
     * Orf
     */
    orf: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastOrf;
    /**
     * Remove private a s
     */
    removePrivateAs: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAs;
    /**
     * Route reflector client?
     */
    routeReflectorClient: boolean;
    /**
     * Send community
     */
    sendCommunity: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunity;
    /**
     * Soft reconfiguration of peer with stored routes?
     */
    softReconfigWithStoredInfo: boolean;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastAddPath {
    /**
     * Advertise all paths to peer?
     */
    txAllPaths: boolean;
    /**
     * Tx bestpath per a s
     */
    txBestpathPerAs: boolean;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastAllowasIn {
    /**
     * Number of times the firewalls own AS can be in an AS_PATH
     */
    occurrence: number;
    /**
     * Origin
     *
     * > ℹ️ **Note:** You must specify exactly one of `occurrence` and `origin`.
     */
    origin: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastAllowasInOrigin;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastAllowasInOrigin {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefix {
    /**
     * Action
     */
    action: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixAction;
    /**
     * Maximum number of prefixes
     */
    numPrefixes: number;
    /**
     * Threshold percentage of the maximum number of prefixes
     */
    threshold: number;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixAction {
    /**
     * Restart
     */
    restart: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixActionRestart;
    /**
     * Warning only
     *
     * > ℹ️ **Note:** You must specify exactly one of `restart` and `warningOnly`.
     */
    warningOnly: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixActionWarningOnly;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixActionRestart {
    /**
     * Restart interval
     */
    interval: number;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastMaximumPrefixActionWarningOnly {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastNextHop {
    /**
     * Self
     */
    self: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastNextHopSelf;
    /**
     * Self force
     *
     * > ℹ️ **Note:** You must specify exactly one of `self` and `selfForce`.
     */
    selfForce: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastNextHopSelfForce;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastNextHopSelf {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastNextHopSelfForce {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastOrf {
    /**
     * ORF prefix list
     */
    orfPrefixList: string;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAs {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAsAll;
    /**
     * Replace a s
     */
    replaceAs: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAsReplaceAs;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAsAll {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastRemovePrivateAsReplaceAs {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunity {
    /**
     * All
     */
    all: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityAll;
    /**
     * Both
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    both: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityBoth;
    /**
     * Extended
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    extended: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    large: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityLarge;
    /**
     * Standard
     *
     * > ℹ️ **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
     */
    standard: outputs.GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityStandard;
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityAll {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityBoth {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityExtended {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityLarge {
}

export interface GetBgpAddressFamilyProfileListDataIpv4UnicastSendCommunityStandard {
}

export interface GetBgpAuthProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * BGP authentication key
     */
    secret: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpFilteringProfileIpv4 {
    /**
     * Multicast
     */
    multicast: outputs.GetBgpFilteringProfileIpv4Multicast;
    /**
     * Unicast
     */
    unicast: outputs.GetBgpFilteringProfileIpv4Unicast;
}

export interface GetBgpFilteringProfileIpv4Multicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetBgpFilteringProfileIpv4MulticastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList: outputs.GetBgpFilteringProfileIpv4MulticastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters: outputs.GetBgpFilteringProfileIpv4MulticastInboundNetworkFilters;
    /**
     * Inherit from unicast
     */
    inherit: boolean;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters: outputs.GetBgpFilteringProfileIpv4MulticastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps: outputs.GetBgpFilteringProfileIpv4MulticastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap: string;
}

export interface GetBgpFilteringProfileIpv4MulticastConditionalAdvertisement {
    /**
     * Exist
     */
    exist: outputs.GetBgpFilteringProfileIpv4MulticastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist: outputs.GetBgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExist;
}

export interface GetBgpFilteringProfileIpv4MulticastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Exist map
     */
    existMap: string;
}

export interface GetBgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Non exist map
     */
    nonExistMap: string;
}

export interface GetBgpFilteringProfileIpv4MulticastFilterList {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileIpv4MulticastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileIpv4MulticastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileIpv4MulticastRouteMaps {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileIpv4Unicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetBgpFilteringProfileIpv4UnicastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList: outputs.GetBgpFilteringProfileIpv4UnicastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters: outputs.GetBgpFilteringProfileIpv4UnicastInboundNetworkFilters;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters: outputs.GetBgpFilteringProfileIpv4UnicastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps: outputs.GetBgpFilteringProfileIpv4UnicastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap: string;
}

export interface GetBgpFilteringProfileIpv4UnicastConditionalAdvertisement {
    /**
     * Exist
     */
    exist: outputs.GetBgpFilteringProfileIpv4UnicastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist: outputs.GetBgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExist;
}

export interface GetBgpFilteringProfileIpv4UnicastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Exist map
     */
    existMap: string;
}

export interface GetBgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Non exist map
     */
    nonExistMap: string;
}

export interface GetBgpFilteringProfileIpv4UnicastFilterList {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileIpv4UnicastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileIpv4UnicastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileIpv4UnicastRouteMaps {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpFilteringProfileListDataIpv4;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpFilteringProfileListDataIpv4 {
    /**
     * Multicast
     */
    multicast: outputs.GetBgpFilteringProfileListDataIpv4Multicast;
    /**
     * Unicast
     */
    unicast: outputs.GetBgpFilteringProfileListDataIpv4Unicast;
}

export interface GetBgpFilteringProfileListDataIpv4Multicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList: outputs.GetBgpFilteringProfileListDataIpv4MulticastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters: outputs.GetBgpFilteringProfileListDataIpv4MulticastInboundNetworkFilters;
    /**
     * Inherit from unicast
     */
    inherit: boolean;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters: outputs.GetBgpFilteringProfileListDataIpv4MulticastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps: outputs.GetBgpFilteringProfileListDataIpv4MulticastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisement {
    /**
     * Exist
     */
    exist: outputs.GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist: outputs.GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisementNonExist;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Exist map
     */
    existMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Non exist map
     */
    nonExistMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastFilterList {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileListDataIpv4MulticastRouteMaps {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileListDataIpv4Unicast {
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisement;
    /**
     * Filter list
     */
    filterList: outputs.GetBgpFilteringProfileListDataIpv4UnicastFilterList;
    /**
     * Inbound network filters
     */
    inboundNetworkFilters: outputs.GetBgpFilteringProfileListDataIpv4UnicastInboundNetworkFilters;
    /**
     * Outbound network filters
     */
    outboundNetworkFilters: outputs.GetBgpFilteringProfileListDataIpv4UnicastOutboundNetworkFilters;
    /**
     * Route maps
     */
    routeMaps: outputs.GetBgpFilteringProfileListDataIpv4UnicastRouteMaps;
    /**
     * Unsuppress map
     */
    unsuppressMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisement {
    /**
     * Exist
     */
    exist: outputs.GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisementExist;
    /**
     * Non exist
     */
    nonExist: outputs.GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisementNonExist;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisementExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Exist map
     */
    existMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastConditionalAdvertisementNonExist {
    /**
     * Advertise map
     */
    advertiseMap: string;
    /**
     * Non exist map
     */
    nonExistMap: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastFilterList {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastInboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastOutboundNetworkFilters {
    /**
     * Distribute list
     */
    distributeList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpFilteringProfileListDataIpv4UnicastRouteMaps {
    /**
     * Inbound
     */
    inbound: string;
    /**
     * Outbound
     */
    outbound: string;
}

export interface GetBgpRedistributionProfileIpv4 {
    /**
     * Unicast
     */
    unicast: outputs.GetBgpRedistributionProfileIpv4Unicast;
}

export interface GetBgpRedistributionProfileIpv4Unicast {
    /**
     * Connected
     */
    connected: outputs.GetBgpRedistributionProfileIpv4UnicastConnected;
    /**
     * Ospf
     */
    ospf: outputs.GetBgpRedistributionProfileIpv4UnicastOspf;
    /**
     * Static
     */
    static: outputs.GetBgpRedistributionProfileIpv4UnicastStatic;
}

export interface GetBgpRedistributionProfileIpv4UnicastConnected {
    /**
     * Enable connected route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRedistributionProfileIpv4UnicastOspf {
    /**
     * Enable OSPF route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRedistributionProfileIpv4UnicastStatic {
    /**
     * Enable static route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRedistributionProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRedistributionProfileListDataIpv4;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpRedistributionProfileListDataIpv4 {
    /**
     * Unicast
     */
    unicast: outputs.GetBgpRedistributionProfileListDataIpv4Unicast;
}

export interface GetBgpRedistributionProfileListDataIpv4Unicast {
    /**
     * Connected
     */
    connected: outputs.GetBgpRedistributionProfileListDataIpv4UnicastConnected;
    /**
     * Ospf
     */
    ospf: outputs.GetBgpRedistributionProfileListDataIpv4UnicastOspf;
    /**
     * Static
     */
    static: outputs.GetBgpRedistributionProfileListDataIpv4UnicastStatic;
}

export interface GetBgpRedistributionProfileListDataIpv4UnicastConnected {
    /**
     * Enable connected route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRedistributionProfileListDataIpv4UnicastOspf {
    /**
     * Enable OSPF route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRedistributionProfileListDataIpv4UnicastStatic {
    /**
     * Enable static route redistribution?
     */
    enable: boolean;
    /**
     * Route metric
     */
    metric: number;
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetBgpRouteMapListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Route map
     */
    routeMaps: outputs.GetBgpRouteMapListDataRouteMap[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpRouteMapListDataRouteMap {
    /**
     * Action
     */
    action: string;
    /**
     * Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapListDataRouteMapMatch;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Set
     */
    set: outputs.GetBgpRouteMapListDataRouteMapSet;
}

export interface GetBgpRouteMapListDataRouteMapMatch {
    /**
     * AS path access list
     */
    asPathAccessList: string;
    /**
     * Extended community
     */
    extendedCommunity: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * bgp-route-maps ipv4 object
     */
    ipv4: outputs.GetBgpRouteMapListDataRouteMapMatchIpv4;
    /**
     * Large community
     */
    largeCommunity: string;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: number;
    /**
     * Origin
     */
    origin: string;
    /**
     * Peer
     */
    peer: string;
    /**
     * Regular community
     */
    regularCommunity: string;
    /**
     * Tag
     */
    tag: number;
}

export interface GetBgpRouteMapListDataRouteMapMatchIpv4 {
    /**
     * Address
     */
    address: outputs.GetBgpRouteMapListDataRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapListDataRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource: outputs.GetBgpRouteMapListDataRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapListDataRouteMapMatchIpv4Address {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapListDataRouteMapMatchIpv4NextHop {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapListDataRouteMapMatchIpv4RouteSource {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapListDataRouteMapSet {
    /**
     * bgp-route-maps aggregator
     */
    aggregator: outputs.GetBgpRouteMapListDataRouteMapSetAggregator;
    /**
     * Aspath exclude
     */
    aspathExcludes: number[];
    /**
     * Aspath prepend
     */
    aspathPrepends: number[];
    /**
     * Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapListDataRouteMapSetIpv4;
    /**
     * Large community
     */
    largeCommunities: string[];
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapListDataRouteMapSetMetric;
    /**
     * Origin
     */
    origin: string;
    /**
     * Originator ID
     */
    originatorId: string;
    /**
     * Overwrite large community?
     */
    overwriteLargeCommunity: boolean;
    /**
     * Overwrite regular community?
     */
    overwriteRegularCommunity: boolean;
    /**
     * Regular community
     */
    regularCommunities: string[];
    /**
     * Remove large community name
     */
    removeLargeCommunity: string;
    /**
     * Remove regular community name
     */
    removeRegularCommunity: string;
    /**
     * Tag
     */
    tag: number;
    /**
     * Weight
     */
    weight: number;
}

export interface GetBgpRouteMapListDataRouteMapSetAggregator {
    /**
     * Aggregator AS
     */
    as: number;
    /**
     * Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapListDataRouteMapSetIpv4 {
    /**
     * Next hop
     */
    nextHop: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapListDataRouteMapSetMetric {
    /**
     * Metric action
     */
    action: string;
    /**
     * Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionBgp {
    /**
     * Ospf
     */
    ospf: outputs.GetBgpRouteMapRedistributionBgpOspf;
    /**
     * BGP Root RIB
     *
     * > ℹ️ **Note:** You must specify exactly one of `ospf` and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionBgpRib;
}

export interface GetBgpRouteMapRedistributionBgpOspf {
    /**
     * BGP Root OSPF Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMap[];
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMap {
    /**
     * BGP Root OSPF Route maps Action
     */
    action: string;
    /**
     * BGP Root OSPF Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapMatch;
    /**
     * BGP Root OSPF Route maps Sequence number
     */
    name: number;
    /**
     * BGP Root OSPF Set
     */
    set: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapSet;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapMatch {
    /**
     * BGP Root OSPF Route maps match AS path access list
     */
    asPathAccessList: string;
    /**
     * EBGP Root OSPF Route maps match xtended community
     */
    extendedCommunity: string;
    /**
     * BGP Root OSPF Route maps match Interface
     */
    interface: string;
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
     */
    ipv4: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4;
    /**
     * BGP Root OSPF Route maps match Large community
     */
    largeCommunity: string;
    /**
     * BGP Root OSPF Route maps match Local preference
     */
    localPreference: number;
    /**
     * BGP Root OSPF Route maps match Metric
     */
    metric: number;
    /**
     * BGP Root OSPF Route maps match Origin
     */
    origin: string;
    /**
     * BGP Root OSPF Route maps match Peer
     */
    peer: string;
    /**
     * BGP Root OSPF Route maps match Regular community
     */
    regularCommunity: string;
    /**
     * BGP Root OSPF Route maps match Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4 {
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
     */
    address: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Address;
    /**
     * BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHop;
    /**
     * BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
     */
    routeSource: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Address {
    /**
     * BGP Root OSPF Route maps match ipv4 Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps match ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHop {
    /**
     * BGP Root OSPF Route maps ipv4 nextVr hop Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root OSPF Route maps ipv4 route source Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps ipv4 route source Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapSet {
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionBgpOspfRouteMapSetMetric;
    /**
     * BGP Root OSPF Route maps set Metric type
     */
    metricType: string;
    /**
     * BGP Root OSPF Route maps set Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionBgpOspfRouteMapSetMetric {
    /**
     * BGP Root OSPF Route maps set Metric action
     */
    action: string;
    /**
     * BGP Root OSPF Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionBgpRib {
    /**
     * BGP Root RIB Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionBgpRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMap {
    /**
     * BGP Root RIB Route maps Action
     */
    action: string;
    /**
     * BGP Root RIB Route maps Description
     */
    description: string;
    /**
     * match attribute for BG Rib route map
     */
    match: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapMatch;
    /**
     * BGP Root RIB Route maps Sequence number
     */
    name: number;
    /**
     * Set attributes for BGP route map
     */
    set: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapMatch {
    /**
     * BGP Root RIB Route maps match AS path access list
     */
    asPathAccessList: string;
    /**
     * BGP Root RIB Route maps match Extended community
     */
    extendedCommunity: string;
    /**
     * BGP Root RIB Route maps match Interface
     */
    interface: string;
    /**
     * BGP Route Map Redistributions Root BGP rib Route Map IPv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4;
    /**
     * BGP Root RIB Route maps match Large community
     */
    largeCommunity: string;
    /**
     * BGP Root RIB Route maps match Local preference
     */
    localPreference: number;
    /**
     * BGP Root RIB Route maps match Metric
     */
    metric: number;
    /**
     * BGP Root RIB Route maps match Origin
     */
    origin: string;
    /**
     * BGP Root RIB Route maps match Peer
     */
    peer: string;
    /**
     * BGP Root RIB Route maps match Regular community
     */
    regularCommunity: string;
    /**
     * BGP Root RIB Route maps match Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4 {
    /**
     * bgp-route-map-redistributions ipv4 rib object address
     */
    address: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Address;
    /**
     * bgp-route-map-redistributions ipv4 rib object next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource: outputs.GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Address {
    /**
     * BGP Root RIB Route maps match ipv Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHop {
    /**
     * BGP Root RIB Route maps match ipv next hop Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root RIB Route maps match ipv route source Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv route source Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionBgpRibRouteMapSet {
    /**
     * BGP Root RIB Route maps set Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionConnectedStatic {
    /**
     * Connected Static Root BGP
     */
    bgp: outputs.GetBgpRouteMapRedistributionConnectedStaticBgp;
    /**
     * Ospf
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    ospf: outputs.GetBgpRouteMapRedistributionConnectedStaticOspf;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionConnectedStaticRib;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgp {
    /**
     * Connected Static BGP Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMap[];
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMap {
    /**
     * Connected Static BGP Route maps Action
     */
    action: string;
    /**
     * Connected Static BGP Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatch;
    /**
     * Connected Static BGP Route maps Sequence number
     */
    name: number;
    /**
     * Set
     */
    set: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSet;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatch {
    /**
     * Connected Static BGP Route maps match Interface
     */
    interface: string;
    /**
     * bgp-route-map-redistributions connected-static ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4;
    /**
     * Connected Static BGP Route maps match Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4 {
    /**
     * Address
     */
    address: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Route maps match ip4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Route maps match ip4  Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Route maps match ip4 next hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Route maps match ip4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions connected*static aggregator
     */
    aggregator: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregator;
    /**
     * Connected Static BGP Route maps set AS numbers
     */
    aspathPrepends: number[];
    /**
     * Connected Static BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4;
    /**
     * Connected Static  BGP Route maps set Large communities
     */
    largeCommunities: string[];
    /**
     * Connected Static BGP Route maps set Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetric;
    /**
     * Connected Static BGP Route maps set Origin
     */
    origin: string;
    /**
     * Connected Static BGP Route maps set Originator ID
     */
    originatorId: string;
    /**
     * Connected Static  BGP Route maps set Regular communities
     */
    regularCommunities: string[];
    /**
     * Connected Static BGP Route maps set Tag
     */
    tag: number;
    /**
     * Connected Static BGP Route maps set Weight
     */
    weight: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregator {
    /**
     * Connected Static BGP Route maps set Aggregator AS
     */
    as: number;
    /**
     * Connected Static BGP Route maps set Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4 {
    /**
     * Connected Static BGP Route maps set Next ipv4 hop
     */
    nextHop: string;
    /**
     * Connected Static BGP Route maps set ipv4 Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetric {
    /**
     * Connected Static BGP Route maps set Metric action
     */
    action: string;
    /**
     * Connected Static BGP Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspf {
    /**
     * Connected Static  BGP OSPF Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMap[];
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMap {
    /**
     * Connected Static BGP OSPF Route map Action
     */
    action: string;
    /**
     * Connected Static BGP OSPF Route map Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatch;
    /**
     * Connected Static BGP OSPF Route map Sequence number
     */
    name: number;
    /**
     * Connected Static Root OSPF Set
     */
    set: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapSet;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatch {
    /**
     * Connected Static BGP OSPF Route map Interface
     */
    interface: string;
    /**
     * bgp-route-map-redistributions connected-static match ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4;
    /**
     * Connected Static BGP OSPF Route map Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4 {
    /**
     * Connected Static Root OSPF Address
     */
    address: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP OSPF Route map ipv4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapSet {
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetric;
    /**
     * Connected Static BGP OSPF Route map set Metric type
     */
    metricType: string;
    /**
     * Connected Static BGP OSPF Route map set Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetric {
    /**
     * Connected Static BGP OSPF Route map set Metric action
     */
    action: string;
    /**
     * Connected Static BGP OSPF Route map set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRib {
    /**
     * Connected Static BGP Rib Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMap {
    /**
     * Connected Static BGP Rib Route maps Action
     */
    action: string;
    /**
     * Connected Static BGP Rib Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatch;
    /**
     * Connected Static BGP Rib Route maps Sequence number
     */
    name: number;
    /**
     * Connected Static Root RIB set
     */
    set: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatch {
    /**
     * Connected Static BGP Rib Route maps Interface
     */
    interface: string;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4;
    /**
     * Connected Static BGP Rib Route maps Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4 {
    /**
     * Connected Static BGP Rib Route maps ipv4 address
     */
    address: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Rib Route maps ipv4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Rib Route maps ipv4 nect hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionConnectedStaticRibRouteMapSet {
    /**
     * Connected Static BGP Rib Route Map Distribution Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionListData {
    /**
     * Bgp
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `connectedStatic`, and `ospf`.
     */
    bgp: outputs.GetBgpRouteMapRedistributionListDataBgp;
    /**
     * Connected static
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `connectedStatic`, and `ospf`.
     */
    connectedStatic: outputs.GetBgpRouteMapRedistributionListDataConnectedStatic;
    /**
     * BGP Route Map Redistributions Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * BGP Route Map Redistributions UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Ospf
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `connectedStatic`, and `ospf`.
     */
    ospf: outputs.GetBgpRouteMapRedistributionListDataOspf;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetBgpRouteMapRedistributionListDataBgp {
    /**
     * Ospf
     */
    ospf: outputs.GetBgpRouteMapRedistributionListDataBgpOspf;
    /**
     * BGP Root RIB
     *
     * > ℹ️ **Note:** You must specify exactly one of `ospf` and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionListDataBgpRib;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspf {
    /**
     * BGP Root OSPF Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMap {
    /**
     * BGP Root OSPF Route maps Action
     */
    action: string;
    /**
     * BGP Root OSPF Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatch;
    /**
     * BGP Root OSPF Route maps Sequence number
     */
    name: number;
    /**
     * BGP Root OSPF Set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatch {
    /**
     * BGP Root OSPF Route maps match AS path access list
     */
    asPathAccessList: string;
    /**
     * EBGP Root OSPF Route maps match xtended community
     */
    extendedCommunity: string;
    /**
     * BGP Root OSPF Route maps match Interface
     */
    interface: string;
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4;
    /**
     * BGP Root OSPF Route maps match Large community
     */
    largeCommunity: string;
    /**
     * BGP Root OSPF Route maps match Local preference
     */
    localPreference: number;
    /**
     * BGP Root OSPF Route maps match Metric
     */
    metric: number;
    /**
     * BGP Root OSPF Route maps match Origin
     */
    origin: string;
    /**
     * BGP Root OSPF Route maps match Peer
     */
    peer: string;
    /**
     * BGP Root OSPF Route maps match Regular community
     */
    regularCommunity: string;
    /**
     * BGP Root OSPF Route maps match Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4 {
    /**
     * BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4Address;
    /**
     * BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4NextHop;
    /**
     * BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
     */
    routeSource: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4Address {
    /**
     * BGP Root OSPF Route maps match ipv4 Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps match ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4NextHop {
    /**
     * BGP Root OSPF Route maps ipv4 nextVr hop Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root OSPF Route maps ipv4 route source Access list
     */
    accessList: string;
    /**
     * BGP Root OSPF Route maps ipv4 route source Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapSet {
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionListDataBgpOspfRouteMapSetMetric;
    /**
     * BGP Root OSPF Route maps set Metric type
     */
    metricType: string;
    /**
     * BGP Root OSPF Route maps set Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataBgpOspfRouteMapSetMetric {
    /**
     * BGP Root OSPF Route maps set Metric action
     */
    action: string;
    /**
     * BGP Root OSPF Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionListDataBgpRib {
    /**
     * BGP Root RIB Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMap {
    /**
     * BGP Root RIB Route maps Action
     */
    action: string;
    /**
     * BGP Root RIB Route maps Description
     */
    description: string;
    /**
     * match attribute for BG Rib route map
     */
    match: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatch;
    /**
     * BGP Root RIB Route maps Sequence number
     */
    name: number;
    /**
     * Set attributes for BGP route map
     */
    set: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatch {
    /**
     * BGP Root RIB Route maps match AS path access list
     */
    asPathAccessList: string;
    /**
     * BGP Root RIB Route maps match Extended community
     */
    extendedCommunity: string;
    /**
     * BGP Root RIB Route maps match Interface
     */
    interface: string;
    /**
     * BGP Route Map Redistributions Root BGP rib Route Map IPv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4;
    /**
     * BGP Root RIB Route maps match Large community
     */
    largeCommunity: string;
    /**
     * BGP Root RIB Route maps match Local preference
     */
    localPreference: number;
    /**
     * BGP Root RIB Route maps match Metric
     */
    metric: number;
    /**
     * BGP Root RIB Route maps match Origin
     */
    origin: string;
    /**
     * BGP Root RIB Route maps match Peer
     */
    peer: string;
    /**
     * BGP Root RIB Route maps match Regular community
     */
    regularCommunity: string;
    /**
     * BGP Root RIB Route maps match Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4 {
    /**
     * bgp-route-map-redistributions ipv4 rib object address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4Address;
    /**
     * bgp-route-map-redistributions ipv4 rib object next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource: outputs.GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4Address {
    /**
     * BGP Root RIB Route maps match ipv Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4NextHop {
    /**
     * BGP Root RIB Route maps match ipv next hop Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapMatchIpv4RouteSource {
    /**
     * BGP Root RIB Route maps match ipv route source Access list
     */
    accessList: string;
    /**
     * BGP Root RIB Route maps match ipv route source Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataBgpRibRouteMapSet {
    /**
     * BGP Root RIB Route maps set Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStatic {
    /**
     * Connected Static Root BGP
     */
    bgp: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgp;
    /**
     * Ospf
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    ospf: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspf;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRib;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgp {
    /**
     * Connected Static BGP Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMap {
    /**
     * Connected Static BGP Route maps Action
     */
    action: string;
    /**
     * Connected Static BGP Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatch;
    /**
     * Connected Static BGP Route maps Sequence number
     */
    name: number;
    /**
     * Set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatch {
    /**
     * Connected Static BGP Route maps match Interface
     */
    interface: string;
    /**
     * bgp-route-map-redistributions connected-static ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4;
    /**
     * Connected Static BGP Route maps match Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4 {
    /**
     * Address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Route maps match ip4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Route maps match ip4  Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Route maps match ip4 next hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Route maps match ip4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions connected*static aggregator
     */
    aggregator: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetAggregator;
    /**
     * Connected Static BGP Route maps set AS numbers
     */
    aspathPrepends: number[];
    /**
     * Connected Static BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetIpv4;
    /**
     * Connected Static  BGP Route maps set Large communities
     */
    largeCommunities: string[];
    /**
     * Connected Static BGP Route maps set Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetMetric;
    /**
     * Connected Static BGP Route maps set Origin
     */
    origin: string;
    /**
     * Connected Static BGP Route maps set Originator ID
     */
    originatorId: string;
    /**
     * Connected Static  BGP Route maps set Regular communities
     */
    regularCommunities: string[];
    /**
     * Connected Static BGP Route maps set Tag
     */
    tag: number;
    /**
     * Connected Static BGP Route maps set Weight
     */
    weight: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetAggregator {
    /**
     * Connected Static BGP Route maps set Aggregator AS
     */
    as: number;
    /**
     * Connected Static BGP Route maps set Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetIpv4 {
    /**
     * Connected Static BGP Route maps set Next ipv4 hop
     */
    nextHop: string;
    /**
     * Connected Static BGP Route maps set ipv4 Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticBgpRouteMapSetMetric {
    /**
     * Connected Static BGP Route maps set Metric action
     */
    action: string;
    /**
     * Connected Static BGP Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspf {
    /**
     * Connected Static  BGP OSPF Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMap {
    /**
     * Connected Static BGP OSPF Route map Action
     */
    action: string;
    /**
     * Connected Static BGP OSPF Route map Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatch;
    /**
     * Connected Static BGP OSPF Route map Sequence number
     */
    name: number;
    /**
     * Connected Static Root OSPF Set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatch {
    /**
     * Connected Static BGP OSPF Route map Interface
     */
    interface: string;
    /**
     * bgp-route-map-redistributions connected-static match ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4;
    /**
     * Connected Static BGP OSPF Route map Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4 {
    /**
     * Connected Static Root OSPF Address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP OSPF Route map ipv4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP OSPF Route map ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapSet {
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapSetMetric;
    /**
     * Connected Static BGP OSPF Route map set Metric type
     */
    metricType: string;
    /**
     * Connected Static BGP OSPF Route map set Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticOspfRouteMapSetMetric {
    /**
     * Connected Static BGP OSPF Route map set Metric action
     */
    action: string;
    /**
     * Connected Static BGP OSPF Route map set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRib {
    /**
     * Connected Static BGP Rib Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMap {
    /**
     * Connected Static BGP Rib Route maps Action
     */
    action: string;
    /**
     * Connected Static BGP Rib Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatch;
    /**
     * Connected Static BGP Rib Route maps Sequence number
     */
    name: number;
    /**
     * Connected Static Root RIB set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatch {
    /**
     * Connected Static BGP Rib Route maps Interface
     */
    interface: string;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4;
    /**
     * Connected Static BGP Rib Route maps Metric
     */
    metric: number;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4 {
    /**
     * Connected Static BGP Rib Route maps ipv4 address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4NextHop;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4Address {
    /**
     * Connected Static BGP Rib Route maps ipv4 Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapMatchIpv4NextHop {
    /**
     * Connected Static BGP Rib Route maps ipv4 nect hop Access list
     */
    accessList: string;
    /**
     * Connected Static BGP Rib Route maps ipv4 next hop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataConnectedStaticRibRouteMapSet {
    /**
     * Connected Static BGP Rib Route Map Distribution Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionListDataOspf {
    /**
     * OSPF Root BGP
     */
    bgp: outputs.GetBgpRouteMapRedistributionListDataOspfBgp;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp` and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionListDataOspfRib;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgp {
    /**
     * OSPF BGP Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMap {
    /**
     * OSPF BGP Route maps Action
     */
    action: string;
    /**
     * OSPF BGP Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatch;
    /**
     * OSPF BGP Route maps Sequence number
     */
    name: number;
    /**
     * OSPF Root Set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatch {
    /**
     * bgp-route-map-redistributions ospf address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatchAddress;
    /**
     * OSPF BGP Route maps Interface
     */
    interface: string;
    /**
     * OSPF BGP Route maps Metric
     */
    metric: number;
    /**
     * bgp-route-map-redistributions ospf next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatchNextHop;
    /**
     * OSPF BGP Route maps Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatchAddress {
    /**
     * OSPF BGP Route maps match Access list
     */
    accessList: string;
    /**
     * OSPF BGP Route maps match Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapMatchNextHop {
    /**
     * OSPF BGP Route maps nextHop Access list
     */
    accessList: string;
    /**
     * OSPF BGP Route maps nextHop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions set aggregator
     */
    aggregator: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetAggregator;
    /**
     * OSPF BGP Route maps set AS numbers
     */
    aspathPrepends: number[];
    /**
     * OSPF BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetIpv4;
    /**
     * OSPF BGP Route maps set Large communities
     */
    largeCommunities: string[];
    /**
     * OSPF BGP Route maps set Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetMetric;
    /**
     * OSPF BGP Route maps set Origin
     */
    origin: string;
    /**
     * OSPF BGP Route maps set Originator ID
     */
    originatorId: string;
    /**
     * OSPF BGP Route maps set Regular communities
     */
    regularCommunities: string[];
    /**
     * OSPF BGP Route maps set Tag
     */
    tag: number;
    /**
     * OSPF BGP Route maps set Weight
     */
    weight: number;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetAggregator {
    /**
     * OSPF BGP Route maps set Aggregator AS
     */
    as: number;
    /**
     * OSPF BGP Route maps set Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetIpv4 {
    /**
     * OSPF BGP Route maps set ipv4 Next hop
     */
    nextHop: string;
    /**
     * OSPF BGP Route maps set ipv4 Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfBgpRouteMapSetMetric {
    /**
     * OSPF BGP Route maps set Metric action
     */
    action: string;
    /**
     * OSPF BGP Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionListDataOspfRib {
    /**
     * OSPF RIB Route maps set Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionListDataOspfRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionListDataOspfRibRouteMap {
    /**
     * OSPF RIB Route maps Action
     */
    action: string;
    /**
     * OSPF RIB Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatch;
    /**
     * OSPF RIB Route mapsSequence number
     */
    name: number;
    /**
     * OSPF RIB Route maps set
     */
    set: outputs.GetBgpRouteMapRedistributionListDataOspfRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatch {
    /**
     * OSPF RIB Route maps address
     */
    address: outputs.GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatchAddress;
    /**
     * OSPF RIB Route maps Interface
     */
    interface: string;
    /**
     * OSPF RIB Route maps Metric
     */
    metric: number;
    /**
     * OSPF RIB Route maps next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatchNextHop;
    /**
     * OSPF RIB Route maps tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatchAddress {
    /**
     * OSPF RIB Route maps address Access list
     */
    accessList: string;
    /**
     * OSPF RIB Route maps address Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfRibRouteMapMatchNextHop {
    /**
     * OSPF RIB Route maps nextHop Access list
     */
    accessList: string;
    /**
     * OSPF RIB Route maps nextHop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionListDataOspfRibRouteMapSet {
    /**
     * OSPF RIB Route maps set Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionOspf {
    /**
     * OSPF Root BGP
     */
    bgp: outputs.GetBgpRouteMapRedistributionOspfBgp;
    /**
     * Rib
     *
     * > ℹ️ **Note:** You must specify exactly one of `bgp` and `rib`.
     */
    rib: outputs.GetBgpRouteMapRedistributionOspfRib;
}

export interface GetBgpRouteMapRedistributionOspfBgp {
    /**
     * OSPF BGP Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMap[];
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMap {
    /**
     * OSPF BGP Route maps Action
     */
    action: string;
    /**
     * OSPF BGP Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapMatch;
    /**
     * OSPF BGP Route maps Sequence number
     */
    name: number;
    /**
     * OSPF Root Set
     */
    set: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapSet;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapMatch {
    /**
     * bgp-route-map-redistributions ospf address
     */
    address: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapMatchAddress;
    /**
     * OSPF BGP Route maps Interface
     */
    interface: string;
    /**
     * OSPF BGP Route maps Metric
     */
    metric: number;
    /**
     * bgp-route-map-redistributions ospf next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapMatchNextHop;
    /**
     * OSPF BGP Route maps Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapMatchAddress {
    /**
     * OSPF BGP Route maps match Access list
     */
    accessList: string;
    /**
     * OSPF BGP Route maps match Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapMatchNextHop {
    /**
     * OSPF BGP Route maps nextHop Access list
     */
    accessList: string;
    /**
     * OSPF BGP Route maps nextHop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapSet {
    /**
     * bgp-route-map-redistributions set aggregator
     */
    aggregator: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapSetAggregator;
    /**
     * OSPF BGP Route maps set AS numbers
     */
    aspathPrepends: number[];
    /**
     * OSPF BGP Route maps set Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapSetIpv4;
    /**
     * OSPF BGP Route maps set Large communities
     */
    largeCommunities: string[];
    /**
     * OSPF BGP Route maps set Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRedistributionOspfBgpRouteMapSetMetric;
    /**
     * OSPF BGP Route maps set Origin
     */
    origin: string;
    /**
     * OSPF BGP Route maps set Originator ID
     */
    originatorId: string;
    /**
     * OSPF BGP Route maps set Regular communities
     */
    regularCommunities: string[];
    /**
     * OSPF BGP Route maps set Tag
     */
    tag: number;
    /**
     * OSPF BGP Route maps set Weight
     */
    weight: number;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapSetAggregator {
    /**
     * OSPF BGP Route maps set Aggregator AS
     */
    as: number;
    /**
     * OSPF BGP Route maps set Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapSetIpv4 {
    /**
     * OSPF BGP Route maps set ipv4 Next hop
     */
    nextHop: string;
    /**
     * OSPF BGP Route maps set ipv4 Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRedistributionOspfBgpRouteMapSetMetric {
    /**
     * OSPF BGP Route maps set Metric action
     */
    action: string;
    /**
     * OSPF BGP Route maps set Metric value
     */
    value: number;
}

export interface GetBgpRouteMapRedistributionOspfRib {
    /**
     * OSPF RIB Route maps set Route maps
     */
    routeMaps: outputs.GetBgpRouteMapRedistributionOspfRibRouteMap[];
}

export interface GetBgpRouteMapRedistributionOspfRibRouteMap {
    /**
     * OSPF RIB Route maps Action
     */
    action: string;
    /**
     * OSPF RIB Route maps Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRedistributionOspfRibRouteMapMatch;
    /**
     * OSPF RIB Route mapsSequence number
     */
    name: number;
    /**
     * OSPF RIB Route maps set
     */
    set: outputs.GetBgpRouteMapRedistributionOspfRibRouteMapSet;
}

export interface GetBgpRouteMapRedistributionOspfRibRouteMapMatch {
    /**
     * OSPF RIB Route maps address
     */
    address: outputs.GetBgpRouteMapRedistributionOspfRibRouteMapMatchAddress;
    /**
     * OSPF RIB Route maps Interface
     */
    interface: string;
    /**
     * OSPF RIB Route maps Metric
     */
    metric: number;
    /**
     * OSPF RIB Route maps next*hop
     */
    nextHop: outputs.GetBgpRouteMapRedistributionOspfRibRouteMapMatchNextHop;
    /**
     * OSPF RIB Route maps tag
     */
    tag: number;
}

export interface GetBgpRouteMapRedistributionOspfRibRouteMapMatchAddress {
    /**
     * OSPF RIB Route maps address Access list
     */
    accessList: string;
    /**
     * OSPF RIB Route maps address Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionOspfRibRouteMapMatchNextHop {
    /**
     * OSPF RIB Route maps nextHop Access list
     */
    accessList: string;
    /**
     * OSPF RIB Route maps nextHop Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRedistributionOspfRibRouteMapSet {
    /**
     * OSPF RIB Route maps set Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRouteMap {
    /**
     * Action
     */
    action: string;
    /**
     * Description
     */
    description: string;
    /**
     * Match
     */
    match: outputs.GetBgpRouteMapRouteMapMatch;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Set
     */
    set: outputs.GetBgpRouteMapRouteMapSet;
}

export interface GetBgpRouteMapRouteMapMatch {
    /**
     * AS path access list
     */
    asPathAccessList: string;
    /**
     * Extended community
     */
    extendedCommunity: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * bgp-route-maps ipv4 object
     */
    ipv4: outputs.GetBgpRouteMapRouteMapMatchIpv4;
    /**
     * Large community
     */
    largeCommunity: string;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: number;
    /**
     * Origin
     */
    origin: string;
    /**
     * Peer
     */
    peer: string;
    /**
     * Regular community
     */
    regularCommunity: string;
    /**
     * Tag
     */
    tag: number;
}

export interface GetBgpRouteMapRouteMapMatchIpv4 {
    /**
     * Address
     */
    address: outputs.GetBgpRouteMapRouteMapMatchIpv4Address;
    /**
     * Next hop
     */
    nextHop: outputs.GetBgpRouteMapRouteMapMatchIpv4NextHop;
    /**
     * Route source
     */
    routeSource: outputs.GetBgpRouteMapRouteMapMatchIpv4RouteSource;
}

export interface GetBgpRouteMapRouteMapMatchIpv4Address {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRouteMapMatchIpv4NextHop {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRouteMapMatchIpv4RouteSource {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Prefix list
     */
    prefixList: string;
}

export interface GetBgpRouteMapRouteMapSet {
    /**
     * bgp-route-maps aggregator
     */
    aggregator: outputs.GetBgpRouteMapRouteMapSetAggregator;
    /**
     * Aspath exclude
     */
    aspathExcludes: number[];
    /**
     * Aspath prepend
     */
    aspathPrepends: number[];
    /**
     * Enable BGP atomic aggregate?
     */
    atomicAggregate: boolean;
    /**
     * Ipv4
     */
    ipv4: outputs.GetBgpRouteMapRouteMapSetIpv4;
    /**
     * Large community
     */
    largeCommunities: string[];
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Metric
     */
    metric: outputs.GetBgpRouteMapRouteMapSetMetric;
    /**
     * Origin
     */
    origin: string;
    /**
     * Originator ID
     */
    originatorId: string;
    /**
     * Overwrite large community?
     */
    overwriteLargeCommunity: boolean;
    /**
     * Overwrite regular community?
     */
    overwriteRegularCommunity: boolean;
    /**
     * Regular community
     */
    regularCommunities: string[];
    /**
     * Remove large community name
     */
    removeLargeCommunity: string;
    /**
     * Remove regular community name
     */
    removeRegularCommunity: string;
    /**
     * Tag
     */
    tag: number;
    /**
     * Weight
     */
    weight: number;
}

export interface GetBgpRouteMapRouteMapSetAggregator {
    /**
     * Aggregator AS
     */
    as: number;
    /**
     * Router ID
     */
    routerId: string;
}

export interface GetBgpRouteMapRouteMapSetIpv4 {
    /**
     * Next hop
     */
    nextHop: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetBgpRouteMapRouteMapSetMetric {
    /**
     * Metric action
     */
    action: string;
    /**
     * Metric value
     */
    value: number;
}

export interface GetBgpRoutingRoutingPreference {
    /**
     * Default
     */
    default: outputs.GetBgpRoutingRoutingPreferenceDefault;
    /**
     * Hot potato routing
     *
     * > ℹ️ **Note:** You must specify exactly one of `default` and `hotPotatoRouting`.
     */
    hotPotatoRouting: outputs.GetBgpRoutingRoutingPreferenceHotPotatoRouting;
}

export interface GetBgpRoutingRoutingPreferenceDefault {
}

export interface GetBgpRoutingRoutingPreferenceHotPotatoRouting {
}

export interface GetCertificateProfileCaCertificate {
    /**
     * Default OCSP URL
     */
    defaultOcspUrl: string;
    /**
     * CA certificate name
     */
    name: string;
    /**
     * OCSP verify certificate
     */
    ocspVerifyCert: string;
    /**
     * Template name/OID
     */
    templateName: string;
}

export interface GetCertificateProfileListData {
    /**
     * Block sessions with expired certificates?
     */
    blockExpiredCert: boolean;
    /**
     * Block session if certificate status cannot be retrieved within timeout?
     */
    blockTimeoutCert: boolean;
    /**
     * Block session if the certificate was not issued to the authenticating device?
     */
    blockUnauthenticatedCert: boolean;
    /**
     * Block session if certificate status is unknown?
     */
    blockUnknownCert: boolean;
    /**
     * An ordered list of CA certificates
     */
    caCertificates: outputs.GetCertificateProfileListDataCaCertificate[];
    /**
     * Certificate status timeout
     */
    certStatusTimeout: string;
    /**
     * CRL receive timeout (seconds)
     */
    crlReceiveTimeout: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * User domain
     */
    domain: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the certificate profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * OCSP receive timeout (seconds)
     */
    ocspReceiveTimeout: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Use CRL?
     */
    useCrl: boolean;
    /**
     * Use OCSP?
     */
    useOcsp: boolean;
    /**
     * Certificate username field
     */
    usernameField: outputs.GetCertificateProfileListDataUsernameField;
}

export interface GetCertificateProfileListDataCaCertificate {
    /**
     * Default OCSP URL
     */
    defaultOcspUrl: string;
    /**
     * CA certificate name
     */
    name: string;
    /**
     * OCSP verify certificate
     */
    ocspVerifyCert: string;
    /**
     * Template name/OID
     */
    templateName: string;
}

export interface GetCertificateProfileListDataUsernameField {
    /**
     * Common name
     */
    subject: string;
    /**
     * Email address
     */
    subjectAlt: string;
}

export interface GetCertificateProfileUsernameField {
    /**
     * Common name
     */
    subject: string;
    /**
     * Email address
     */
    subjectAlt: string;
}

export interface GetContentIdSettingContentId {
    /**
     * Allow forward decrypted content
     */
    allowForwardDecryptedContent: boolean;
    /**
     * Allow http range
     */
    allowHttpRange: boolean;
    /**
     * Application
     */
    application: outputs.GetContentIdSettingContentIdApplication;
    /**
     * Extended capture segment
     */
    extendedCaptureSegment: number;
    /**
     * Strip x fwd for
     */
    stripXFwdFor: boolean;
    /**
     * Tcp bypass exceed queue
     */
    tcpBypassExceedQueue: boolean;
    /**
     * Udp bypass exceed queue
     */
    udpBypassExceedQueue: boolean;
    /**
     * X forwarded for
     */
    xForwardedFor: string;
}

export interface GetContentIdSettingContentIdApplication {
    /**
     * Bypass exceed queue
     */
    bypassExceedQueue: boolean;
}

export interface GetContentIdSettingListData {
    /**
     * Content id
     */
    contentId: outputs.GetContentIdSettingListDataContentId;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetContentIdSettingListDataContentId {
    /**
     * Allow forward decrypted content
     */
    allowForwardDecryptedContent: boolean;
    /**
     * Allow http range
     */
    allowHttpRange: boolean;
    /**
     * Application
     */
    application: outputs.GetContentIdSettingListDataContentIdApplication;
    /**
     * Extended capture segment
     */
    extendedCaptureSegment: number;
    /**
     * Strip x fwd for
     */
    stripXFwdFor: boolean;
    /**
     * Tcp bypass exceed queue
     */
    tcpBypassExceedQueue: boolean;
    /**
     * Udp bypass exceed queue
     */
    udpBypassExceedQueue: boolean;
    /**
     * X forwarded for
     */
    xForwardedFor: string;
}

export interface GetContentIdSettingListDataContentIdApplication {
    /**
     * Bypass exceed queue
     */
    bypassExceedQueue: boolean;
}

export interface GetDecryptionExclusionListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetDecryptionProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Ssl forward proxy
     */
    sslForwardProxy: outputs.GetDecryptionProfileListDataSslForwardProxy;
    /**
     * Ssl inbound proxy
     */
    sslInboundProxy: outputs.GetDecryptionProfileListDataSslInboundProxy;
    /**
     * Ssl no proxy
     */
    sslNoProxy: outputs.GetDecryptionProfileListDataSslNoProxy;
    /**
     * Ssl protocol settings
     */
    sslProtocolSettings: outputs.GetDecryptionProfileListDataSslProtocolSettings;
    tfid: string;
}

export interface GetDecryptionProfileListDataSslForwardProxy {
    /**
     * Auto include altname
     */
    autoIncludeAltname: boolean;
    /**
     * Block client cert
     */
    blockClientCert: boolean;
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block timeout cert
     */
    blockTimeoutCert: boolean;
    /**
     * Block tls13 downgrade no resource
     */
    blockTls13DowngradeNoResource: boolean;
    /**
     * Block unknown cert
     */
    blockUnknownCert: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
    /**
     * Restrict cert exts
     */
    restrictCertExts: boolean;
    /**
     * Strip alpn
     */
    stripAlpn: boolean;
}

export interface GetDecryptionProfileListDataSslInboundProxy {
    /**
     * Block if hsm unavailable
     */
    blockIfHsmUnavailable: boolean;
    /**
     * Block if no resource
     */
    blockIfNoResource: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
}

export interface GetDecryptionProfileListDataSslNoProxy {
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
}

export interface GetDecryptionProfileListDataSslProtocolSettings {
    /**
     * Auth algo md5
     */
    authAlgoMd5: boolean;
    /**
     * Auth algo sha1
     */
    authAlgoSha1: boolean;
    /**
     * Auth algo sha256
     */
    authAlgoSha256: boolean;
    /**
     * Auth algo sha384
     */
    authAlgoSha384: boolean;
    /**
     * Enc algo3des
     */
    encAlgo3des: boolean;
    /**
     * Enc algo aes128 cbc
     */
    encAlgoAes128Cbc: boolean;
    /**
     * Enc algo aes128 gcm
     */
    encAlgoAes128Gcm: boolean;
    /**
     * Enc algo aes256 cbc
     */
    encAlgoAes256Cbc: boolean;
    /**
     * Enc algo aes256 gcm
     */
    encAlgoAes256Gcm: boolean;
    /**
     * Enc algo chacha20 poly1305
     */
    encAlgoChacha20Poly1305: boolean;
    /**
     * Enc algo rc4
     */
    encAlgoRc4: boolean;
    /**
     * Keyxchg algo dhe
     */
    keyxchgAlgoDhe: boolean;
    /**
     * Keyxchg algo ecdhe
     */
    keyxchgAlgoEcdhe: boolean;
    /**
     * Keyxchg algo rsa
     */
    keyxchgAlgoRsa: boolean;
    /**
     * Max version
     */
    maxVersion: string;
    /**
     * Min version
     */
    minVersion: string;
}

export interface GetDecryptionProfileSslForwardProxy {
    /**
     * Auto include altname
     */
    autoIncludeAltname: boolean;
    /**
     * Block client cert
     */
    blockClientCert: boolean;
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block timeout cert
     */
    blockTimeoutCert: boolean;
    /**
     * Block tls13 downgrade no resource
     */
    blockTls13DowngradeNoResource: boolean;
    /**
     * Block unknown cert
     */
    blockUnknownCert: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
    /**
     * Restrict cert exts
     */
    restrictCertExts: boolean;
    /**
     * Strip alpn
     */
    stripAlpn: boolean;
}

export interface GetDecryptionProfileSslInboundProxy {
    /**
     * Block if hsm unavailable
     */
    blockIfHsmUnavailable: boolean;
    /**
     * Block if no resource
     */
    blockIfNoResource: boolean;
    /**
     * Block unsupported cipher
     */
    blockUnsupportedCipher: boolean;
    /**
     * Block unsupported version
     */
    blockUnsupportedVersion: boolean;
}

export interface GetDecryptionProfileSslNoProxy {
    /**
     * Block expired certificate
     */
    blockExpiredCertificate: boolean;
    /**
     * Block untrusted issuer
     */
    blockUntrustedIssuer: boolean;
}

export interface GetDecryptionProfileSslProtocolSettings {
    /**
     * Auth algo md5
     */
    authAlgoMd5: boolean;
    /**
     * Auth algo sha1
     */
    authAlgoSha1: boolean;
    /**
     * Auth algo sha256
     */
    authAlgoSha256: boolean;
    /**
     * Auth algo sha384
     */
    authAlgoSha384: boolean;
    /**
     * Enc algo3des
     */
    encAlgo3des: boolean;
    /**
     * Enc algo aes128 cbc
     */
    encAlgoAes128Cbc: boolean;
    /**
     * Enc algo aes128 gcm
     */
    encAlgoAes128Gcm: boolean;
    /**
     * Enc algo aes256 cbc
     */
    encAlgoAes256Cbc: boolean;
    /**
     * Enc algo aes256 gcm
     */
    encAlgoAes256Gcm: boolean;
    /**
     * Enc algo chacha20 poly1305
     */
    encAlgoChacha20Poly1305: boolean;
    /**
     * Enc algo rc4
     */
    encAlgoRc4: boolean;
    /**
     * Keyxchg algo dhe
     */
    keyxchgAlgoDhe: boolean;
    /**
     * Keyxchg algo ecdhe
     */
    keyxchgAlgoEcdhe: boolean;
    /**
     * Keyxchg algo rsa
     */
    keyxchgAlgoRsa: boolean;
    /**
     * Max version
     */
    maxVersion: string;
    /**
     * Min version
     */
    minVersion: string;
}

export interface GetDecryptionRuleListData {
    /**
     * The action to be taken
     */
    action: string;
    /**
     * The destination URL category
     */
    categories: string[];
    /**
     * The description of the decryption rule
     */
    description: string;
    /**
     * The Host Integrity Profile of the destination host
     */
    destinationHips: string[];
    /**
     * The destination addresses
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Is the rule disabled?
     */
    disabled: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The source security zone
     */
    froms: string[];
    /**
     * The UUID of the decryption rule
     */
    id: string;
    /**
     * Log failed decryption events?
     */
    logFail: boolean;
    /**
     * The log settings of the decryption rule
     */
    logSetting: string;
    /**
     * Log successful decryption events?
     */
    logSuccess: boolean;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Negate the destination addresses?
     */
    negateDestination: boolean;
    /**
     * Negate the source addresses?
     */
    negateSource: boolean;
    /**
     * The position of a security rule
     */
    position: string;
    /**
     * The decryption profile associated with the decryption rule
     */
    profile: string;
    /**
     * Relative positioning rule. String must be one of these: `"before"`, `"after"`, `"top"`, `"bottom"`. If not specified, rule is created at the bottom of the ruleset.
     */
    relativePosition: string;
    /**
     * The destination services and/or service groups
     */
    services: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Source hip
     */
    sourceHips: string[];
    /**
     * List of source users and/or groups.  Reserved words include `any`, `pre-login`, `known-user`, and `unknown`.
     */
    sourceUsers: string[];
    /**
     * The source addresses
     */
    sources: string[];
    /**
     * The tags associated with the decryption rule
     */
    tags: string[];
    /**
     * The name or UUID of the rule to position this rule relative to. Required when `relativePosition` is `"before"` or `"after"`.
     */
    targetRule: string;
    tfid: string;
    /**
     * The destination security zone
     */
    tos: string[];
    /**
     * The type of decryption
     */
    type: outputs.GetDecryptionRuleListDataType;
}

export interface GetDecryptionRuleListDataType {
    /**
     * Ssl forward proxy
     */
    sslForwardProxy: outputs.GetDecryptionRuleListDataTypeSslForwardProxy;
    /**
     * add the certificate name for SSL inbound inspection
     *
     * > ℹ️ **Note:** You must specify exactly one of `sslForwardProxy` and `sslInboundInspection`.
     */
    sslInboundInspection: outputs.GetDecryptionRuleListDataTypeSslInboundInspection;
}

export interface GetDecryptionRuleListDataTypeSslForwardProxy {
}

export interface GetDecryptionRuleListDataTypeSslInboundInspection {
    /**
     * List of certificate names for SSL inbound inspection
     */
    certificates: string[];
}

export interface GetDecryptionRuleType {
    /**
     * Ssl forward proxy
     */
    sslForwardProxy: outputs.GetDecryptionRuleTypeSslForwardProxy;
    /**
     * add the certificate name for SSL inbound inspection
     *
     * > ℹ️ **Note:** You must specify exactly one of `sslForwardProxy` and `sslInboundInspection`.
     */
    sslInboundInspection: outputs.GetDecryptionRuleTypeSslInboundInspection;
}

export interface GetDecryptionRuleTypeSslForwardProxy {
}

export interface GetDecryptionRuleTypeSslInboundInspection {
    /**
     * List of certificate names for SSL inbound inspection
     */
    certificates: string[];
}

export interface GetDeviceRedistributionCollectorListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Redistribution collector
     */
    redistributionCollector: outputs.GetDeviceRedistributionCollectorListDataRedistributionCollector;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetDeviceRedistributionCollectorListDataRedistributionCollector {
    /**
     * User-ID collector interface
     */
    interface: string;
}

export interface GetDeviceRedistributionCollectorRedistributionCollector {
    /**
     * User-ID collector interface
     */
    interface: string;
}

export interface GetDhcpInterfaceListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Relay
     *
     * > ℹ️ **Note:** You must specify exactly one of `relay` and `server`.
     */
    relay: outputs.GetDhcpInterfaceListDataRelay;
    /**
     * Server
     *
     * > ℹ️ **Note:** You must specify exactly one of `relay` and `server`.
     */
    server: outputs.GetDhcpInterfaceListDataServer;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetDhcpInterfaceListDataRelay {
    /**
     * Ip
     */
    ip: outputs.GetDhcpInterfaceListDataRelayIp;
}

export interface GetDhcpInterfaceListDataRelayIp {
    /**
     * Enabled?
     */
    enabled: boolean;
    /**
     * Server
     */
    servers: string[];
}

export interface GetDhcpInterfaceListDataServer {
    /**
     * List of IP address pools
     */
    ipPools: string[];
    /**
     * DHCP server mode
     */
    mode: string;
    /**
     * Option
     */
    option: outputs.GetDhcpInterfaceListDataServerOption;
    /**
     * Ping IP before allocating?
     */
    probeIp: boolean;
    /**
     * List of IP reservations
     */
    reserveds: outputs.GetDhcpInterfaceListDataServerReserved[];
}

export interface GetDhcpInterfaceListDataServerOption {
    /**
     * Dns
     */
    dns: outputs.GetDhcpInterfaceListDataServerOptionDns;
    /**
     * DNS suffix
     */
    dnsSuffix: string;
    /**
     * Default gateway
     */
    gateway: string;
    /**
     * Inheritance
     */
    inheritance: outputs.GetDhcpInterfaceListDataServerOptionInheritance;
    /**
     * Lease
     */
    lease: outputs.GetDhcpInterfaceListDataServerOptionLease;
    /**
     * Nis
     */
    nis: outputs.GetDhcpInterfaceListDataServerOptionNis;
    /**
     * Ntp
     */
    ntp: outputs.GetDhcpInterfaceListDataServerOptionNtp;
    /**
     * POP3 server
     */
    pop3Server: string;
    /**
     * SMTP server
     */
    smtpServer: string;
    /**
     * Subnet mask
     */
    subnetMask: string;
    /**
     * Custom DHCP options
     */
    userDefineds: outputs.GetDhcpInterfaceListDataServerOptionUserDefined[];
    /**
     * Wins
     */
    wins: outputs.GetDhcpInterfaceListDataServerOptionWins;
}

export interface GetDhcpInterfaceListDataServerOptionDns {
    /**
     * Primary DNS server
     */
    primary: string;
    /**
     * Secondary DNS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceListDataServerOptionInheritance {
    /**
     * Interface from which to inherit lease options
     */
    source: string;
}

export interface GetDhcpInterfaceListDataServerOptionLease {
    /**
     * DHCP lease timeout (minutes)
     */
    timeout: number;
    /**
     * Unlimited
     *
     * > ℹ️ **Note:** You must specify exactly one of `timeout` and `unlimited`.
     */
    unlimited: outputs.GetDhcpInterfaceListDataServerOptionLeaseUnlimited;
}

export interface GetDhcpInterfaceListDataServerOptionLeaseUnlimited {
}

export interface GetDhcpInterfaceListDataServerOptionNis {
    /**
     * Primary NIS server
     */
    primary: string;
    /**
     * Secondary NIS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceListDataServerOptionNtp {
    /**
     * Primary NTP server
     */
    primary: string;
    /**
     * Secondary NTP server
     */
    secondary: string;
}

export interface GetDhcpInterfaceListDataServerOptionUserDefined {
    /**
     * Ascii
     */
    asciis: string[];
    /**
     * Option code
     */
    code: number;
    /**
     * Hex
     */
    hexes: string[];
    /**
     * Inherited from DHCP server inheritance source?
     */
    inherited: boolean;
    /**
     * Ip
     */
    ips: string[];
    /**
     * Option name
     */
    name: string;
}

export interface GetDhcpInterfaceListDataServerOptionWins {
    /**
     * Primary WINS server
     */
    primary: string;
    /**
     * Secondary WINS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceListDataServerReserved {
    /**
     * Reservation description
     */
    description: string;
    /**
     * Reserved MAC address
     */
    mac: string;
    /**
     * Reserved IP address
     */
    name: string;
}

export interface GetDhcpInterfaceRelay {
    /**
     * Ip
     */
    ip: outputs.GetDhcpInterfaceRelayIp;
}

export interface GetDhcpInterfaceRelayIp {
    /**
     * Enabled?
     */
    enabled: boolean;
    /**
     * Server
     */
    servers: string[];
}

export interface GetDhcpInterfaceServer {
    /**
     * List of IP address pools
     */
    ipPools: string[];
    /**
     * DHCP server mode
     */
    mode: string;
    /**
     * Option
     */
    option: outputs.GetDhcpInterfaceServerOption;
    /**
     * Ping IP before allocating?
     */
    probeIp: boolean;
    /**
     * List of IP reservations
     */
    reserveds: outputs.GetDhcpInterfaceServerReserved[];
}

export interface GetDhcpInterfaceServerOption {
    /**
     * Dns
     */
    dns: outputs.GetDhcpInterfaceServerOptionDns;
    /**
     * DNS suffix
     */
    dnsSuffix: string;
    /**
     * Default gateway
     */
    gateway: string;
    /**
     * Inheritance
     */
    inheritance: outputs.GetDhcpInterfaceServerOptionInheritance;
    /**
     * Lease
     */
    lease: outputs.GetDhcpInterfaceServerOptionLease;
    /**
     * Nis
     */
    nis: outputs.GetDhcpInterfaceServerOptionNis;
    /**
     * Ntp
     */
    ntp: outputs.GetDhcpInterfaceServerOptionNtp;
    /**
     * POP3 server
     */
    pop3Server: string;
    /**
     * SMTP server
     */
    smtpServer: string;
    /**
     * Subnet mask
     */
    subnetMask: string;
    /**
     * Custom DHCP options
     */
    userDefineds: outputs.GetDhcpInterfaceServerOptionUserDefined[];
    /**
     * Wins
     */
    wins: outputs.GetDhcpInterfaceServerOptionWins;
}

export interface GetDhcpInterfaceServerOptionDns {
    /**
     * Primary DNS server
     */
    primary: string;
    /**
     * Secondary DNS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceServerOptionInheritance {
    /**
     * Interface from which to inherit lease options
     */
    source: string;
}

export interface GetDhcpInterfaceServerOptionLease {
    /**
     * DHCP lease timeout (minutes)
     */
    timeout: number;
    /**
     * Unlimited
     *
     * > ℹ️ **Note:** You must specify exactly one of `timeout` and `unlimited`.
     */
    unlimited: outputs.GetDhcpInterfaceServerOptionLeaseUnlimited;
}

export interface GetDhcpInterfaceServerOptionLeaseUnlimited {
}

export interface GetDhcpInterfaceServerOptionNis {
    /**
     * Primary NIS server
     */
    primary: string;
    /**
     * Secondary NIS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceServerOptionNtp {
    /**
     * Primary NTP server
     */
    primary: string;
    /**
     * Secondary NTP server
     */
    secondary: string;
}

export interface GetDhcpInterfaceServerOptionUserDefined {
    /**
     * Ascii
     */
    asciis: string[];
    /**
     * Option code
     */
    code: number;
    /**
     * Hex
     */
    hexes: string[];
    /**
     * Inherited from DHCP server inheritance source?
     */
    inherited: boolean;
    /**
     * Ip
     */
    ips: string[];
    /**
     * Option name
     */
    name: string;
}

export interface GetDhcpInterfaceServerOptionWins {
    /**
     * Primary WINS server
     */
    primary: string;
    /**
     * Secondary WINS server
     */
    secondary: string;
}

export interface GetDhcpInterfaceServerReserved {
    /**
     * Reservation description
     */
    description: string;
    /**
     * Reserved MAC address
     */
    mac: string;
    /**
     * Reserved IP address
     */
    name: string;
}

export interface GetDnsProxyCache {
    /**
     * Cache EDNS UDP response
     */
    cacheEdns: boolean;
    /**
     * Turn on caching for this DNS object
     */
    enabled: boolean;
    /**
     * Max ttl
     */
    maxTtl: outputs.GetDnsProxyCacheMaxTtl;
}

export interface GetDnsProxyCacheMaxTtl {
    /**
     * Enable max ttl for this DNS object
     */
    enabled: boolean;
    /**
     * Time in seconds after which entry is cleared
     */
    timeToLive: number;
}

export interface GetDnsProxyDefault {
    /**
     * Inheritance
     */
    inheritance: outputs.GetDnsProxyDefaultInheritance;
    /**
     * Primary DNS Name server IP address
     */
    primary: string;
    /**
     * Secondary DNS Name server IP address
     */
    secondary: string;
}

export interface GetDnsProxyDefaultInheritance {
    /**
     * Dynamic interface
     */
    source: string;
}

export interface GetDnsProxyDomainServer {
    /**
     * Enable caching for this DNS proxy rule?
     */
    cacheable: boolean;
    /**
     * Domain names(s) that will be matched
     */
    domainNames: string[];
    /**
     * Proxy rule name
     */
    name: string;
    /**
     * Primary DNS server IP address
     */
    primary: string;
    /**
     * Secondary DNS server IP address
     */
    secondary: string;
}

export interface GetDnsProxyListData {
    /**
     * Cache
     */
    cache: outputs.GetDnsProxyListDataCache;
    /**
     * Default
     */
    default: outputs.GetDnsProxyListDataDefault;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * DNS proxy rules
     */
    domainServers: outputs.GetDnsProxyListDataDomainServer[];
    /**
     * Enable DNS proxy?
     */
    enabled: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Interfaces on which to enable DNS proxy service
     */
    interfaces: string[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Static entries
     */
    staticEntries: outputs.GetDnsProxyListDataStaticEntry[];
    /**
     * Tcp queries
     */
    tcpQueries: outputs.GetDnsProxyListDataTcpQueries;
    tfid: string;
    /**
     * Udp queries
     */
    udpQueries: outputs.GetDnsProxyListDataUdpQueries;
}

export interface GetDnsProxyListDataCache {
    /**
     * Cache EDNS UDP response
     */
    cacheEdns: boolean;
    /**
     * Turn on caching for this DNS object
     */
    enabled: boolean;
    /**
     * Max ttl
     */
    maxTtl: outputs.GetDnsProxyListDataCacheMaxTtl;
}

export interface GetDnsProxyListDataCacheMaxTtl {
    /**
     * Enable max ttl for this DNS object
     */
    enabled: boolean;
    /**
     * Time in seconds after which entry is cleared
     */
    timeToLive: number;
}

export interface GetDnsProxyListDataDefault {
    /**
     * Inheritance
     */
    inheritance: outputs.GetDnsProxyListDataDefaultInheritance;
    /**
     * Primary DNS Name server IP address
     */
    primary: string;
    /**
     * Secondary DNS Name server IP address
     */
    secondary: string;
}

export interface GetDnsProxyListDataDefaultInheritance {
    /**
     * Dynamic interface
     */
    source: string;
}

export interface GetDnsProxyListDataDomainServer {
    /**
     * Enable caching for this DNS proxy rule?
     */
    cacheable: boolean;
    /**
     * Domain names(s) that will be matched
     */
    domainNames: string[];
    /**
     * Proxy rule name
     */
    name: string;
    /**
     * Primary DNS server IP address
     */
    primary: string;
    /**
     * Secondary DNS server IP address
     */
    secondary: string;
}

export interface GetDnsProxyListDataStaticEntry {
    /**
     * Address
     */
    addresses: string[];
    /**
     * Fully qualified domain name
     */
    domain: string;
    /**
     * Static entry name
     */
    name: string;
}

export interface GetDnsProxyListDataTcpQueries {
    /**
     * Turn on forwarding of TCP DNS queries?
     */
    enabled: boolean;
    /**
     * Upper limit on number of concurrent TCP DNS requests
     */
    maxPendingRequests: number;
}

export interface GetDnsProxyListDataUdpQueries {
    /**
     * Retries
     */
    retries: outputs.GetDnsProxyListDataUdpQueriesRetries;
}

export interface GetDnsProxyListDataUdpQueriesRetries {
    /**
     * Maximum number of retries before trying next name server
     */
    attempts: number;
    /**
     * Time in seconds for another request to be sent
     */
    interval: number;
}

export interface GetDnsProxyStaticEntry {
    /**
     * Address
     */
    addresses: string[];
    /**
     * Fully qualified domain name
     */
    domain: string;
    /**
     * Static entry name
     */
    name: string;
}

export interface GetDnsProxyTcpQueries {
    /**
     * Turn on forwarding of TCP DNS queries?
     */
    enabled: boolean;
    /**
     * Upper limit on number of concurrent TCP DNS requests
     */
    maxPendingRequests: number;
}

export interface GetDnsProxyUdpQueries {
    /**
     * Retries
     */
    retries: outputs.GetDnsProxyUdpQueriesRetries;
}

export interface GetDnsProxyUdpQueriesRetries {
    /**
     * Maximum number of retries before trying next name server
     */
    attempts: number;
    /**
     * Time in seconds for another request to be sent
     */
    interval: number;
}

export interface GetDnsSecurityProfileBotnetDomains {
    /**
     * DNS categories
     */
    dnsSecurityCategories: outputs.GetDnsSecurityProfileBotnetDomainsDnsSecurityCategory[];
    /**
     * Dynamic lists of DNS domains
     */
    lists: outputs.GetDnsSecurityProfileBotnetDomainsList[];
    /**
     * DNS sinkhole settings
     */
    sinkhole: outputs.GetDnsSecurityProfileBotnetDomainsSinkhole;
    /**
     * DNS security overrides
     */
    whitelists: outputs.GetDnsSecurityProfileBotnetDomainsWhitelist[];
}

export interface GetDnsSecurityProfileBotnetDomainsDnsSecurityCategory {
    /**
     * Action
     */
    action: string;
    /**
     * Log level
     */
    logLevel: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetDnsSecurityProfileBotnetDomainsList {
    /**
     * Action
     */
    action: outputs.GetDnsSecurityProfileBotnetDomainsListAction;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetDnsSecurityProfileBotnetDomainsListAction {
    /**
     * Alert
     */
    alert: outputs.GetDnsSecurityProfileBotnetDomainsListActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    allow: outputs.GetDnsSecurityProfileBotnetDomainsListActionAllow;
    /**
     * Block
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    block: outputs.GetDnsSecurityProfileBotnetDomainsListActionBlock;
    /**
     * Sinkhole
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    sinkhole: outputs.GetDnsSecurityProfileBotnetDomainsListActionSinkhole;
}

export interface GetDnsSecurityProfileBotnetDomainsListActionAlert {
}

export interface GetDnsSecurityProfileBotnetDomainsListActionAllow {
}

export interface GetDnsSecurityProfileBotnetDomainsListActionBlock {
}

export interface GetDnsSecurityProfileBotnetDomainsListActionSinkhole {
}

export interface GetDnsSecurityProfileBotnetDomainsSinkhole {
    /**
     * Ipv4 address
     */
    ipv4Address: string;
    /**
     * Ipv6 address
     */
    ipv6Address: string;
}

export interface GetDnsSecurityProfileBotnetDomainsWhitelist {
    /**
     * Description
     */
    description: string;
    /**
     * DNS domain or FQDN to be whitelisted
     */
    name: string;
}

export interface GetDnsSecurityProfileListData {
    /**
     * Botnet domains
     */
    botnetDomains: outputs.GetDnsSecurityProfileListDataBotnetDomains;
    /**
     * The description of the DNS security profile
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the DNS security profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetDnsSecurityProfileListDataBotnetDomains {
    /**
     * DNS categories
     */
    dnsSecurityCategories: outputs.GetDnsSecurityProfileListDataBotnetDomainsDnsSecurityCategory[];
    /**
     * Dynamic lists of DNS domains
     */
    lists: outputs.GetDnsSecurityProfileListDataBotnetDomainsList[];
    /**
     * DNS sinkhole settings
     */
    sinkhole: outputs.GetDnsSecurityProfileListDataBotnetDomainsSinkhole;
    /**
     * DNS security overrides
     */
    whitelists: outputs.GetDnsSecurityProfileListDataBotnetDomainsWhitelist[];
}

export interface GetDnsSecurityProfileListDataBotnetDomainsDnsSecurityCategory {
    /**
     * Action
     */
    action: string;
    /**
     * Log level
     */
    logLevel: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetDnsSecurityProfileListDataBotnetDomainsList {
    /**
     * Action
     */
    action: outputs.GetDnsSecurityProfileListDataBotnetDomainsListAction;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
}

export interface GetDnsSecurityProfileListDataBotnetDomainsListAction {
    /**
     * Alert
     */
    alert: outputs.GetDnsSecurityProfileListDataBotnetDomainsListActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    allow: outputs.GetDnsSecurityProfileListDataBotnetDomainsListActionAllow;
    /**
     * Block
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    block: outputs.GetDnsSecurityProfileListDataBotnetDomainsListActionBlock;
    /**
     * Sinkhole
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
     */
    sinkhole: outputs.GetDnsSecurityProfileListDataBotnetDomainsListActionSinkhole;
}

export interface GetDnsSecurityProfileListDataBotnetDomainsListActionAlert {
}

export interface GetDnsSecurityProfileListDataBotnetDomainsListActionAllow {
}

export interface GetDnsSecurityProfileListDataBotnetDomainsListActionBlock {
}

export interface GetDnsSecurityProfileListDataBotnetDomainsListActionSinkhole {
}

export interface GetDnsSecurityProfileListDataBotnetDomainsSinkhole {
    /**
     * Ipv4 address
     */
    ipv4Address: string;
    /**
     * Ipv6 address
     */
    ipv6Address: string;
}

export interface GetDnsSecurityProfileListDataBotnetDomainsWhitelist {
    /**
     * Description
     */
    description: string;
    /**
     * DNS domain or FQDN to be whitelisted
     */
    name: string;
}

export interface GetDosProtectionProfileFlood {
    /**
     * Icmp
     */
    icmp: outputs.GetDosProtectionProfileFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6: outputs.GetDosProtectionProfileFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp: outputs.GetDosProtectionProfileFloodOtherIp;
    /**
     * Tcp syn
     */
    tcpSyn: outputs.GetDosProtectionProfileFloodTcpSyn;
    /**
     * Udp
     */
    udp: outputs.GetDosProtectionProfileFloodUdp;
}

export interface GetDosProtectionProfileFloodIcmp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileFloodIcmpRed;
}

export interface GetDosProtectionProfileFloodIcmpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodIcmpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodIcmpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileFloodIcmpv6 {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileFloodIcmpv6Red;
}

export interface GetDosProtectionProfileFloodIcmpv6Red {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodIcmpv6RedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodIcmpv6RedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileFloodOtherIp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileFloodOtherIpRed;
}

export interface GetDosProtectionProfileFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodOtherIpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodOtherIpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileFloodTcpSyn {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies: outputs.GetDosProtectionProfileFloodTcpSynSynCookies;
}

export interface GetDosProtectionProfileFloodTcpSynRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodTcpSynRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodTcpSynRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileFloodTcpSynSynCookies {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodTcpSynSynCookiesBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodTcpSynSynCookiesBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileFloodUdp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileFloodUdpRed;
}

export interface GetDosProtectionProfileFloodUdpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileFloodUdpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileFloodUdpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Flood
     */
    flood: outputs.GetDosProtectionProfileListDataFlood;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the DNS security profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Resource
     */
    resource: outputs.GetDosProtectionProfileListDataResource;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Type
     */
    type: string;
}

export interface GetDosProtectionProfileListDataFlood {
    /**
     * Icmp
     */
    icmp: outputs.GetDosProtectionProfileListDataFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6: outputs.GetDosProtectionProfileListDataFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp: outputs.GetDosProtectionProfileListDataFloodOtherIp;
    /**
     * Tcp syn
     */
    tcpSyn: outputs.GetDosProtectionProfileListDataFloodTcpSyn;
    /**
     * Udp
     */
    udp: outputs.GetDosProtectionProfileListDataFloodUdp;
}

export interface GetDosProtectionProfileListDataFloodIcmp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileListDataFloodIcmpRed;
}

export interface GetDosProtectionProfileListDataFloodIcmpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodIcmpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodIcmpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataFloodIcmpv6 {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileListDataFloodIcmpv6Red;
}

export interface GetDosProtectionProfileListDataFloodIcmpv6Red {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodIcmpv6RedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodIcmpv6RedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataFloodOtherIp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileListDataFloodOtherIpRed;
}

export interface GetDosProtectionProfileListDataFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodOtherIpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodOtherIpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataFloodTcpSyn {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileListDataFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies: outputs.GetDosProtectionProfileListDataFloodTcpSynSynCookies;
}

export interface GetDosProtectionProfileListDataFloodTcpSynRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodTcpSynRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodTcpSynRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataFloodTcpSynSynCookies {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodTcpSynSynCookiesBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodTcpSynSynCookiesBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataFloodUdp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetDosProtectionProfileListDataFloodUdpRed;
}

export interface GetDosProtectionProfileListDataFloodUdpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Block
     */
    block: outputs.GetDosProtectionProfileListDataFloodUdpRedBlock;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetDosProtectionProfileListDataFloodUdpRedBlock {
    /**
     * Duration
     */
    duration: number;
}

export interface GetDosProtectionProfileListDataResource {
    /**
     * Sessions
     */
    sessions: outputs.GetDosProtectionProfileListDataResourceSessions;
}

export interface GetDosProtectionProfileListDataResourceSessions {
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Max concurrent limit
     */
    maxConcurrentLimit: number;
}

export interface GetDosProtectionProfileResource {
    /**
     * Sessions
     */
    sessions: outputs.GetDosProtectionProfileResourceSessions;
}

export interface GetDosProtectionProfileResourceSessions {
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Max concurrent limit
     */
    maxConcurrentLimit: number;
}

export interface GetDosProtectionRuleAction {
    /**
     * Allow
     */
    allow: outputs.GetDosProtectionRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    deny: outputs.GetDosProtectionRuleActionDeny;
    /**
     * Protect
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    protect: outputs.GetDosProtectionRuleActionProtect;
}

export interface GetDosProtectionRuleActionAllow {
}

export interface GetDosProtectionRuleActionDeny {
}

export interface GetDosProtectionRuleActionProtect {
}

export interface GetDosProtectionRuleListData {
    /**
     * The action to take on rule match
     */
    action: outputs.GetDosProtectionRuleListDataAction;
    /**
     * Description
     */
    description: string;
    /**
     * List of destination addresses
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Rule disabled?
     */
    disabled: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * List of source zones
     */
    froms: string[];
    /**
     * The UUID of the DNS security profile
     */
    id: string;
    /**
     * Log forwarding profile name
     */
    logSetting: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Position relative to local device rules
     */
    position: string;
    /**
     * Protection
     */
    protection: outputs.GetDosProtectionRuleListDataProtection;
    /**
     * Schedule on which to enforce the rule
     */
    schedule: string;
    /**
     * List of services
     */
    services: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * List of source users and/or groups.  Reserved words include `any`, `pre-login`, `known-user`, and `unknown`.
     */
    sourceUsers: string[];
    /**
     * List of source addresses
     */
    sources: string[];
    /**
     * List of tags
     */
    tags: string[];
    tfid: string;
    /**
     * List of destination zones
     */
    tos: string[];
}

export interface GetDosProtectionRuleListDataAction {
    /**
     * Allow
     */
    allow: outputs.GetDosProtectionRuleListDataActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    deny: outputs.GetDosProtectionRuleListDataActionDeny;
    /**
     * Protect
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
     */
    protect: outputs.GetDosProtectionRuleListDataActionProtect;
}

export interface GetDosProtectionRuleListDataActionAllow {
}

export interface GetDosProtectionRuleListDataActionDeny {
}

export interface GetDosProtectionRuleListDataActionProtect {
}

export interface GetDosProtectionRuleListDataProtection {
    /**
     * Aggregate
     */
    aggregate: outputs.GetDosProtectionRuleListDataProtectionAggregate;
    /**
     * Classified
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregate` and `classified`.
     */
    classified: outputs.GetDosProtectionRuleListDataProtectionClassified;
}

export interface GetDosProtectionRuleListDataProtectionAggregate {
    /**
     * Aggregate DoS protection profile
     */
    profile: string;
}

export interface GetDosProtectionRuleListDataProtectionClassified {
    /**
     * Classification criteria
     */
    classificationCriteria: outputs.GetDosProtectionRuleListDataProtectionClassifiedClassificationCriteria;
    /**
     * Classified DoS protection profile
     */
    profile: string;
}

export interface GetDosProtectionRuleListDataProtectionClassifiedClassificationCriteria {
    /**
     * Address
     */
    address: string;
}

export interface GetDosProtectionRuleProtection {
    /**
     * Aggregate
     */
    aggregate: outputs.GetDosProtectionRuleProtectionAggregate;
    /**
     * Classified
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregate` and `classified`.
     */
    classified: outputs.GetDosProtectionRuleProtectionClassified;
}

export interface GetDosProtectionRuleProtectionAggregate {
    /**
     * Aggregate DoS protection profile
     */
    profile: string;
}

export interface GetDosProtectionRuleProtectionClassified {
    /**
     * Classification criteria
     */
    classificationCriteria: outputs.GetDosProtectionRuleProtectionClassifiedClassificationCriteria;
    /**
     * Classified DoS protection profile
     */
    profile: string;
}

export interface GetDosProtectionRuleProtectionClassifiedClassificationCriteria {
    /**
     * Address
     */
    address: string;
}

export interface GetDynamicUserGroupListData {
    /**
     * The description of the dynamic address group
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The tag-based filter for the dynamic user group
     */
    filter: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the dynamic user group
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tags associated with the dynamic user group
     */
    tags: string[];
    tfid: string;
}

export interface GetEthernetInterfaceLayer2 {
    /**
     * LLDP Settings
     */
    lldp: outputs.GetEthernetInterfaceLayer2Lldp;
    /**
     * Assign interface to VLAN tag
     */
    vlanTag: string;
}

export interface GetEthernetInterfaceLayer2Lldp {
    /**
     * Enable LLDP on Interface
     */
    enable: boolean;
}

export interface GetEthernetInterfaceLayer3 {
    /**
     * Ethernet Interfaces ARP configuration
     */
    arps: outputs.GetEthernetInterfaceLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Ethernet Interfaces.
     */
    ddnsConfig: outputs.GetEthernetInterfaceLayer3DdnsConfig;
    /**
     * Ethernet Interfaces DHCP Client Object
     */
    dhcpClient: outputs.GetEthernetInterfaceLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Ethernet Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    ips: outputs.GetEthernetInterfaceLayer3Ip[];
    /**
     * MTU
     */
    mtu: number;
    /**
     * Pppoe
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    pppoe: outputs.GetEthernetInterfaceLayer3Pppoe;
}

export interface GetEthernetInterfaceLayer3Arp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetEthernetInterfaceLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetEthernetInterfaceLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Ethernet Interfaces DHCP ClientSend hostname
     */
    sendHostname: outputs.GetEthernetInterfaceLayer3DhcpClientSendHostname;
}

export interface GetEthernetInterfaceLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetEthernetInterfaceLayer3Ip {
    /**
     * Ethernet Interface IP addresses name
     */
    name: string;
}

export interface GetEthernetInterfaceLayer3Pppoe {
    /**
     * Access concentrator
     */
    accessConcentrator: string;
    /**
     * Authentication protocol
     */
    authentication: string;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Passive
     */
    passive: outputs.GetEthernetInterfaceLayer3PppoePassive;
    /**
     * Password
     */
    password: string;
    /**
     * Service
     */
    service: string;
    /**
     * Static address
     */
    staticAddress: outputs.GetEthernetInterfaceLayer3PppoeStaticAddress;
    /**
     * Username
     */
    username: string;
}

export interface GetEthernetInterfaceLayer3PppoePassive {
    /**
     * Passive Mode enabled
     */
    enable: boolean;
}

export interface GetEthernetInterfaceLayer3PppoeStaticAddress {
    /**
     * Static IP address
     */
    ip: string;
}

export interface GetEthernetInterfaceListData {
    /**
     * Aggregate group
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregateGroup`, `layer2`, `layer3`, and `tap`.
     */
    aggregateGroup: string;
    /**
     * Interface description
     */
    comment: string;
    /**
     * Default interface assignment
     */
    defaultValue: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Layer2
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregateGroup`, `layer2`, `layer3`, and `tap`.
     */
    layer2: outputs.GetEthernetInterfaceListDataLayer2;
    /**
     * Ethernet Interface Layer 3 configuration
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregateGroup`, `layer2`, `layer3`, and `tap`.
     */
    layer3: outputs.GetEthernetInterfaceListDataLayer3;
    /**
     * Link duplex
     */
    linkDuplex: string;
    /**
     * Link speed
     */
    linkSpeed: string;
    /**
     * Link state
     */
    linkState: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Poe
     */
    poe: outputs.GetEthernetInterfaceListDataPoe;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tap
     *
     * > ℹ️ **Note:** You must specify exactly one of `aggregateGroup`, `layer2`, `layer3`, and `tap`.
     */
    tap: outputs.GetEthernetInterfaceListDataTap;
    tfid: string;
}

export interface GetEthernetInterfaceListDataLayer2 {
    /**
     * LLDP Settings
     */
    lldp: outputs.GetEthernetInterfaceListDataLayer2Lldp;
    /**
     * Assign interface to VLAN tag
     */
    vlanTag: string;
}

export interface GetEthernetInterfaceListDataLayer2Lldp {
    /**
     * Enable LLDP on Interface
     */
    enable: boolean;
}

export interface GetEthernetInterfaceListDataLayer3 {
    /**
     * Ethernet Interfaces ARP configuration
     */
    arps: outputs.GetEthernetInterfaceListDataLayer3Arp[];
    /**
     * Dynamic DNS configuration specific to the Ethernet Interfaces.
     */
    ddnsConfig: outputs.GetEthernetInterfaceListDataLayer3DdnsConfig;
    /**
     * Ethernet Interfaces DHCP Client Object
     */
    dhcpClient: outputs.GetEthernetInterfaceListDataLayer3DhcpClient;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Ethernet Interface IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    ips: outputs.GetEthernetInterfaceListDataLayer3Ip[];
    /**
     * MTU
     */
    mtu: number;
    /**
     * Pppoe
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient`, `ip`, and `pppoe`.
     */
    pppoe: outputs.GetEthernetInterfaceListDataLayer3Pppoe;
}

export interface GetEthernetInterfaceListDataLayer3Arp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetEthernetInterfaceListDataLayer3DdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetEthernetInterfaceListDataLayer3DhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Ethernet Interfaces DHCP ClientSend hostname
     */
    sendHostname: outputs.GetEthernetInterfaceListDataLayer3DhcpClientSendHostname;
}

export interface GetEthernetInterfaceListDataLayer3DhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetEthernetInterfaceListDataLayer3Ip {
    /**
     * Ethernet Interface IP addresses name
     */
    name: string;
}

export interface GetEthernetInterfaceListDataLayer3Pppoe {
    /**
     * Access concentrator
     */
    accessConcentrator: string;
    /**
     * Authentication protocol
     */
    authentication: string;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Passive
     */
    passive: outputs.GetEthernetInterfaceListDataLayer3PppoePassive;
    /**
     * Password
     */
    password: string;
    /**
     * Service
     */
    service: string;
    /**
     * Static address
     */
    staticAddress: outputs.GetEthernetInterfaceListDataLayer3PppoeStaticAddress;
    /**
     * Username
     */
    username: string;
}

export interface GetEthernetInterfaceListDataLayer3PppoePassive {
    /**
     * Passive Mode enabled
     */
    enable: boolean;
}

export interface GetEthernetInterfaceListDataLayer3PppoeStaticAddress {
    /**
     * Static IP address
     */
    ip: string;
}

export interface GetEthernetInterfaceListDataPoe {
    /**
     * Enabled PoE?
     */
    poeEnabled: boolean;
    /**
     * PoE reserved power
     */
    poeRsvdPwr: number;
}

export interface GetEthernetInterfaceListDataTap {
}

export interface GetEthernetInterfacePoe {
    /**
     * Enabled PoE?
     */
    poeEnabled: boolean;
    /**
     * PoE reserved power
     */
    poeRsvdPwr: number;
}

export interface GetEthernetInterfaceTap {
}

export interface GetExternalDynamicListListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the external dynamic list
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Type configuration for External Dynamic List
     */
    type: outputs.GetExternalDynamicListListDataType;
}

export interface GetExternalDynamicListListDataType {
    /**
     * Domain settings for Custom Domain type
     */
    domain: outputs.GetExternalDynamicListListDataTypeDomain;
    /**
     * IMEI Configuration settings
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imei: outputs.GetExternalDynamicListListDataTypeImei;
    /**
     * IMSI Config for Custom IMSI type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imsi: outputs.GetExternalDynamicListListDataTypeImsi;
    /**
     * IP settings for Custom IP type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    ip: outputs.GetExternalDynamicListListDataTypeIp;
    /**
     * Predefined IP settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedIp: outputs.GetExternalDynamicListListDataTypePredefinedIp;
    /**
     * Predefined URL settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedUrl: outputs.GetExternalDynamicListListDataTypePredefinedUrl;
    /**
     * URL settings for Custom URL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    url: outputs.GetExternalDynamicListListDataTypeUrl;
}

export interface GetExternalDynamicListListDataTypeDomain {
    /**
     * Authentication settings for Custom Domain type
     */
    auth: outputs.GetExternalDynamicListListDataTypeDomainAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * Domain Exception List for Custom Domain type
     */
    exceptionLists: string[];
    /**
     * Enable/Disable expand domain
     */
    expandDomain: boolean;
    /**
     * Update Schedule for Custom Domain type
     */
    recurring: outputs.GetExternalDynamicListListDataTypeDomainRecurring;
    /**
     * External URL for Custom Domain type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeDomainAuth {
    /**
     * Password for Custom Domain authentication
     */
    password: string;
    /**
     * Username for Custom Domain authentication
     */
    username: string;
}

export interface GetExternalDynamicListListDataTypeDomainRecurring {
    /**
     * Daily settings for Domain recurring
     */
    daily: outputs.GetExternalDynamicListListDataTypeDomainRecurringDaily;
    /**
     * Five minute settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListListDataTypeDomainRecurringFiveMinute;
    /**
     * Hourly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListListDataTypeDomainRecurringHourly;
    /**
     * Monthly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListListDataTypeDomainRecurringMonthly;
    /**
     * Weekly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListListDataTypeDomainRecurringWeekly;
}

export interface GetExternalDynamicListListDataTypeDomainRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for Domain
     */
    at: string;
}

export interface GetExternalDynamicListListDataTypeDomainRecurringFiveMinute {
}

export interface GetExternalDynamicListListDataTypeDomainRecurringHourly {
}

export interface GetExternalDynamicListListDataTypeDomainRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for domain
     */
    at: string;
    /**
     * Day setting for monthly Domain updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListListDataTypeDomainRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for Domain
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListListDataTypeImei {
    /**
     * IMEI Auth Cnfig for Custom IMEI type
     */
    auth: outputs.GetExternalDynamicListListDataTypeImeiAuth;
    /**
     * IMEI Certificate Profile for Custom IMEI type
     */
    certificateProfile: string;
    /**
     * IMEI Description for Custom IMEI type
     */
    description: string;
    /**
     * IMEI Exception List for Custom IMEI type
     */
    exceptionLists: string[];
    /**
     * Recurring interval for IMEI updates
     */
    recurring: outputs.GetExternalDynamicListListDataTypeImeiRecurring;
    /**
     * IMEI URL for Custom IMEI type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeImeiAuth {
    /**
     * IMEI Auth Password for Custom IMEI type
     */
    password: string;
    /**
     * IMEI Auth username for Custom IMEI type
     */
    username: string;
}

export interface GetExternalDynamicListListDataTypeImeiRecurring {
    /**
     * Daily interval settings for IMEI updates
     */
    daily: outputs.GetExternalDynamicListListDataTypeImeiRecurringDaily;
    /**
     * Five-minute interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListListDataTypeImeiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListListDataTypeImeiRecurringHourly;
    /**
     * Monthly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListListDataTypeImeiRecurringMonthly;
    /**
     * Weekly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListListDataTypeImeiRecurringWeekly;
}

export interface GetExternalDynamicListListDataTypeImeiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMEI
     */
    at: string;
}

export interface GetExternalDynamicListListDataTypeImeiRecurringFiveMinute {
}

export interface GetExternalDynamicListListDataTypeImeiRecurringHourly {
}

export interface GetExternalDynamicListListDataTypeImeiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of month for IMEI updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListListDataTypeImeiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListListDataTypeImsi {
    /**
     * IMSI Auth Config for Custom IMSI type
     */
    auth: outputs.GetExternalDynamicListListDataTypeImsiAuth;
    /**
     * IMSI Certificate Profile for Custom IMSI type
     */
    certificateProfile: string;
    /**
     * IMSI Description for Custom IMSI type
     */
    description: string;
    /**
     * IMSI Exception List for Custom IMSI type
     */
    exceptionLists: string[];
    /**
     * IMSI Recuring Config for Custom IMSI type
     */
    recurring: outputs.GetExternalDynamicListListDataTypeImsiRecurring;
    /**
     * IMSI URL for Custom IMSI type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeImsiAuth {
    /**
     * IMSI Auth Password for Custom IMSI type
     */
    password: string;
    /**
     * IMSI Auth Username for Custom IMSI type
     */
    username: string;
}

export interface GetExternalDynamicListListDataTypeImsiRecurring {
    /**
     * Daily interval settings for IMSI updates
     */
    daily: outputs.GetExternalDynamicListListDataTypeImsiRecurringDaily;
    /**
     * Five-minute interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListListDataTypeImsiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListListDataTypeImsiRecurringHourly;
    /**
     * Monthly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListListDataTypeImsiRecurringMonthly;
    /**
     * Weekly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListListDataTypeImsiRecurringWeekly;
}

export interface GetExternalDynamicListListDataTypeImsiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMSI
     */
    at: string;
}

export interface GetExternalDynamicListListDataTypeImsiRecurringFiveMinute {
}

export interface GetExternalDynamicListListDataTypeImsiRecurringHourly {
}

export interface GetExternalDynamicListListDataTypeImsiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of the month for monthly IMSI updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListListDataTypeImsiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListListDataTypeIp {
    /**
     * Authentication settings for Custom IP type
     */
    auth: outputs.GetExternalDynamicListListDataTypeIpAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * IP Exception List for Custom IP type
     */
    exceptionLists: string[];
    /**
     * Update Schedule for Custom IP type
     */
    recurring: outputs.GetExternalDynamicListListDataTypeIpRecurring;
    /**
     * External URL for Custom IP type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeIpAuth {
    /**
     * Password for Custom IP authentication
     */
    password: string;
    /**
     * Username for Custom IP authentication
     */
    username: string;
}

export interface GetExternalDynamicListListDataTypeIpRecurring {
    /**
     * Daily settings for IP recurring
     */
    daily: outputs.GetExternalDynamicListListDataTypeIpRecurringDaily;
    /**
     * Five minute settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListListDataTypeIpRecurringFiveMinute;
    /**
     * Hourly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListListDataTypeIpRecurringHourly;
    /**
     * Monthly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListListDataTypeIpRecurringMonthly;
    /**
     * Weekly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListListDataTypeIpRecurringWeekly;
}

export interface GetExternalDynamicListListDataTypeIpRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IP
     */
    at: string;
}

export interface GetExternalDynamicListListDataTypeIpRecurringFiveMinute {
}

export interface GetExternalDynamicListListDataTypeIpRecurringHourly {
}

export interface GetExternalDynamicListListDataTypeIpRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day setting for monthly IP updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListListDataTypeIpRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListListDataTypePredefinedIp {
    /**
     * Description
     */
    description: string;
    /**
     * IP Exception List for Predefined IP type
     */
    exceptionLists: string[];
    /**
     * URL source for Predefined IP type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypePredefinedUrl {
    /**
     * Description
     */
    description: string;
    /**
     * URL Exception List for Predefined URL type
     */
    exceptionLists: string[];
    /**
     * URL source for Predefined URL type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeUrl {
    /**
     * Authentication settings for Custom URL type
     */
    auth: outputs.GetExternalDynamicListListDataTypeUrlAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * URL Exception List for Custom URL type
     */
    exceptionLists: string[];
    /**
     * Update Schedule for Custom URL type
     */
    recurring: outputs.GetExternalDynamicListListDataTypeUrlRecurring;
    /**
     * External URL for Custom URL type
     */
    url: string;
}

export interface GetExternalDynamicListListDataTypeUrlAuth {
    /**
     * Password for Custom URL authentication
     */
    password: string;
    /**
     * Username for Custom URL authentication
     */
    username: string;
}

export interface GetExternalDynamicListListDataTypeUrlRecurring {
    /**
     * Daily settings for URL recurring
     */
    daily: outputs.GetExternalDynamicListListDataTypeUrlRecurringDaily;
    /**
     * Five minute settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListListDataTypeUrlRecurringFiveMinute;
    /**
     * Hourly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListListDataTypeUrlRecurringHourly;
    /**
     * Monthly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListListDataTypeUrlRecurringMonthly;
    /**
     * Weekly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListListDataTypeUrlRecurringWeekly;
}

export interface GetExternalDynamicListListDataTypeUrlRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for URL
     */
    at: string;
}

export interface GetExternalDynamicListListDataTypeUrlRecurringFiveMinute {
}

export interface GetExternalDynamicListListDataTypeUrlRecurringHourly {
}

export interface GetExternalDynamicListListDataTypeUrlRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day setting for monthly URL updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListListDataTypeUrlRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListType {
    /**
     * Domain settings for Custom Domain type
     */
    domain: outputs.GetExternalDynamicListTypeDomain;
    /**
     * IMEI Configuration settings
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imei: outputs.GetExternalDynamicListTypeImei;
    /**
     * IMSI Config for Custom IMSI type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    imsi: outputs.GetExternalDynamicListTypeImsi;
    /**
     * IP settings for Custom IP type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    ip: outputs.GetExternalDynamicListTypeIp;
    /**
     * Predefined IP settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedIp: outputs.GetExternalDynamicListTypePredefinedIp;
    /**
     * Predefined URL settings for EDL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    predefinedUrl: outputs.GetExternalDynamicListTypePredefinedUrl;
    /**
     * URL settings for Custom URL type
     *
     * > ℹ️ **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefinedIp`, `predefinedUrl`, and `url`.
     */
    url: outputs.GetExternalDynamicListTypeUrl;
}

export interface GetExternalDynamicListTypeDomain {
    /**
     * Authentication settings for Custom Domain type
     */
    auth: outputs.GetExternalDynamicListTypeDomainAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * Domain Exception List for Custom Domain type
     */
    exceptionLists: string[];
    /**
     * Enable/Disable expand domain
     */
    expandDomain: boolean;
    /**
     * Update Schedule for Custom Domain type
     */
    recurring: outputs.GetExternalDynamicListTypeDomainRecurring;
    /**
     * External URL for Custom Domain type
     */
    url: string;
}

export interface GetExternalDynamicListTypeDomainAuth {
    /**
     * Password for Custom Domain authentication
     */
    password: string;
    /**
     * Username for Custom Domain authentication
     */
    username: string;
}

export interface GetExternalDynamicListTypeDomainRecurring {
    /**
     * Daily settings for Domain recurring
     */
    daily: outputs.GetExternalDynamicListTypeDomainRecurringDaily;
    /**
     * Five minute settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListTypeDomainRecurringFiveMinute;
    /**
     * Hourly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListTypeDomainRecurringHourly;
    /**
     * Monthly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListTypeDomainRecurringMonthly;
    /**
     * Weekly settings for Domain recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListTypeDomainRecurringWeekly;
}

export interface GetExternalDynamicListTypeDomainRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for Domain
     */
    at: string;
}

export interface GetExternalDynamicListTypeDomainRecurringFiveMinute {
}

export interface GetExternalDynamicListTypeDomainRecurringHourly {
}

export interface GetExternalDynamicListTypeDomainRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for domain
     */
    at: string;
    /**
     * Day setting for monthly Domain updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListTypeDomainRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for Domain
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListTypeImei {
    /**
     * IMEI Auth Cnfig for Custom IMEI type
     */
    auth: outputs.GetExternalDynamicListTypeImeiAuth;
    /**
     * IMEI Certificate Profile for Custom IMEI type
     */
    certificateProfile: string;
    /**
     * IMEI Description for Custom IMEI type
     */
    description: string;
    /**
     * IMEI Exception List for Custom IMEI type
     */
    exceptionLists: string[];
    /**
     * Recurring interval for IMEI updates
     */
    recurring: outputs.GetExternalDynamicListTypeImeiRecurring;
    /**
     * IMEI URL for Custom IMEI type
     */
    url: string;
}

export interface GetExternalDynamicListTypeImeiAuth {
    /**
     * IMEI Auth Password for Custom IMEI type
     */
    password: string;
    /**
     * IMEI Auth username for Custom IMEI type
     */
    username: string;
}

export interface GetExternalDynamicListTypeImeiRecurring {
    /**
     * Daily interval settings for IMEI updates
     */
    daily: outputs.GetExternalDynamicListTypeImeiRecurringDaily;
    /**
     * Five-minute interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListTypeImeiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListTypeImeiRecurringHourly;
    /**
     * Monthly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListTypeImeiRecurringMonthly;
    /**
     * Weekly interval settings for IMEI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListTypeImeiRecurringWeekly;
}

export interface GetExternalDynamicListTypeImeiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMEI
     */
    at: string;
}

export interface GetExternalDynamicListTypeImeiRecurringFiveMinute {
}

export interface GetExternalDynamicListTypeImeiRecurringHourly {
}

export interface GetExternalDynamicListTypeImeiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of month for IMEI updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListTypeImeiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMEI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListTypeImsi {
    /**
     * IMSI Auth Config for Custom IMSI type
     */
    auth: outputs.GetExternalDynamicListTypeImsiAuth;
    /**
     * IMSI Certificate Profile for Custom IMSI type
     */
    certificateProfile: string;
    /**
     * IMSI Description for Custom IMSI type
     */
    description: string;
    /**
     * IMSI Exception List for Custom IMSI type
     */
    exceptionLists: string[];
    /**
     * IMSI Recuring Config for Custom IMSI type
     */
    recurring: outputs.GetExternalDynamicListTypeImsiRecurring;
    /**
     * IMSI URL for Custom IMSI type
     */
    url: string;
}

export interface GetExternalDynamicListTypeImsiAuth {
    /**
     * IMSI Auth Password for Custom IMSI type
     */
    password: string;
    /**
     * IMSI Auth Username for Custom IMSI type
     */
    username: string;
}

export interface GetExternalDynamicListTypeImsiRecurring {
    /**
     * Daily interval settings for IMSI updates
     */
    daily: outputs.GetExternalDynamicListTypeImsiRecurringDaily;
    /**
     * Five-minute interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListTypeImsiRecurringFiveMinute;
    /**
     * Hourly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListTypeImsiRecurringHourly;
    /**
     * Monthly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListTypeImsiRecurringMonthly;
    /**
     * Weekly interval settings for IMSI updates
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListTypeImsiRecurringWeekly;
}

export interface GetExternalDynamicListTypeImsiRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IMSI
     */
    at: string;
}

export interface GetExternalDynamicListTypeImsiRecurringFiveMinute {
}

export interface GetExternalDynamicListTypeImsiRecurringHourly {
}

export interface GetExternalDynamicListTypeImsiRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of the month for monthly IMSI updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListTypeImsiRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IMSI
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListTypeIp {
    /**
     * Authentication settings for Custom IP type
     */
    auth: outputs.GetExternalDynamicListTypeIpAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * IP Exception List for Custom IP type
     */
    exceptionLists: string[];
    /**
     * Update Schedule for Custom IP type
     */
    recurring: outputs.GetExternalDynamicListTypeIpRecurring;
    /**
     * External URL for Custom IP type
     */
    url: string;
}

export interface GetExternalDynamicListTypeIpAuth {
    /**
     * Password for Custom IP authentication
     */
    password: string;
    /**
     * Username for Custom IP authentication
     */
    username: string;
}

export interface GetExternalDynamicListTypeIpRecurring {
    /**
     * Daily settings for IP recurring
     */
    daily: outputs.GetExternalDynamicListTypeIpRecurringDaily;
    /**
     * Five minute settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListTypeIpRecurringFiveMinute;
    /**
     * Hourly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListTypeIpRecurringHourly;
    /**
     * Monthly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListTypeIpRecurringMonthly;
    /**
     * Weekly settings for IP recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListTypeIpRecurringWeekly;
}

export interface GetExternalDynamicListTypeIpRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for IP
     */
    at: string;
}

export interface GetExternalDynamicListTypeIpRecurringFiveMinute {
}

export interface GetExternalDynamicListTypeIpRecurringHourly {
}

export interface GetExternalDynamicListTypeIpRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day setting for monthly IP updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListTypeIpRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for IP
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetExternalDynamicListTypePredefinedIp {
    /**
     * Description
     */
    description: string;
    /**
     * IP Exception List for Predefined IP type
     */
    exceptionLists: string[];
    /**
     * URL source for Predefined IP type
     */
    url: string;
}

export interface GetExternalDynamicListTypePredefinedUrl {
    /**
     * Description
     */
    description: string;
    /**
     * URL Exception List for Predefined URL type
     */
    exceptionLists: string[];
    /**
     * URL source for Predefined URL type
     */
    url: string;
}

export interface GetExternalDynamicListTypeUrl {
    /**
     * Authentication settings for Custom URL type
     */
    auth: outputs.GetExternalDynamicListTypeUrlAuth;
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
    /**
     * Description
     */
    description: string;
    /**
     * URL Exception List for Custom URL type
     */
    exceptionLists: string[];
    /**
     * Update Schedule for Custom URL type
     */
    recurring: outputs.GetExternalDynamicListTypeUrlRecurring;
    /**
     * External URL for Custom URL type
     */
    url: string;
}

export interface GetExternalDynamicListTypeUrlAuth {
    /**
     * Password for Custom URL authentication
     */
    password: string;
    /**
     * Username for Custom URL authentication
     */
    username: string;
}

export interface GetExternalDynamicListTypeUrlRecurring {
    /**
     * Daily settings for URL recurring
     */
    daily: outputs.GetExternalDynamicListTypeUrlRecurringDaily;
    /**
     * Five minute settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    fiveMinute: outputs.GetExternalDynamicListTypeUrlRecurringFiveMinute;
    /**
     * Hourly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    hourly: outputs.GetExternalDynamicListTypeUrlRecurringHourly;
    /**
     * Monthly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    monthly: outputs.GetExternalDynamicListTypeUrlRecurringMonthly;
    /**
     * Weekly settings for URL recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `fiveMinute`, `hourly`, `monthly`, and `weekly`.
     */
    weekly: outputs.GetExternalDynamicListTypeUrlRecurringWeekly;
}

export interface GetExternalDynamicListTypeUrlRecurringDaily {
    /**
     * Daily Time specification hh (e.g. 20) for URL
     */
    at: string;
}

export interface GetExternalDynamicListTypeUrlRecurringFiveMinute {
}

export interface GetExternalDynamicListTypeUrlRecurringHourly {
}

export interface GetExternalDynamicListTypeUrlRecurringMonthly {
    /**
     * Monthly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day setting for monthly URL updates
     */
    dayOfMonth: number;
}

export interface GetExternalDynamicListTypeUrlRecurringWeekly {
    /**
     * Weekly Time specification hh (e.g. 20) for URL
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetFileBlockingProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the file blocking profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * A list of file blocking rules
     */
    rules: outputs.GetFileBlockingProfileListDataRule[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetFileBlockingProfileListDataRule {
    /**
     * The action to take when the rule match criteria is met
     */
    action: string;
    /**
     * The application transferring the files (App-ID naming)
     */
    applications: string[];
    /**
     * The direction of the file transfer
     */
    direction: string;
    /**
     * The file type
     */
    fileTypes: string[];
    /**
     * The name of the file blocking rule
     */
    name: string;
}

export interface GetFileBlockingProfileRule {
    /**
     * The action to take when the rule match criteria is met
     */
    action: string;
    /**
     * The application transferring the files (App-ID naming)
     */
    applications: string[];
    /**
     * The direction of the file transfer
     */
    direction: string;
    /**
     * The file type
     */
    fileTypes: string[];
    /**
     * The name of the file blocking rule
     */
    name: string;
}

export interface GetFolderListData {
    /**
     * The description of the folder
     */
    description: string;
    /**
     * The UUID of the folder
     */
    id: string;
    /**
     * Labels assigned to the folder
     */
    labels: string[];
    /**
     * The name of the folder
     */
    name: string;
    /**
     * The parent folder
     */
    parent: string;
    /**
     * Snippets associated with the folder
     */
    snippets: string[];
    tfid: string;
}

export interface GetGeneralSettingGeneral {
    /**
     * Force admins to acknowledge login banner
     */
    ackLoginBanner: boolean;
    /**
     * DNS domain
     */
    domain: string;
    /**
     * Geographic coordinates
     */
    geoLocation: outputs.GetGeneralSettingGeneralGeoLocation;
    /**
     * Locale
     */
    locale: string;
    /**
     * Logon banner
     */
    loginBanner: string;
    /**
     * Setting
     */
    setting: outputs.GetGeneralSettingGeneralSetting;
    /**
     * SSL/TLS service profile
     */
    sslTlsServiceProfile: string;
    /**
     * Timezone
     */
    timezone: string;
}

export interface GetGeneralSettingGeneralGeoLocation {
    /**
     * Latitude
     */
    latitude: string;
    /**
     * Longitude
     */
    longitude: string;
}

export interface GetGeneralSettingGeneralSetting {
    /**
     * Use hypervisor assigned MAC addresses
     */
    autoMacDetect: boolean;
    /**
     * Fail open
     */
    failOpen: boolean;
    /**
     * Management
     */
    management: outputs.GetGeneralSettingGeneralSettingManagement;
    /**
     * Tunnel acceleration
     */
    tunnelAcceleration: boolean;
}

export interface GetGeneralSettingGeneralSettingManagement {
    /**
     * Automatically acquire commit lock
     */
    autoAcquireCommitLock: boolean;
    /**
     * Certificate expiration check
     */
    enableCertificateExpirationCheck: boolean;
}

export interface GetGeneralSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * General
     */
    general: outputs.GetGeneralSettingListDataGeneral;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetGeneralSettingListDataGeneral {
    /**
     * Force admins to acknowledge login banner
     */
    ackLoginBanner: boolean;
    /**
     * DNS domain
     */
    domain: string;
    /**
     * Geographic coordinates
     */
    geoLocation: outputs.GetGeneralSettingListDataGeneralGeoLocation;
    /**
     * Locale
     */
    locale: string;
    /**
     * Logon banner
     */
    loginBanner: string;
    /**
     * Setting
     */
    setting: outputs.GetGeneralSettingListDataGeneralSetting;
    /**
     * SSL/TLS service profile
     */
    sslTlsServiceProfile: string;
    /**
     * Timezone
     */
    timezone: string;
}

export interface GetGeneralSettingListDataGeneralGeoLocation {
    /**
     * Latitude
     */
    latitude: string;
    /**
     * Longitude
     */
    longitude: string;
}

export interface GetGeneralSettingListDataGeneralSetting {
    /**
     * Use hypervisor assigned MAC addresses
     */
    autoMacDetect: boolean;
    /**
     * Fail open
     */
    failOpen: boolean;
    /**
     * Management
     */
    management: outputs.GetGeneralSettingListDataGeneralSettingManagement;
    /**
     * Tunnel acceleration
     */
    tunnelAcceleration: boolean;
}

export interface GetGeneralSettingListDataGeneralSettingManagement {
    /**
     * Automatically acquire commit lock
     */
    autoAcquireCommitLock: boolean;
    /**
     * Certificate expiration check
     */
    enableCertificateExpirationCheck: boolean;
}

export interface GetHipObjectAntiMalware {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectAntiMalwareCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectAntiMalwareVendor[];
}

export interface GetHipObjectAntiMalwareCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last scan time
     */
    lastScanTime: outputs.GetHipObjectAntiMalwareCriteriaLastScanTime;
    /**
     * Product version
     */
    productVersion: outputs.GetHipObjectAntiMalwareCriteriaProductVersion;
    /**
     * real time protection
     */
    realTimeProtection: string;
    /**
     * Virdef version
     */
    virdefVersion: outputs.GetHipObjectAntiMalwareCriteriaVirdefVersion;
}

export interface GetHipObjectAntiMalwareCriteriaLastScanTime {
    /**
     * Not available
     */
    notAvailable: outputs.GetHipObjectAntiMalwareCriteriaLastScanTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectAntiMalwareCriteriaLastScanTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectAntiMalwareCriteriaLastScanTimeWithin;
}

export interface GetHipObjectAntiMalwareCriteriaLastScanTimeNotAvailable {
}

export interface GetHipObjectAntiMalwareCriteriaLastScanTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectAntiMalwareCriteriaLastScanTimeWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectAntiMalwareCriteriaProductVersion {
    /**
     * Contains
     */
    contains: string;
    /**
     * Greater equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterEqual: string;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterThan: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    isNot: string;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessEqual: string;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessThan: string;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectAntiMalwareCriteriaProductVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectAntiMalwareCriteriaProductVersionWithin;
}

export interface GetHipObjectAntiMalwareCriteriaProductVersionNotWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface GetHipObjectAntiMalwareCriteriaProductVersionWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface GetHipObjectAntiMalwareCriteriaVirdefVersion {
    /**
     * Not within
     */
    notWithin: outputs.GetHipObjectAntiMalwareCriteriaVirdefVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within: outputs.GetHipObjectAntiMalwareCriteriaVirdefVersionWithin;
}

export interface GetHipObjectAntiMalwareCriteriaVirdefVersionNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions: number;
}

export interface GetHipObjectAntiMalwareCriteriaVirdefVersionWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions: number;
}

export interface GetHipObjectAntiMalwareVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectCertificate {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectCertificateCriteria;
}

export interface GetHipObjectCertificateCriteria {
    /**
     * Certificate attributes
     */
    certificateAttributes: outputs.GetHipObjectCertificateCriteriaCertificateAttribute[];
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
}

export interface GetHipObjectCertificateCriteriaCertificateAttribute {
    /**
     * Attribute Name
     */
    name: string;
    /**
     * Key value
     */
    value: string;
}

export interface GetHipObjectCustomChecks {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectCustomChecksCriteria;
}

export interface GetHipObjectCustomChecksCriteria {
    /**
     * Plist
     */
    plists: outputs.GetHipObjectCustomChecksCriteriaPlist[];
    /**
     * Process list
     */
    processLists: outputs.GetHipObjectCustomChecksCriteriaProcessList[];
    /**
     * Registry key
     */
    registryKeys: outputs.GetHipObjectCustomChecksCriteriaRegistryKey[];
}

export interface GetHipObjectCustomChecksCriteriaPlist {
    /**
     * Key
     */
    keys: outputs.GetHipObjectCustomChecksCriteriaPlistKey[];
    /**
     * Preference list
     */
    name: string;
    /**
     * Plist does not exist
     */
    negate: boolean;
}

export interface GetHipObjectCustomChecksCriteriaPlistKey {
    /**
     * Key name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Key value
     */
    value: string;
}

export interface GetHipObjectCustomChecksCriteriaProcessList {
    /**
     * Process Name
     */
    name: string;
    /**
     * Running
     */
    running: boolean;
}

export interface GetHipObjectCustomChecksCriteriaRegistryKey {
    /**
     * Registry key default value data
     */
    defaultValueData: string;
    /**
     * Registry key
     */
    name: string;
    /**
     * Key does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value
     */
    registryValues: outputs.GetHipObjectCustomChecksCriteriaRegistryKeyRegistryValue[];
}

export interface GetHipObjectCustomChecksCriteriaRegistryKeyRegistryValue {
    /**
     * Registry value name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value data
     */
    valueData: string;
}

export interface GetHipObjectDataLossPrevention {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectDataLossPreventionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectDataLossPreventionVendor[];
}

export interface GetHipObjectDataLossPreventionCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectDataLossPreventionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products: string[];
}

export interface GetHipObjectDiskBackup {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectDiskBackupCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectDiskBackupVendor[];
}

export interface GetHipObjectDiskBackupCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last backup time
     */
    lastBackupTime: outputs.GetHipObjectDiskBackupCriteriaLastBackupTime;
}

export interface GetHipObjectDiskBackupCriteriaLastBackupTime {
    /**
     * Not available
     */
    notAvailable: outputs.GetHipObjectDiskBackupCriteriaLastBackupTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectDiskBackupCriteriaLastBackupTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectDiskBackupCriteriaLastBackupTimeWithin;
}

export interface GetHipObjectDiskBackupCriteriaLastBackupTimeNotAvailable {
}

export interface GetHipObjectDiskBackupCriteriaLastBackupTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectDiskBackupCriteriaLastBackupTimeWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectDiskBackupVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectDiskEncryption {
    /**
     * Encryption locations
     */
    criteria: outputs.GetHipObjectDiskEncryptionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectDiskEncryptionVendor[];
}

export interface GetHipObjectDiskEncryptionCriteria {
    /**
     * Encrypted locations
     */
    encryptedLocations: outputs.GetHipObjectDiskEncryptionCriteriaEncryptedLocation[];
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectDiskEncryptionCriteriaEncryptedLocation {
    /**
     * Encryption state
     */
    encryptionState: outputs.GetHipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionState;
    /**
     * Encryption location
     */
    name: string;
}

export interface GetHipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionState {
    /**
     * Is
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectDiskEncryptionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectFirewall {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectFirewallCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectFirewallVendor[];
}

export interface GetHipObjectFirewallCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectFirewallVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectHostInfo {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectHostInfoCriteria;
}

export interface GetHipObjectHostInfoCriteria {
    /**
     * Client version
     */
    clientVersion: outputs.GetHipObjectHostInfoCriteriaClientVersion;
    /**
     * Domain
     */
    domain: outputs.GetHipObjectHostInfoCriteriaDomain;
    /**
     * Host id
     */
    hostId: outputs.GetHipObjectHostInfoCriteriaHostId;
    /**
     * Host name
     */
    hostName: outputs.GetHipObjectHostInfoCriteriaHostName;
    /**
     * If device is managed
     */
    managed: boolean;
    /**
     * Os
     */
    os: outputs.GetHipObjectHostInfoCriteriaOs;
    /**
     * Serial number
     */
    serialNumber: outputs.GetHipObjectHostInfoCriteriaSerialNumber;
}

export interface GetHipObjectHostInfoCriteriaClientVersion {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectHostInfoCriteriaDomain {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectHostInfoCriteriaHostId {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectHostInfoCriteriaHostName {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectHostInfoCriteriaOs {
    /**
     * Contains
     */
    contains: outputs.GetHipObjectHostInfoCriteriaOsContains;
}

export interface GetHipObjectHostInfoCriteriaOsContains {
    /**
     * Apple
     */
    apple: string;
    /**
     * Google
     */
    google: string;
    /**
     * Linux
     */
    linux: string;
    /**
     * Microsoft
     */
    microsoft: string;
    /**
     * Other
     */
    other: string;
}

export interface GetHipObjectHostInfoCriteriaSerialNumber {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListData {
    /**
     * Anti malware
     */
    antiMalware: outputs.GetHipObjectListDataAntiMalware;
    /**
     * Certificate
     */
    certificate: outputs.GetHipObjectListDataCertificate;
    /**
     * Custom checks
     */
    customChecks: outputs.GetHipObjectListDataCustomChecks;
    /**
     * Data loss prevention
     */
    dataLossPrevention: outputs.GetHipObjectListDataDataLossPrevention;
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Disk backup
     */
    diskBackup: outputs.GetHipObjectListDataDiskBackup;
    /**
     * Disk encryption
     */
    diskEncryption: outputs.GetHipObjectListDataDiskEncryption;
    /**
     * Firewall
     */
    firewall: outputs.GetHipObjectListDataFirewall;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Host info
     */
    hostInfo: outputs.GetHipObjectListDataHostInfo;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Mobile device
     */
    mobileDevice: outputs.GetHipObjectListDataMobileDevice;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Network info
     */
    networkInfo: outputs.GetHipObjectListDataNetworkInfo;
    /**
     * Patch management
     */
    patchManagement: outputs.GetHipObjectListDataPatchManagement;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetHipObjectListDataAntiMalware {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataAntiMalwareCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataAntiMalwareVendor[];
}

export interface GetHipObjectListDataAntiMalwareCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last scan time
     */
    lastScanTime: outputs.GetHipObjectListDataAntiMalwareCriteriaLastScanTime;
    /**
     * Product version
     */
    productVersion: outputs.GetHipObjectListDataAntiMalwareCriteriaProductVersion;
    /**
     * real time protection
     */
    realTimeProtection: string;
    /**
     * Virdef version
     */
    virdefVersion: outputs.GetHipObjectListDataAntiMalwareCriteriaVirdefVersion;
}

export interface GetHipObjectListDataAntiMalwareCriteriaLastScanTime {
    /**
     * Not available
     */
    notAvailable: outputs.GetHipObjectListDataAntiMalwareCriteriaLastScanTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectListDataAntiMalwareCriteriaLastScanTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectListDataAntiMalwareCriteriaLastScanTimeWithin;
}

export interface GetHipObjectListDataAntiMalwareCriteriaLastScanTimeNotAvailable {
}

export interface GetHipObjectListDataAntiMalwareCriteriaLastScanTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectListDataAntiMalwareCriteriaLastScanTimeWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectListDataAntiMalwareCriteriaProductVersion {
    /**
     * Contains
     */
    contains: string;
    /**
     * Greater equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterEqual: string;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterThan: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    isNot: string;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessEqual: string;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessThan: string;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectListDataAntiMalwareCriteriaProductVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectListDataAntiMalwareCriteriaProductVersionWithin;
}

export interface GetHipObjectListDataAntiMalwareCriteriaProductVersionNotWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface GetHipObjectListDataAntiMalwareCriteriaProductVersionWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface GetHipObjectListDataAntiMalwareCriteriaVirdefVersion {
    /**
     * Not within
     */
    notWithin: outputs.GetHipObjectListDataAntiMalwareCriteriaVirdefVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within: outputs.GetHipObjectListDataAntiMalwareCriteriaVirdefVersionWithin;
}

export interface GetHipObjectListDataAntiMalwareCriteriaVirdefVersionNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions: number;
}

export interface GetHipObjectListDataAntiMalwareCriteriaVirdefVersionWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions: number;
}

export interface GetHipObjectListDataAntiMalwareVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectListDataCertificate {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataCertificateCriteria;
}

export interface GetHipObjectListDataCertificateCriteria {
    /**
     * Certificate attributes
     */
    certificateAttributes: outputs.GetHipObjectListDataCertificateCriteriaCertificateAttribute[];
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile: string;
}

export interface GetHipObjectListDataCertificateCriteriaCertificateAttribute {
    /**
     * Attribute Name
     */
    name: string;
    /**
     * Key value
     */
    value: string;
}

export interface GetHipObjectListDataCustomChecks {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataCustomChecksCriteria;
}

export interface GetHipObjectListDataCustomChecksCriteria {
    /**
     * Plist
     */
    plists: outputs.GetHipObjectListDataCustomChecksCriteriaPlist[];
    /**
     * Process list
     */
    processLists: outputs.GetHipObjectListDataCustomChecksCriteriaProcessList[];
    /**
     * Registry key
     */
    registryKeys: outputs.GetHipObjectListDataCustomChecksCriteriaRegistryKey[];
}

export interface GetHipObjectListDataCustomChecksCriteriaPlist {
    /**
     * Key
     */
    keys: outputs.GetHipObjectListDataCustomChecksCriteriaPlistKey[];
    /**
     * Preference list
     */
    name: string;
    /**
     * Plist does not exist
     */
    negate: boolean;
}

export interface GetHipObjectListDataCustomChecksCriteriaPlistKey {
    /**
     * Key name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Key value
     */
    value: string;
}

export interface GetHipObjectListDataCustomChecksCriteriaProcessList {
    /**
     * Process Name
     */
    name: string;
    /**
     * Running
     */
    running: boolean;
}

export interface GetHipObjectListDataCustomChecksCriteriaRegistryKey {
    /**
     * Registry key default value data
     */
    defaultValueData: string;
    /**
     * Registry key
     */
    name: string;
    /**
     * Key does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value
     */
    registryValues: outputs.GetHipObjectListDataCustomChecksCriteriaRegistryKeyRegistryValue[];
}

export interface GetHipObjectListDataCustomChecksCriteriaRegistryKeyRegistryValue {
    /**
     * Registry value name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value data
     */
    valueData: string;
}

export interface GetHipObjectListDataDataLossPrevention {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataDataLossPreventionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataDataLossPreventionVendor[];
}

export interface GetHipObjectListDataDataLossPreventionCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectListDataDataLossPreventionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products: string[];
}

export interface GetHipObjectListDataDiskBackup {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataDiskBackupCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataDiskBackupVendor[];
}

export interface GetHipObjectListDataDiskBackupCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last backup time
     */
    lastBackupTime: outputs.GetHipObjectListDataDiskBackupCriteriaLastBackupTime;
}

export interface GetHipObjectListDataDiskBackupCriteriaLastBackupTime {
    /**
     * Not available
     */
    notAvailable: outputs.GetHipObjectListDataDiskBackupCriteriaLastBackupTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin: outputs.GetHipObjectListDataDiskBackupCriteriaLastBackupTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within: outputs.GetHipObjectListDataDiskBackupCriteriaLastBackupTimeWithin;
}

export interface GetHipObjectListDataDiskBackupCriteriaLastBackupTimeNotAvailable {
}

export interface GetHipObjectListDataDiskBackupCriteriaLastBackupTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectListDataDiskBackupCriteriaLastBackupTimeWithin {
    /**
     * specify time in days
     */
    days: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours: number;
}

export interface GetHipObjectListDataDiskBackupVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectListDataDiskEncryption {
    /**
     * Encryption locations
     */
    criteria: outputs.GetHipObjectListDataDiskEncryptionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataDiskEncryptionVendor[];
}

export interface GetHipObjectListDataDiskEncryptionCriteria {
    /**
     * Encrypted locations
     */
    encryptedLocations: outputs.GetHipObjectListDataDiskEncryptionCriteriaEncryptedLocation[];
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectListDataDiskEncryptionCriteriaEncryptedLocation {
    /**
     * Encryption state
     */
    encryptionState: outputs.GetHipObjectListDataDiskEncryptionCriteriaEncryptedLocationEncryptionState;
    /**
     * Encryption location
     */
    name: string;
}

export interface GetHipObjectListDataDiskEncryptionCriteriaEncryptedLocationEncryptionState {
    /**
     * Is
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataDiskEncryptionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectListDataFirewall {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataFirewallCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataFirewallVendor[];
}

export interface GetHipObjectListDataFirewallCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface GetHipObjectListDataFirewallVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products: string[];
}

export interface GetHipObjectListDataHostInfo {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataHostInfoCriteria;
}

export interface GetHipObjectListDataHostInfoCriteria {
    /**
     * Client version
     */
    clientVersion: outputs.GetHipObjectListDataHostInfoCriteriaClientVersion;
    /**
     * Domain
     */
    domain: outputs.GetHipObjectListDataHostInfoCriteriaDomain;
    /**
     * Host id
     */
    hostId: outputs.GetHipObjectListDataHostInfoCriteriaHostId;
    /**
     * Host name
     */
    hostName: outputs.GetHipObjectListDataHostInfoCriteriaHostName;
    /**
     * If device is managed
     */
    managed: boolean;
    /**
     * Os
     */
    os: outputs.GetHipObjectListDataHostInfoCriteriaOs;
    /**
     * Serial number
     */
    serialNumber: outputs.GetHipObjectListDataHostInfoCriteriaSerialNumber;
}

export interface GetHipObjectListDataHostInfoCriteriaClientVersion {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataHostInfoCriteriaDomain {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataHostInfoCriteriaHostId {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataHostInfoCriteriaHostName {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataHostInfoCriteriaOs {
    /**
     * Contains
     */
    contains: outputs.GetHipObjectListDataHostInfoCriteriaOsContains;
}

export interface GetHipObjectListDataHostInfoCriteriaOsContains {
    /**
     * Apple
     */
    apple: string;
    /**
     * Google
     */
    google: string;
    /**
     * Linux
     */
    linux: string;
    /**
     * Microsoft
     */
    microsoft: string;
    /**
     * Other
     */
    other: string;
}

export interface GetHipObjectListDataHostInfoCriteriaSerialNumber {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataMobileDevice {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataMobileDeviceCriteria;
}

export interface GetHipObjectListDataMobileDeviceCriteria {
    /**
     * Applications
     */
    applications: outputs.GetHipObjectListDataMobileDeviceCriteriaApplications;
    /**
     * If device's disk is encrypted
     */
    diskEncrypted: boolean;
    /**
     * Imei
     */
    imei: outputs.GetHipObjectListDataMobileDeviceCriteriaImei;
    /**
     * If device is by rooted/jailbroken
     */
    jailbroken: boolean;
    /**
     * Last checkin time
     */
    lastCheckinTime: outputs.GetHipObjectListDataMobileDeviceCriteriaLastCheckinTime;
    /**
     * Model
     */
    model: outputs.GetHipObjectListDataMobileDeviceCriteriaModel;
    /**
     * If device's passcode is present
     */
    passcodeSet: boolean;
    /**
     * Phone number
     */
    phoneNumber: outputs.GetHipObjectListDataMobileDeviceCriteriaPhoneNumber;
    /**
     * Tag
     */
    tag: outputs.GetHipObjectListDataMobileDeviceCriteriaTag;
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplications {
    /**
     * Has malware
     */
    hasMalware: outputs.GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalware;
    /**
     * Has apps that are not managed
     */
    hasUnmanagedApp: boolean;
    /**
     * Includes
     */
    includes: outputs.GetHipObjectListDataMobileDeviceCriteriaApplicationsInclude[];
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalware {
    /**
     * No
     */
    no: outputs.GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `no` and `yes`.
     */
    yes: outputs.GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareYes;
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareNo {
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareYes {
    /**
     * Excludes
     */
    excludes: outputs.GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareYesExclude[];
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplicationsHasMalwareYesExclude {
    /**
     * application hash
     */
    hash: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package: string;
}

export interface GetHipObjectListDataMobileDeviceCriteriaApplicationsInclude {
    /**
     * application hash
     */
    hash: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package: string;
}

export interface GetHipObjectListDataMobileDeviceCriteriaImei {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataMobileDeviceCriteriaLastCheckinTime {
    /**
     * Not within
     */
    notWithin: outputs.GetHipObjectListDataMobileDeviceCriteriaLastCheckinTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within: outputs.GetHipObjectListDataMobileDeviceCriteriaLastCheckinTimeWithin;
}

export interface GetHipObjectListDataMobileDeviceCriteriaLastCheckinTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface GetHipObjectListDataMobileDeviceCriteriaLastCheckinTimeWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface GetHipObjectListDataMobileDeviceCriteriaModel {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataMobileDeviceCriteriaPhoneNumber {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataMobileDeviceCriteriaTag {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectListDataNetworkInfo {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataNetworkInfoCriteria;
}

export interface GetHipObjectListDataNetworkInfoCriteria {
    /**
     * Network
     */
    network: outputs.GetHipObjectListDataNetworkInfoCriteriaNetwork;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetwork {
    /**
     * Is
     */
    is: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIs;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsNot;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIs {
    /**
     * Mobile
     */
    mobile: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    unknown: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    wifi: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsWifi;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsMobile {
    /**
     * Carrier
     */
    carrier: string;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsNot {
    /**
     * Ethernet
     */
    ethernet: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotEthernet;
    /**
     * Mobile
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    mobile: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    unknown: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    wifi: outputs.GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotWifi;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotEthernet {
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotMobile {
    /**
     * Carrier
     */
    carrier: string;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotUnknown {
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsNotWifi {
    /**
     * SSID
     */
    ssid: string;
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsUnknown {
}

export interface GetHipObjectListDataNetworkInfoCriteriaNetworkIsWifi {
    /**
     * SSID
     */
    ssid: string;
}

export interface GetHipObjectListDataPatchManagement {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectListDataPatchManagementCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectListDataPatchManagementVendor[];
}

export interface GetHipObjectListDataPatchManagementCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Missing patches
     */
    missingPatches: outputs.GetHipObjectListDataPatchManagementCriteriaMissingPatches;
}

export interface GetHipObjectListDataPatchManagementCriteriaMissingPatches {
    /**
     * Check
     */
    check: string;
    /**
     * Patches
     */
    patches: string[];
    /**
     * Severity
     */
    severity: outputs.GetHipObjectListDataPatchManagementCriteriaMissingPatchesSeverity;
}

export interface GetHipObjectListDataPatchManagementCriteriaMissingPatchesSeverity {
    /**
     * Greater equal
     */
    greaterEqual: number;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    greaterThan: number;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    is: number;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    isNot: number;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessEqual: number;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessThan: number;
}

export interface GetHipObjectListDataPatchManagementVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products: string[];
}

export interface GetHipObjectMobileDevice {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectMobileDeviceCriteria;
}

export interface GetHipObjectMobileDeviceCriteria {
    /**
     * Applications
     */
    applications: outputs.GetHipObjectMobileDeviceCriteriaApplications;
    /**
     * If device's disk is encrypted
     */
    diskEncrypted: boolean;
    /**
     * Imei
     */
    imei: outputs.GetHipObjectMobileDeviceCriteriaImei;
    /**
     * If device is by rooted/jailbroken
     */
    jailbroken: boolean;
    /**
     * Last checkin time
     */
    lastCheckinTime: outputs.GetHipObjectMobileDeviceCriteriaLastCheckinTime;
    /**
     * Model
     */
    model: outputs.GetHipObjectMobileDeviceCriteriaModel;
    /**
     * If device's passcode is present
     */
    passcodeSet: boolean;
    /**
     * Phone number
     */
    phoneNumber: outputs.GetHipObjectMobileDeviceCriteriaPhoneNumber;
    /**
     * Tag
     */
    tag: outputs.GetHipObjectMobileDeviceCriteriaTag;
}

export interface GetHipObjectMobileDeviceCriteriaApplications {
    /**
     * Has malware
     */
    hasMalware: outputs.GetHipObjectMobileDeviceCriteriaApplicationsHasMalware;
    /**
     * Has apps that are not managed
     */
    hasUnmanagedApp: boolean;
    /**
     * Includes
     */
    includes: outputs.GetHipObjectMobileDeviceCriteriaApplicationsInclude[];
}

export interface GetHipObjectMobileDeviceCriteriaApplicationsHasMalware {
    /**
     * No
     */
    no: outputs.GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `no` and `yes`.
     */
    yes: outputs.GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareYes;
}

export interface GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareNo {
}

export interface GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareYes {
    /**
     * Excludes
     */
    excludes: outputs.GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExclude[];
}

export interface GetHipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExclude {
    /**
     * application hash
     */
    hash: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package: string;
}

export interface GetHipObjectMobileDeviceCriteriaApplicationsInclude {
    /**
     * application hash
     */
    hash: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package: string;
}

export interface GetHipObjectMobileDeviceCriteriaImei {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectMobileDeviceCriteriaLastCheckinTime {
    /**
     * Not within
     */
    notWithin: outputs.GetHipObjectMobileDeviceCriteriaLastCheckinTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within: outputs.GetHipObjectMobileDeviceCriteriaLastCheckinTimeWithin;
}

export interface GetHipObjectMobileDeviceCriteriaLastCheckinTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface GetHipObjectMobileDeviceCriteriaLastCheckinTimeWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface GetHipObjectMobileDeviceCriteriaModel {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectMobileDeviceCriteriaPhoneNumber {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectMobileDeviceCriteriaTag {
    /**
     * Contains
     */
    contains: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot: string;
}

export interface GetHipObjectNetworkInfo {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectNetworkInfoCriteria;
}

export interface GetHipObjectNetworkInfoCriteria {
    /**
     * Network
     */
    network: outputs.GetHipObjectNetworkInfoCriteriaNetwork;
}

export interface GetHipObjectNetworkInfoCriteriaNetwork {
    /**
     * Is
     */
    is: outputs.GetHipObjectNetworkInfoCriteriaNetworkIs;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsNot;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIs {
    /**
     * Mobile
     */
    mobile: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    unknown: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    wifi: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsWifi;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsMobile {
    /**
     * Carrier
     */
    carrier: string;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsNot {
    /**
     * Ethernet
     */
    ethernet: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsNotEthernet;
    /**
     * Mobile
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    mobile: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsNotMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    unknown: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsNotUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    wifi: outputs.GetHipObjectNetworkInfoCriteriaNetworkIsNotWifi;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsNotEthernet {
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsNotMobile {
    /**
     * Carrier
     */
    carrier: string;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsNotUnknown {
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsNotWifi {
    /**
     * SSID
     */
    ssid: string;
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsUnknown {
}

export interface GetHipObjectNetworkInfoCriteriaNetworkIsWifi {
    /**
     * SSID
     */
    ssid: string;
}

export interface GetHipObjectPatchManagement {
    /**
     * Criteria
     */
    criteria: outputs.GetHipObjectPatchManagementCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors: outputs.GetHipObjectPatchManagementVendor[];
}

export interface GetHipObjectPatchManagementCriteria {
    /**
     * is enabled
     */
    isEnabled: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Missing patches
     */
    missingPatches: outputs.GetHipObjectPatchManagementCriteriaMissingPatches;
}

export interface GetHipObjectPatchManagementCriteriaMissingPatches {
    /**
     * Check
     */
    check: string;
    /**
     * Patches
     */
    patches: string[];
    /**
     * Severity
     */
    severity: outputs.GetHipObjectPatchManagementCriteriaMissingPatchesSeverity;
}

export interface GetHipObjectPatchManagementCriteriaMissingPatchesSeverity {
    /**
     * Greater equal
     */
    greaterEqual: number;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    greaterThan: number;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    is: number;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    isNot: number;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessEqual: number;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessThan: number;
}

export interface GetHipObjectPatchManagementVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products: string[];
}

export interface GetHipProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Match
     */
    match: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetHttpHeaderProfileHttpHeaderInsertion {
    /**
     * The name of the HTTP header insertion rule
     */
    name: string;
    /**
     * A list of HTTP header insertion definitions
     */
    types: outputs.GetHttpHeaderProfileHttpHeaderInsertionType[];
}

export interface GetHttpHeaderProfileHttpHeaderInsertionType {
    /**
     * A list of DNS domains
     */
    domains: string[];
    /**
     * Headers
     */
    headers: outputs.GetHttpHeaderProfileHttpHeaderInsertionTypeHeader[];
    /**
     * The HTTP header insertion type
     */
    name: string;
}

export interface GetHttpHeaderProfileHttpHeaderInsertionTypeHeader {
    /**
     * The HTTP header string
     */
    header: string;
    /**
     * Log the use of this HTTP header insertion?
     */
    log: boolean;
    /**
     * The name of the HTTP header
     */
    name: string;
    /**
     * The value associated with the HTTP header
     */
    value: string;
}

export interface GetHttpHeaderProfileListData {
    /**
     * The description of the HTTP header profile
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * A list of HTTP header profile rules
     */
    httpHeaderInsertions: outputs.GetHttpHeaderProfileListDataHttpHeaderInsertion[];
    /**
     * The UUID of the HTTP header profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetHttpHeaderProfileListDataHttpHeaderInsertion {
    /**
     * The name of the HTTP header insertion rule
     */
    name: string;
    /**
     * A list of HTTP header insertion definitions
     */
    types: outputs.GetHttpHeaderProfileListDataHttpHeaderInsertionType[];
}

export interface GetHttpHeaderProfileListDataHttpHeaderInsertionType {
    /**
     * A list of DNS domains
     */
    domains: string[];
    /**
     * Headers
     */
    headers: outputs.GetHttpHeaderProfileListDataHttpHeaderInsertionTypeHeader[];
    /**
     * The HTTP header insertion type
     */
    name: string;
}

export interface GetHttpHeaderProfileListDataHttpHeaderInsertionTypeHeader {
    /**
     * The HTTP header string
     */
    header: string;
    /**
     * Log the use of this HTTP header insertion?
     */
    log: boolean;
    /**
     * The name of the HTTP header
     */
    name: string;
    /**
     * The value associated with the HTTP header
     */
    value: string;
}

export interface GetHttpServerProfileFormat {
    /**
     * Auth
     */
    auth: outputs.GetHttpServerProfileFormatAuth;
    /**
     * Config
     */
    config: outputs.GetHttpServerProfileFormatConfig;
    /**
     * Correlation
     */
    correlation: outputs.GetHttpServerProfileFormatCorrelation;
    /**
     * Data
     */
    data: outputs.GetHttpServerProfileFormatData;
    /**
     * Decryption
     */
    decryption: outputs.GetHttpServerProfileFormatDecryption;
    /**
     * Globalprotect
     */
    globalprotect: outputs.GetHttpServerProfileFormatGlobalprotect;
    /**
     * Gtp
     */
    gtp: outputs.GetHttpServerProfileFormatGtp;
    /**
     * Hip match
     */
    hipMatch: outputs.GetHttpServerProfileFormatHipMatch;
    /**
     * Iptag
     */
    iptag: outputs.GetHttpServerProfileFormatIptag;
    /**
     * Sctp
     */
    sctp: outputs.GetHttpServerProfileFormatSctp;
    /**
     * System
     */
    system: outputs.GetHttpServerProfileFormatSystem;
    /**
     * Threat
     */
    threat: outputs.GetHttpServerProfileFormatThreat;
    /**
     * Traffic
     */
    traffic: outputs.GetHttpServerProfileFormatTraffic;
    /**
     * Tunnel
     */
    tunnel: outputs.GetHttpServerProfileFormatTunnel;
    /**
     * Url
     */
    url: outputs.GetHttpServerProfileFormatUrl;
    /**
     * Userid
     */
    userid: outputs.GetHttpServerProfileFormatUserid;
    /**
     * Wildfire
     */
    wildfire: outputs.GetHttpServerProfileFormatWildfire;
}

export interface GetHttpServerProfileFormatAuth {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatAuthHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatAuthParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatAuthHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatAuthParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatConfig {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatConfigHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatConfigParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatConfigHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatConfigParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatCorrelation {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatCorrelationHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatCorrelationParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatCorrelationHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatCorrelationParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatData {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatDataHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatDataParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatDataHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatDataParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatDecryption {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatDecryptionHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatDecryptionParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatDecryptionHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatDecryptionParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatGlobalprotect {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatGlobalprotectHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatGlobalprotectParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatGlobalprotectHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatGlobalprotectParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatGtp {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatGtpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatGtpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatGtpHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatGtpParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatHipMatch {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatHipMatchHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatHipMatchParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatHipMatchHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatHipMatchParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatIptag {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatIptagHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatIptagParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatIptagHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatIptagParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatSctp {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatSctpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatSctpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatSctpHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatSctpParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatSystem {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatSystemHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatSystemParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatSystemHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatSystemParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatThreat {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatThreatHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatThreatParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatThreatHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatThreatParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatTraffic {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatTrafficHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatTrafficParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatTrafficHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatTrafficParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatTunnel {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatTunnelHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatTunnelParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatTunnelHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatTunnelParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatUrl {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatUrlHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatUrlParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatUrlHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatUrlParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatUserid {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatUseridHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatUseridParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatUseridHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatUseridParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileFormatWildfire {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileFormatWildfireHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileFormatWildfireParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileFormatWildfireHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileFormatWildfireParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Format
     */
    format: outputs.GetHttpServerProfileListDataFormat;
    /**
     * The UUID of the HTTP server profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Server
     */
    servers: outputs.GetHttpServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Register tags on match
     */
    tagRegistration: boolean;
    tfid: string;
}

export interface GetHttpServerProfileListDataFormat {
    /**
     * Auth
     */
    auth: outputs.GetHttpServerProfileListDataFormatAuth;
    /**
     * Config
     */
    config: outputs.GetHttpServerProfileListDataFormatConfig;
    /**
     * Correlation
     */
    correlation: outputs.GetHttpServerProfileListDataFormatCorrelation;
    /**
     * Data
     */
    data: outputs.GetHttpServerProfileListDataFormatData;
    /**
     * Decryption
     */
    decryption: outputs.GetHttpServerProfileListDataFormatDecryption;
    /**
     * Globalprotect
     */
    globalprotect: outputs.GetHttpServerProfileListDataFormatGlobalprotect;
    /**
     * Gtp
     */
    gtp: outputs.GetHttpServerProfileListDataFormatGtp;
    /**
     * Hip match
     */
    hipMatch: outputs.GetHttpServerProfileListDataFormatHipMatch;
    /**
     * Iptag
     */
    iptag: outputs.GetHttpServerProfileListDataFormatIptag;
    /**
     * Sctp
     */
    sctp: outputs.GetHttpServerProfileListDataFormatSctp;
    /**
     * System
     */
    system: outputs.GetHttpServerProfileListDataFormatSystem;
    /**
     * Threat
     */
    threat: outputs.GetHttpServerProfileListDataFormatThreat;
    /**
     * Traffic
     */
    traffic: outputs.GetHttpServerProfileListDataFormatTraffic;
    /**
     * Tunnel
     */
    tunnel: outputs.GetHttpServerProfileListDataFormatTunnel;
    /**
     * Url
     */
    url: outputs.GetHttpServerProfileListDataFormatUrl;
    /**
     * Userid
     */
    userid: outputs.GetHttpServerProfileListDataFormatUserid;
    /**
     * Wildfire
     */
    wildfire: outputs.GetHttpServerProfileListDataFormatWildfire;
}

export interface GetHttpServerProfileListDataFormatAuth {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatAuthHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatAuthParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatAuthHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatAuthParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatConfig {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatConfigHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatConfigParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatConfigHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatConfigParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatCorrelation {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatCorrelationHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatCorrelationParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatCorrelationHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatCorrelationParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatData {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatDataHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatDataParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatDataHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatDataParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatDecryption {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatDecryptionHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatDecryptionParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatDecryptionHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatDecryptionParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatGlobalprotect {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatGlobalprotectHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatGlobalprotectParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatGlobalprotectHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatGlobalprotectParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatGtp {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatGtpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatGtpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatGtpHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatGtpParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatHipMatch {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatHipMatchHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatHipMatchParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatHipMatchHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatHipMatchParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatIptag {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatIptagHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatIptagParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatIptagHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatIptagParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatSctp {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatSctpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatSctpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatSctpHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatSctpParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatSystem {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatSystemHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatSystemParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatSystemHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatSystemParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatThreat {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatThreatHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatThreatParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatThreatHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatThreatParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatTraffic {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatTrafficHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatTrafficParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatTrafficHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatTrafficParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatTunnel {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatTunnelHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatTunnelParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatTunnelHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatTunnelParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatUrl {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatUrlHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatUrlParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatUrlHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatUrlParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatUserid {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatUseridHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatUseridParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatUseridHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatUseridParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatWildfire {
    /**
     * Headers
     */
    headers: outputs.GetHttpServerProfileListDataFormatWildfireHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params: outputs.GetHttpServerProfileListDataFormatWildfireParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat: string;
}

export interface GetHttpServerProfileListDataFormatWildfireHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface GetHttpServerProfileListDataFormatWildfireParam {
    /**
     * Parameter name
     */
    name: string;
    /**
     * Parameter value
     */
    value: string;
}

export interface GetHttpServerProfileListDataServer {
    /**
     * HTTP server address
     */
    address: string;
    /**
     * HTTP server certificate profile
     */
    certificateProfile: string;
    /**
     * HTTP operation to perform
     */
    httpMethod: string;
    /**
     * HTTP server name
     */
    name: string;
    /**
     * HTTP server port
     */
    port: number;
    /**
     * HTTP server protocol
     */
    protocol: string;
    /**
     * HTTP server TLS version
     */
    tlsVersion: string;
}

export interface GetHttpServerProfileServer {
    /**
     * HTTP server address
     */
    address: string;
    /**
     * HTTP server certificate profile
     */
    certificateProfile: string;
    /**
     * HTTP operation to perform
     */
    httpMethod: string;
    /**
     * HTTP server name
     */
    name: string;
    /**
     * HTTP server port
     */
    port: number;
    /**
     * HTTP server protocol
     */
    protocol: string;
    /**
     * HTTP server TLS version
     */
    tlsVersion: string;
}

export interface GetIkeCryptoProfileLifetime {
    /**
     * specify lifetime in days
     */
    days: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds: number;
}

export interface GetIkeCryptoProfileListData {
    /**
     * IKEv2 SA reauthentication interval equals authetication-multiple * rekey-lifetime; 0 means reauthentication disabled
     */
    authenticationMultiple: number;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Dh group
     */
    dhGroups: string[];
    /**
     * Encryption algorithm
     */
    encryptions: string[];
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Hash
     */
    hashes: string[];
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Ike crypto profile lifetime
     */
    lifetime: outputs.GetIkeCryptoProfileListDataLifetime;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetIkeCryptoProfileListDataLifetime {
    /**
     * specify lifetime in days
     */
    days: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds: number;
}

export interface GetIkeGatewayAuthentication {
    /**
     * Certificate
     */
    certificate: outputs.GetIkeGatewayAuthenticationCertificate;
    /**
     * Pre shared key
     *
     * > ℹ️ **Note:** You must specify exactly one of `certificate` and `preSharedKey`.
     */
    preSharedKey: outputs.GetIkeGatewayAuthenticationPreSharedKey;
}

export interface GetIkeGatewayAuthenticationCertificate {
    /**
     * Allow id payload mismatch
     */
    allowIdPayloadMismatch: boolean;
    /**
     * Certificate profile
     */
    certificateProfile: string;
    /**
     * Local certificate
     */
    localCertificate: outputs.GetIkeGatewayAuthenticationCertificateLocalCertificate;
    /**
     * Strict validation revocation
     */
    strictValidationRevocation: boolean;
    /**
     * Use management as source
     */
    useManagementAsSource: boolean;
}

export interface GetIkeGatewayAuthenticationCertificateLocalCertificate {
    /**
     * Local certificate name
     */
    localCertificateName: string;
}

export interface GetIkeGatewayAuthenticationPreSharedKey {
    /**
     * Key
     */
    key: string;
}

export interface GetIkeGatewayListData {
    /**
     * Authentication
     */
    authentication: outputs.GetIkeGatewayListDataAuthentication;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Local address
     */
    localAddress: outputs.GetIkeGatewayListDataLocalAddress;
    /**
     * Local id
     */
    localId: outputs.GetIkeGatewayListDataLocalId;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Peer address
     */
    peerAddress: outputs.GetIkeGatewayListDataPeerAddress;
    /**
     * Peer id
     */
    peerId: outputs.GetIkeGatewayListDataPeerId;
    /**
     * Protocol
     */
    protocol: outputs.GetIkeGatewayListDataProtocol;
    /**
     * Protocol common
     */
    protocolCommon: outputs.GetIkeGatewayListDataProtocolCommon;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetIkeGatewayListDataAuthentication {
    /**
     * Certificate
     */
    certificate: outputs.GetIkeGatewayListDataAuthenticationCertificate;
    /**
     * Pre shared key
     *
     * > ℹ️ **Note:** You must specify exactly one of `certificate` and `preSharedKey`.
     */
    preSharedKey: outputs.GetIkeGatewayListDataAuthenticationPreSharedKey;
}

export interface GetIkeGatewayListDataAuthenticationCertificate {
    /**
     * Allow id payload mismatch
     */
    allowIdPayloadMismatch: boolean;
    /**
     * Certificate profile
     */
    certificateProfile: string;
    /**
     * Local certificate
     */
    localCertificate: outputs.GetIkeGatewayListDataAuthenticationCertificateLocalCertificate;
    /**
     * Strict validation revocation
     */
    strictValidationRevocation: boolean;
    /**
     * Use management as source
     */
    useManagementAsSource: boolean;
}

export interface GetIkeGatewayListDataAuthenticationCertificateLocalCertificate {
    /**
     * Local certificate name
     */
    localCertificateName: string;
}

export interface GetIkeGatewayListDataAuthenticationPreSharedKey {
    /**
     * Key
     */
    key: string;
}

export interface GetIkeGatewayListDataLocalAddress {
    /**
     * Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
     */
    interface: string;
}

export interface GetIkeGatewayListDataLocalId {
    /**
     * Local ID string
     */
    id: string;
    /**
     * Type
     */
    type: string;
}

export interface GetIkeGatewayListDataPeerAddress {
    /**
     * Dynamic
     */
    dynamic: outputs.GetIkeGatewayListDataPeerAddressDynamic;
    /**
     * peer gateway FQDN name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    fqdn: string;
    /**
     * peer gateway has static IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    ip: string;
}

export interface GetIkeGatewayListDataPeerAddressDynamic {
}

export interface GetIkeGatewayListDataPeerId {
    /**
     * Peer ID string
     */
    id: string;
    /**
     * Type
     */
    type: string;
}

export interface GetIkeGatewayListDataProtocol {
    /**
     * Ikev1
     */
    ikev1: outputs.GetIkeGatewayListDataProtocolIkev1;
    /**
     * Ikev2
     */
    ikev2: outputs.GetIkeGatewayListDataProtocolIkev2;
    /**
     * Version
     */
    version: string;
}

export interface GetIkeGatewayListDataProtocolCommon {
    /**
     * Fragmentation
     */
    fragmentation: outputs.GetIkeGatewayListDataProtocolCommonFragmentation;
    /**
     * Enables NAT traversal for the IKE gateway.
     */
    natTraversal: outputs.GetIkeGatewayListDataProtocolCommonNatTraversal;
    /**
     * Passive mode
     */
    passiveMode: boolean;
}

export interface GetIkeGatewayListDataProtocolCommonFragmentation {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayListDataProtocolCommonNatTraversal {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayListDataProtocolIkev1 {
    /**
     * Dpd
     */
    dpd: outputs.GetIkeGatewayListDataProtocolIkev1Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile: string;
}

export interface GetIkeGatewayListDataProtocolIkev1Dpd {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayListDataProtocolIkev2 {
    /**
     * Dpd
     */
    dpd: outputs.GetIkeGatewayListDataProtocolIkev2Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile: string;
}

export interface GetIkeGatewayListDataProtocolIkev2Dpd {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayLocalAddress {
    /**
     * Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
     */
    interface: string;
}

export interface GetIkeGatewayLocalId {
    /**
     * Local ID string
     */
    id: string;
    /**
     * Type
     */
    type: string;
}

export interface GetIkeGatewayPeerAddress {
    /**
     * Dynamic
     */
    dynamic: outputs.GetIkeGatewayPeerAddressDynamic;
    /**
     * peer gateway FQDN name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    fqdn: string;
    /**
     * peer gateway has static IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    ip: string;
}

export interface GetIkeGatewayPeerAddressDynamic {
}

export interface GetIkeGatewayPeerId {
    /**
     * Peer ID string
     */
    id: string;
    /**
     * Type
     */
    type: string;
}

export interface GetIkeGatewayProtocol {
    /**
     * Ikev1
     */
    ikev1: outputs.GetIkeGatewayProtocolIkev1;
    /**
     * Ikev2
     */
    ikev2: outputs.GetIkeGatewayProtocolIkev2;
    /**
     * Version
     */
    version: string;
}

export interface GetIkeGatewayProtocolCommon {
    /**
     * Fragmentation
     */
    fragmentation: outputs.GetIkeGatewayProtocolCommonFragmentation;
    /**
     * Enables NAT traversal for the IKE gateway.
     */
    natTraversal: outputs.GetIkeGatewayProtocolCommonNatTraversal;
    /**
     * Passive mode
     */
    passiveMode: boolean;
}

export interface GetIkeGatewayProtocolCommonFragmentation {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayProtocolCommonNatTraversal {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayProtocolIkev1 {
    /**
     * Dpd
     */
    dpd: outputs.GetIkeGatewayProtocolIkev1Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile: string;
}

export interface GetIkeGatewayProtocolIkev1Dpd {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetIkeGatewayProtocolIkev2 {
    /**
     * Dpd
     */
    dpd: outputs.GetIkeGatewayProtocolIkev2Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile: string;
}

export interface GetIkeGatewayProtocolIkev2Dpd {
    /**
     * Enable
     */
    enable: boolean;
}

export interface GetInterfaceManagementProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Allow HTTP?
     */
    http: boolean;
    /**
     * Allow HTTP OCSP?
     */
    httpOcsp: boolean;
    /**
     * Allow HTTPS?
     */
    https: boolean;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Allowed IP address(es)
     */
    permittedIps: outputs.GetInterfaceManagementProfileListDataPermittedIp[];
    /**
     * Allow ping?
     */
    ping: boolean;
    /**
     * Allow response pages?
     */
    responsePages: boolean;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Allow SSH?
     */
    ssh: boolean;
    /**
     * Allow telnet? Seriously, why would you do this?!?
     */
    telnet: boolean;
    tfid: string;
    /**
     * Allow User-ID?
     */
    useridService: boolean;
    /**
     * Allow User-ID syslog listener (SSL)?
     */
    useridSyslogListenerSsl: boolean;
    /**
     * Allow User-ID syslog listener (UDP)?
     */
    useridSyslogListenerUdp: boolean;
}

export interface GetInterfaceManagementProfileListDataPermittedIp {
    /**
     * The allowed IP address or CIDR block.
     */
    name: string;
}

export interface GetInterfaceManagementProfilePermittedIp {
    /**
     * The allowed IP address or CIDR block.
     */
    name: string;
}

export interface GetIpsecCryptoProfileAh {
    /**
     * Authentication
     */
    authentications: string[];
}

export interface GetIpsecCryptoProfileEsp {
    /**
     * Authentication algorithm
     */
    authentications: string[];
    /**
     * Encryption algorithm
     */
    encryptions: string[];
}

export interface GetIpsecCryptoProfileLifesize {
    /**
     * specify lifesize in gigabytes(GB)
     */
    gb: number;
    /**
     * specify lifesize in kilobytes(KB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    kb: number;
    /**
     * specify lifesize in megabytes(MB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    mb: number;
    /**
     * specify lifesize in terabytes(TB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    tb: number;
}

export interface GetIpsecCryptoProfileLifetime {
    /**
     * specify lifetime in days
     */
    days: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds: number;
}

export interface GetIpsecCryptoProfileListData {
    /**
     * Ah
     *
     * > ℹ️ **Note:** You must specify exactly one of `ah` and `esp`.
     */
    ah: outputs.GetIpsecCryptoProfileListDataAh;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * phase-2 DH group (PFS DH group)
     */
    dhGroup: string;
    /**
     * Esp
     *
     * > ℹ️ **Note:** You must specify exactly one of `ah` and `esp`.
     */
    esp: outputs.GetIpsecCryptoProfileListDataEsp;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Lifesize
     */
    lifesize: outputs.GetIpsecCryptoProfileListDataLifesize;
    /**
     * Ipsec crypto profile lifetime
     */
    lifetime: outputs.GetIpsecCryptoProfileListDataLifetime;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetIpsecCryptoProfileListDataAh {
    /**
     * Authentication
     */
    authentications: string[];
}

export interface GetIpsecCryptoProfileListDataEsp {
    /**
     * Authentication algorithm
     */
    authentications: string[];
    /**
     * Encryption algorithm
     */
    encryptions: string[];
}

export interface GetIpsecCryptoProfileListDataLifesize {
    /**
     * specify lifesize in gigabytes(GB)
     */
    gb: number;
    /**
     * specify lifesize in kilobytes(KB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    kb: number;
    /**
     * specify lifesize in megabytes(MB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    mb: number;
    /**
     * specify lifesize in terabytes(TB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    tb: number;
}

export interface GetIpsecCryptoProfileListDataLifetime {
    /**
     * specify lifetime in days
     */
    days: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds: number;
}

export interface GetIpsecTunnelAutoKey {
    /**
     * Ike gateway
     */
    ikeGateways: outputs.GetIpsecTunnelAutoKeyIkeGateway[];
    /**
     * Ipsec crypto profile
     */
    ipsecCryptoProfile: string;
    /**
     * IPv6 type of proxy*id values
     */
    proxyIdV6s: outputs.GetIpsecTunnelAutoKeyProxyIdV6[];
    /**
     * IPv4 type of proxy*id values
     */
    proxyIds: outputs.GetIpsecTunnelAutoKeyProxyId[];
}

export interface GetIpsecTunnelAutoKeyIkeGateway {
    /**
     * Name
     */
    name: string;
}

export interface GetIpsecTunnelAutoKeyProxyId {
    /**
     * Local
     */
    local: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv4 type of proxy*id protocol values for TCP protocol
     */
    protocol: outputs.GetIpsecTunnelAutoKeyProxyIdProtocol;
    /**
     * Remote
     */
    remote: string;
}

export interface GetIpsecTunnelAutoKeyProxyIdProtocol {
    /**
     * IP protocol number
     */
    number: number;
    /**
     * IPv4 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp: outputs.GetIpsecTunnelAutoKeyProxyIdProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp: outputs.GetIpsecTunnelAutoKeyProxyIdProtocolUdp;
}

export interface GetIpsecTunnelAutoKeyProxyIdProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelAutoKeyProxyIdProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelAutoKeyProxyIdV6 {
    /**
     * Local
     */
    local: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv6 type of proxy*id protocol values for protocol
     */
    protocol: outputs.GetIpsecTunnelAutoKeyProxyIdV6Protocol;
    /**
     * Remote
     */
    remote: string;
}

export interface GetIpsecTunnelAutoKeyProxyIdV6Protocol {
    /**
     * IP protocol number
     */
    number: number;
    /**
     * IPv6 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp: outputs.GetIpsecTunnelAutoKeyProxyIdV6ProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp: outputs.GetIpsecTunnelAutoKeyProxyIdV6ProtocolUdp;
}

export interface GetIpsecTunnelAutoKeyProxyIdV6ProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelAutoKeyProxyIdV6ProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelListData {
    /**
     * Enable Anti-Replay check on this tunnel
     */
    antiReplay: boolean;
    /**
     * Auto key
     */
    autoKey: outputs.GetIpsecTunnelListDataAutoKey;
    /**
     * Copy IP TOS bits from inner packet to IPSec packet (not recommended)
     */
    copyTos: boolean;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * allow GRE over IPSec
     */
    enableGreEncapsulation: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Tunnel interface variable or hardcoded tunnel. Default will be tunnels.
     */
    tunnelInterface: string;
    /**
     * Tunnel monitor
     */
    tunnelMonitor: outputs.GetIpsecTunnelListDataTunnelMonitor;
}

export interface GetIpsecTunnelListDataAutoKey {
    /**
     * Ike gateway
     */
    ikeGateways: outputs.GetIpsecTunnelListDataAutoKeyIkeGateway[];
    /**
     * Ipsec crypto profile
     */
    ipsecCryptoProfile: string;
    /**
     * IPv6 type of proxy*id values
     */
    proxyIdV6s: outputs.GetIpsecTunnelListDataAutoKeyProxyIdV6[];
    /**
     * IPv4 type of proxy*id values
     */
    proxyIds: outputs.GetIpsecTunnelListDataAutoKeyProxyId[];
}

export interface GetIpsecTunnelListDataAutoKeyIkeGateway {
    /**
     * Name
     */
    name: string;
}

export interface GetIpsecTunnelListDataAutoKeyProxyId {
    /**
     * Local
     */
    local: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv4 type of proxy*id protocol values for TCP protocol
     */
    protocol: outputs.GetIpsecTunnelListDataAutoKeyProxyIdProtocol;
    /**
     * Remote
     */
    remote: string;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdProtocol {
    /**
     * IP protocol number
     */
    number: number;
    /**
     * IPv4 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp: outputs.GetIpsecTunnelListDataAutoKeyProxyIdProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp: outputs.GetIpsecTunnelListDataAutoKeyProxyIdProtocolUdp;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdV6 {
    /**
     * Local
     */
    local: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv6 type of proxy*id protocol values for protocol
     */
    protocol: outputs.GetIpsecTunnelListDataAutoKeyProxyIdV6Protocol;
    /**
     * Remote
     */
    remote: string;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdV6Protocol {
    /**
     * IP protocol number
     */
    number: number;
    /**
     * IPv6 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp: outputs.GetIpsecTunnelListDataAutoKeyProxyIdV6ProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp: outputs.GetIpsecTunnelListDataAutoKeyProxyIdV6ProtocolUdp;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdV6ProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelListDataAutoKeyProxyIdV6ProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetIpsecTunnelListDataTunnelMonitor {
    /**
     * Destination IP to send ICMP probe
     */
    destinationIp: string;
    /**
     * Enable tunnel monitoring on this tunnel
     */
    enable: boolean;
    /**
     * Which proxy-id (or proxy-id-v6) the monitoring traffic will use
     */
    proxyId: string;
}

export interface GetIpsecTunnelTunnelMonitor {
    /**
     * Destination IP to send ICMP probe
     */
    destinationIp: string;
    /**
     * Enable tunnel monitoring on this tunnel
     */
    enable: boolean;
    /**
     * Which proxy-id (or proxy-id-v6) the monitoring traffic will use
     */
    proxyId: string;
}

export interface GetKerberosServerProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the Kerberos server profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The Kerberos server configuration
     */
    servers: outputs.GetKerberosServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetKerberosServerProfileListDataServer {
    /**
     * The Kerberos server IP address
     */
    host: string;
    /**
     * The Kerberos server name
     */
    name: string;
    /**
     * The Kerberos server port
     */
    port: number;
}

export interface GetKerberosServerProfileServer {
    /**
     * The Kerberos server IP address
     */
    host: string;
    /**
     * The Kerberos server name
     */
    name: string;
    /**
     * The Kerberos server port
     */
    port: number;
}

export interface GetLabelListData {
    /**
     * The description of the label
     */
    description: string;
    /**
     * The UUID of the label
     */
    id: string;
    /**
     * The name of the label
     */
    name: string;
    tfid: string;
}

export interface GetLayer2SubinterfaceListData {
    /**
     * Description
     */
    comment: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Parent interface
     */
    parentInterface: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * VLAN tag
     */
    vlanTag: string;
}

export interface GetLayer3SubinterfaceArp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetLayer3SubinterfaceDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetLayer3SubinterfaceDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Layer3 sub interfaces DHCP Client Send hostname
     */
    sendHostname: outputs.GetLayer3SubinterfaceDhcpClientSendHostname;
}

export interface GetLayer3SubinterfaceDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetLayer3SubinterfaceIp {
    /**
     * L3 sub-interface IP address(es)
     */
    name: string;
}

export interface GetLayer3SubinterfaceListData {
    /**
     * Layer 3 sub Interfaces ARP configuration
     */
    arps: outputs.GetLayer3SubinterfaceListDataArp[];
    /**
     * Description
     */
    comment: string;
    /**
     * Dynamic DNS configuration specific to the Layer 3 sub Interfaces.
     */
    ddnsConfig: outputs.GetLayer3SubinterfaceListDataDdnsConfig;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Layer3 sub interfaces DHCP Client Object
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    dhcpClient: outputs.GetLayer3SubinterfaceListDataDhcpClient;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * L3 sub-interface IP Parent
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    ips: outputs.GetLayer3SubinterfaceListDataIp[];
    /**
     * MTU
     */
    mtu: number;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Parent interface
     */
    parentInterface: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * VLAN tag
     */
    tag: number;
    tfid: string;
}

export interface GetLayer3SubinterfaceListDataArp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetLayer3SubinterfaceListDataDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetLayer3SubinterfaceListDataDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Layer3 sub interfaces DHCP Client Send hostname
     */
    sendHostname: outputs.GetLayer3SubinterfaceListDataDhcpClientSendHostname;
}

export interface GetLayer3SubinterfaceListDataDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetLayer3SubinterfaceListDataIp {
    /**
     * L3 sub-interface IP address(es)
     */
    name: string;
}

export interface GetLdapServerProfileListData {
    /**
     * The base DN
     */
    base: string;
    /**
     * The bind DN
     */
    bindDn: string;
    /**
     * The bind password
     */
    bindPassword: string;
    /**
     * The bind timeout (seconds)
     */
    bindTimelimit: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the LDAP server profile
     */
    id: string;
    /**
     * The LDAP server time
     */
    ldapType: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The search retry interval (seconds)
     */
    retryInterval: number;
    /**
     * The LDAP server configuration
     */
    servers: outputs.GetLdapServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Require SSL/TLS secured connection?
     */
    ssl: boolean;
    tfid: string;
    /**
     * The search timeout (seconds)
     */
    timelimit: number;
    /**
     * Verify server certificate for SSL sessions?
     */
    verifyServerCertificate: boolean;
}

export interface GetLdapServerProfileListDataServer {
    /**
     * The LDAP server IP address
     */
    address: string;
    /**
     * The LDAP server name
     */
    name: string;
    /**
     * The LDAP server port
     */
    port: number;
}

export interface GetLdapServerProfileServer {
    /**
     * The LDAP server IP address
     */
    address: string;
    /**
     * The LDAP server name
     */
    name: string;
    /**
     * The LDAP server port
     */
    port: number;
}

export interface GetLinkTagListData {
    /**
     * The color of the link tag
     */
    color: string;
    /**
     * Description of the link tag
     */
    comments: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the link tag
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetLldpProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * LLDP mode
     */
    mode: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Option tlvs
     */
    optionTlvs: outputs.GetLldpProfileListDataOptionTlvs;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * SNMP syslog notification
     */
    snmpSyslogNotification: boolean;
    tfid: string;
}

export interface GetLldpProfileListDataOptionTlvs {
    /**
     * Management address
     */
    managementAddress: outputs.GetLldpProfileListDataOptionTlvsManagementAddress;
    /**
     * Option TLV Port Description
     */
    portDescription: boolean;
    /**
     * Option TLV System Capabilities
     */
    systemCapabilities: boolean;
    /**
     * Option TLV System Description
     */
    systemDescription: boolean;
    /**
     * Option TLV System Name
     */
    systemName: boolean;
}

export interface GetLldpProfileListDataOptionTlvsManagementAddress {
    /**
     * Management address enabled
     */
    enabled: boolean;
    /**
     * Iplist
     */
    iplists: outputs.GetLldpProfileListDataOptionTlvsManagementAddressIplist[];
}

export interface GetLldpProfileListDataOptionTlvsManagementAddressIplist {
    /**
     * Interface
     */
    interface: string;
    /**
     * IPv4 Address
     */
    ipv4: string;
    /**
     * IPv6 Address
     */
    ipv6: string;
    /**
     * Name
     */
    name: string;
}

export interface GetLldpProfileOptionTlvs {
    /**
     * Management address
     */
    managementAddress: outputs.GetLldpProfileOptionTlvsManagementAddress;
    /**
     * Option TLV Port Description
     */
    portDescription: boolean;
    /**
     * Option TLV System Capabilities
     */
    systemCapabilities: boolean;
    /**
     * Option TLV System Description
     */
    systemDescription: boolean;
    /**
     * Option TLV System Name
     */
    systemName: boolean;
}

export interface GetLldpProfileOptionTlvsManagementAddress {
    /**
     * Management address enabled
     */
    enabled: boolean;
    /**
     * Iplist
     */
    iplists: outputs.GetLldpProfileOptionTlvsManagementAddressIplist[];
}

export interface GetLldpProfileOptionTlvsManagementAddressIplist {
    /**
     * Interface
     */
    interface: string;
    /**
     * IPv4 Address
     */
    ipv4: string;
    /**
     * IPv6 Address
     */
    ipv6: string;
    /**
     * Name
     */
    name: string;
}

export interface GetLocalUserGroupListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the local user group
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * The local user group users
     */
    users: string[];
}

export interface GetLocalUserListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Is the local user disabled?
     */
    disabled: boolean;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the local user
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The password of the local user
     */
    password: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetLogForwardingProfileListData {
    /**
     * Log forwarding profile description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the log server profile
     */
    id: string;
    /**
     * Match list
     */
    matchLists: outputs.GetLogForwardingProfileListDataMatchList[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetLogForwardingProfileListDataMatchList {
    /**
     * Match profile description
     */
    actionDesc: string;
    /**
     * Filter match criteria
     */
    filter: string;
    /**
     * Log type
     */
    logType: string;
    /**
     * Name of the match profile
     */
    name: string;
    /**
     * A list of email server profiles
     */
    sendEmails: string[];
    /**
     * A list of HTTP server profiles
     */
    sendHttps: string[];
    /**
     * A list of SNMP server profiles
     */
    sendSnmptraps: string[];
    /**
     * A list of syslog server profiles
     */
    sendSyslogs: string[];
}

export interface GetLogForwardingProfileMatchList {
    /**
     * Match profile description
     */
    actionDesc: string;
    /**
     * Filter match criteria
     */
    filter: string;
    /**
     * Log type
     */
    logType: string;
    /**
     * Name of the match profile
     */
    name: string;
    /**
     * A list of email server profiles
     */
    sendEmails: string[];
    /**
     * A list of HTTP server profiles
     */
    sendHttps: string[];
    /**
     * A list of SNMP server profiles
     */
    sendSnmptraps: string[];
    /**
     * A list of syslog server profiles
     */
    sendSyslogs: string[];
}

export interface GetLogicalRouterListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Routing stack
     */
    routingStack: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Vrf
     */
    vrves: outputs.GetLogicalRouterListDataVrf[];
}

export interface GetLogicalRouterListDataVrf {
    /**
     * Admin dists
     */
    adminDists: outputs.GetLogicalRouterListDataVrfAdminDists;
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterListDataVrfBgp;
    /**
     * Ecmp
     */
    ecmp: outputs.GetLogicalRouterListDataVrfEcmp;
    /**
     * Global vrid
     */
    globalVrid: number;
    /**
     * Interface
     */
    interfaces: string[];
    /**
     * Multicast
     */
    multicast: outputs.GetLogicalRouterListDataVrfMulticast;
    /**
     * Name
     */
    name: string;
    /**
     * Ospf
     */
    ospf: outputs.GetLogicalRouterListDataVrfOspf;
    /**
     * Ospfv3
     */
    ospfv3: outputs.GetLogicalRouterListDataVrfOspfv3;
    /**
     * Rib filter
     */
    ribFilter: outputs.GetLogicalRouterListDataVrfRibFilter;
    /**
     * Rip
     */
    rip: outputs.GetLogicalRouterListDataVrfRip;
    /**
     * Routing table
     */
    routingTable: outputs.GetLogicalRouterListDataVrfRoutingTable;
    /**
     * Sdwan type
     */
    sdwanType: string;
    /**
     * Vr admin dists
     */
    vrAdminDists: outputs.GetLogicalRouterListDataVrfVrAdminDists;
    /**
     * Zone name
     */
    zoneName: string;
}

export interface GetLogicalRouterListDataVrfAdminDists {
    /**
     * Bgp external
     */
    bgpExternal: number;
    /**
     * Bgp internal
     */
    bgpInternal: number;
    /**
     * Bgp local
     */
    bgpLocal: number;
    /**
     * Ospf ext
     */
    ospfExt: number;
    /**
     * Ospf inter
     */
    ospfInter: number;
    /**
     * Ospf intra
     */
    ospfIntra: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext: number;
    /**
     * Ospfv3 inter
     */
    ospfv3Inter: number;
    /**
     * Ospfv3 intra
     */
    ospfv3Intra: number;
    /**
     * Rip
     */
    rip: number;
    /**
     * Static
     */
    static: number;
    /**
     * Static ipv6
     */
    staticIpv6: number;
}

export interface GetLogicalRouterListDataVrfBgp {
    /**
     * Advertise network
     */
    advertiseNetwork: outputs.GetLogicalRouterListDataVrfBgpAdvertiseNetwork;
    /**
     * Aggregate
     */
    aggregate: outputs.GetLogicalRouterListDataVrfBgpAggregate;
    /**
     * Aggregate routes
     */
    aggregateRoutes: outputs.GetLogicalRouterListDataVrfBgpAggregateRoute[];
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Always advertise network route
     */
    alwaysAdvertiseNetworkRoute: boolean;
    /**
     * As format
     */
    asFormat: string;
    /**
     * Confederation member as
     */
    confederationMemberAs: string;
    /**
     * Default local preference
     */
    defaultLocalPreference: number;
    /**
     * Ecmp multi as
     */
    ecmpMultiAs: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enforce first as
     */
    enforceFirstAs: boolean;
    /**
     * Fast external failover
     */
    fastExternalFailover: boolean;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterListDataVrfBgpGlobalBfd;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterListDataVrfBgpGracefulRestart;
    /**
     * Graceful shutdown
     */
    gracefulShutdown: boolean;
    /**
     * Install route
     */
    installRoute: boolean;
    /**
     * Local as
     */
    localAs: string;
    /**
     * Med
     */
    med: outputs.GetLogicalRouterListDataVrfBgpMed;
    /**
     * Peer group
     */
    peerGroups: outputs.GetLogicalRouterListDataVrfBgpPeerGroup[];
    /**
     * Policy
     */
    policy: outputs.GetLogicalRouterListDataVrfBgpPolicy;
    /**
     * Redist rules
     */
    redistRules: outputs.GetLogicalRouterListDataVrfBgpRedistRule[];
    /**
     * Redistribution profile
     */
    redistributionProfile: outputs.GetLogicalRouterListDataVrfBgpRedistributionProfile;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Router id
     */
    routerId: string;
}

export interface GetLogicalRouterListDataVrfBgpAdvertiseNetwork {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv6;
}

export interface GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv4 {
    /**
     * Network
     */
    networks: outputs.GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv4Network[];
}

export interface GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv4Network {
    /**
     * Backdoor
     */
    backdoor: boolean;
    /**
     * Multicast
     */
    multicast: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv6 {
    /**
     * Network
     */
    networks: outputs.GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv6Network[];
}

export interface GetLogicalRouterListDataVrfBgpAdvertiseNetworkIpv6Network {
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterListDataVrfBgpAggregate {
    /**
     * Aggregate med
     */
    aggregateMed: boolean;
}

export interface GetLogicalRouterListDataVrfBgpAggregateRoute {
    /**
     * As set
     */
    asSet: boolean;
    /**
     * Description
     */
    description: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Same med
     */
    sameMed: boolean;
    /**
     * Summary only
     */
    summaryOnly: boolean;
    /**
     * Type
     */
    type: outputs.GetLogicalRouterListDataVrfBgpAggregateRouteType;
}

export interface GetLogicalRouterListDataVrfBgpAggregateRouteType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterListDataVrfBgpAggregateRouteTypeIpv4;
    /**
     * Ipv6
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4` and `ipv6`.
     */
    ipv6: outputs.GetLogicalRouterListDataVrfBgpAggregateRouteTypeIpv6;
}

export interface GetLogicalRouterListDataVrfBgpAggregateRouteTypeIpv4 {
    /**
     * Attribute map
     */
    attributeMap: string;
    /**
     * Summary prefix
     */
    summaryPrefix: string;
    /**
     * Suppress map
     */
    suppressMap: string;
}

export interface GetLogicalRouterListDataVrfBgpAggregateRouteTypeIpv6 {
    /**
     * Attribute map
     */
    attributeMap: string;
    /**
     * Summary prefix
     */
    summaryPrefix: string;
    /**
     * Suppress map
     */
    suppressMap: string;
}

export interface GetLogicalRouterListDataVrfBgpGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfBgpGracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Local restart time
     */
    localRestartTime: number;
    /**
     * Max peer restart time
     */
    maxPeerRestartTime: number;
    /**
     * Stale route time
     */
    staleRouteTime: number;
}

export interface GetLogicalRouterListDataVrfBgpMed {
    /**
     * Always compare med
     */
    alwaysCompareMed: boolean;
    /**
     * Deterministic med comparison
     */
    deterministicMedComparison: boolean;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroup {
    /**
     * Address family
     */
    addressFamily: outputs.GetLogicalRouterListDataVrfBgpPeerGroupAddressFamily;
    /**
     * Aggregated confed as path
     */
    aggregatedConfedAsPath: boolean;
    /**
     * Connection options
     */
    connectionOptions: outputs.GetLogicalRouterListDataVrfBgpPeerGroupConnectionOptions;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Filtering profile
     */
    filteringProfile: outputs.GetLogicalRouterListDataVrfBgpPeerGroupFilteringProfile;
    /**
     * Name
     */
    name: string;
    /**
     * Peer
     */
    peers: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeer[];
    /**
     * Soft reset with stored info
     */
    softResetWithStoredInfo: boolean;
    /**
     * Type
     */
    type: outputs.GetLogicalRouterListDataVrfBgpPeerGroupType;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupAddressFamily {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupConnectionOptions {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Multihop
     */
    multihop: number;
    /**
     * Timers
     */
    timers: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupFilteringProfile {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeer {
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerBfd;
    /**
     * Connection options
     */
    connectionOptions: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptions;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enable mp bgp
     */
    enableMpBgp: boolean;
    /**
     * Enable sender side loop detection
     */
    enableSenderSideLoopDetection: boolean;
    /**
     * Inherit
     */
    inherit: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerInherit;
    /**
     * Local address
     */
    localAddress: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerLocalAddress;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Peer address
     */
    peerAddress: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs: string;
    /**
     * Peering type
     */
    peeringType: string;
    /**
     * Reflector client
     */
    reflectorClient: string;
    /**
     * Subsequent address family identifier
     */
    subsequentAddressFamilyIdentifier: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerBfd {
    /**
     * Multihop
     */
    multihop: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerBfdMultihop;
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerBfdMultihop {
    /**
     * Min received ttl
     */
    minReceivedTtl: number;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptions {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Hold time
     */
    holdTime: string;
    /**
     * Idle hold time
     */
    idleHoldTime: number;
    /**
     * Incoming bgp connection
     */
    incomingBgpConnection: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection;
    /**
     * Keep alive interval
     */
    keepAliveInterval: string;
    /**
     * Max prefixes
     */
    maxPrefixes: string;
    /**
     * Min route adv interval
     */
    minRouteAdvInterval: number;
    /**
     * Multihop
     */
    multihop: string;
    /**
     * Open delay time
     */
    openDelayTime: number;
    /**
     * Outgoing bgp connection
     */
    outgoingBgpConnection: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection;
    /**
     * Timers
     */
    timers: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection {
    /**
     * Allow
     */
    allow: boolean;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection {
    /**
     * Allow
     */
    allow: boolean;
    /**
     * Local port
     */
    localPort: number;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerInherit {
    /**
     * No
     */
    no: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
     */
    yes: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritYes;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNo {
    /**
     * Address family
     */
    addressFamily: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNoAddressFamily;
    /**
     * Filtering profile
     */
    filteringProfile: outputs.GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNoFilteringProfile;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNoAddressFamily {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritNoFilteringProfile {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerInheritYes {
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerLocalAddress {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier {
    /**
     * Multicast
     */
    multicast: boolean;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupType {
    /**
     * Ebgp
     */
    ebgp: outputs.GetLogicalRouterListDataVrfBgpPeerGroupTypeEbgp;
    /**
     * Ebgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ebgpConfed: outputs.GetLogicalRouterListDataVrfBgpPeerGroupTypeEbgpConfed;
    /**
     * Ibgp
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgp: outputs.GetLogicalRouterListDataVrfBgpPeerGroupTypeIbgp;
    /**
     * Ibgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgpConfed: outputs.GetLogicalRouterListDataVrfBgpPeerGroupTypeIbgpConfed;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupTypeEbgp {
    /**
     * Export nexthop
     */
    exportNexthop: string;
    /**
     * Import nexthop
     */
    importNexthop: string;
    /**
     * Remove private as
     */
    removePrivateAs: boolean;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupTypeEbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupTypeIbgp {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterListDataVrfBgpPeerGroupTypeIbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicy {
    /**
     * Aggregation
     */
    aggregation: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregation;
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisement;
    /**
     * Export
     */
    export: outputs.GetLogicalRouterListDataVrfBgpPolicyExport;
    /**
     * Import
     */
    import: outputs.GetLogicalRouterListDataVrfBgpPolicyImport;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregation {
    /**
     * Address
     */
    addresses: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddress[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddress {
    /**
     * Advertise filters
     */
    advertiseFilters: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilter[];
    /**
     * Aggregate route attributes
     */
    aggregateRouteAttributes: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributes;
    /**
     * As set
     */
    asSet: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Prefix
     */
    prefix: string;
    /**
     * Summary
     */
    summary: boolean;
    /**
     * Suppress filters
     */
    suppressFilters: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilter[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributes {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisement {
    /**
     * Policy
     */
    policies: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicy[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicy {
    /**
     * Advertise filters
     */
    advertiseFilters: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter[];
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Non exist filters
     */
    nonExistFilters: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter[];
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExport {
    /**
     * Rules
     */
    rules: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRule[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRule {
    /**
     * Action
     */
    action: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleAction;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleAction {
    /**
     * Allow
     */
    allow: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionDeny;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllow {
    /**
     * Update
     */
    update: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdate;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleActionDeny {
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyExportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImport {
    /**
     * Rules
     */
    rules: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRule[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRule {
    /**
     * Action
     */
    action: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleAction;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleAction {
    /**
     * Allow
     */
    allow: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionDeny;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllow {
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Update
     */
    update: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdate;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleActionDeny {
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpPolicyImportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterListDataVrfBgpRedistRule {
    /**
     * Address family identifier
     */
    addressFamilyIdentifier: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Set as path limit
     */
    setAsPathLimit: number;
    /**
     * Set community
     */
    setCommunities: string[];
    /**
     * Set extended community
     */
    setExtendedCommunities: string[];
    /**
     * Set local preference
     */
    setLocalPreference: number;
    /**
     * Set med
     */
    setMed: number;
    /**
     * Set origin
     */
    setOrigin: string;
}

export interface GetLogicalRouterListDataVrfBgpRedistributionProfile {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterListDataVrfBgpRedistributionProfileIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterListDataVrfBgpRedistributionProfileIpv6;
}

export interface GetLogicalRouterListDataVrfBgpRedistributionProfileIpv4 {
    /**
     * Unicast
     */
    unicast: string;
}

export interface GetLogicalRouterListDataVrfBgpRedistributionProfileIpv6 {
    /**
     * Unicast
     */
    unicast: string;
}

export interface GetLogicalRouterListDataVrfEcmp {
    /**
     * Algorithm
     */
    algorithm: outputs.GetLogicalRouterListDataVrfEcmpAlgorithm;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max path
     */
    maxPath: number;
    /**
     * Strict source path
     */
    strictSourcePath: boolean;
    /**
     * Symmetric return
     */
    symmetricReturn: boolean;
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithm {
    /**
     * Balanced round robin
     */
    balancedRoundRobin: outputs.GetLogicalRouterListDataVrfEcmpAlgorithmBalancedRoundRobin;
    /**
     * Ip hash
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipHash: outputs.GetLogicalRouterListDataVrfEcmpAlgorithmIpHash;
    /**
     * Ip modulo
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipModulo: outputs.GetLogicalRouterListDataVrfEcmpAlgorithmIpModulo;
    /**
     * Weighted round robin
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    weightedRoundRobin: outputs.GetLogicalRouterListDataVrfEcmpAlgorithmWeightedRoundRobin;
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithmBalancedRoundRobin {
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithmIpHash {
    /**
     * Hash seed
     */
    hashSeed: number;
    /**
     * Src only
     */
    srcOnly: boolean;
    /**
     * Use port
     */
    usePort: boolean;
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithmIpModulo {
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithmWeightedRoundRobin {
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfEcmpAlgorithmWeightedRoundRobinInterface[];
}

export interface GetLogicalRouterListDataVrfEcmpAlgorithmWeightedRoundRobinInterface {
    /**
     * Name
     */
    name: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterListDataVrfMulticast {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enable v6
     */
    enableV6: boolean;
    /**
     * Igmp
     */
    igmp: outputs.GetLogicalRouterListDataVrfMulticastIgmp;
    /**
     * Interface group
     */
    interfaceGroups: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroup[];
    /**
     * Mode
     */
    mode: string;
    /**
     * Msdp
     */
    msdp: outputs.GetLogicalRouterListDataVrfMulticastMsdp;
    /**
     * Pim
     */
    pim: outputs.GetLogicalRouterListDataVrfMulticastPim;
    /**
     * Route ageout time
     */
    routeAgeoutTime: number;
    /**
     * Rp
     */
    rp: outputs.GetLogicalRouterListDataVrfMulticastRp;
    /**
     * Spt threshold
     */
    sptThresholds: outputs.GetLogicalRouterListDataVrfMulticastSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpaces: outputs.GetLogicalRouterListDataVrfMulticastSsmAddressSpace[];
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterListDataVrfMulticastStaticRoute[];
}

export interface GetLogicalRouterListDataVrfMulticastIgmp {
    /**
     * Dynamic
     */
    dynamic: outputs.GetLogicalRouterListDataVrfMulticastIgmpDynamic;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Static
     */
    statics: outputs.GetLogicalRouterListDataVrfMulticastIgmpStatic[];
}

export interface GetLogicalRouterListDataVrfMulticastIgmpDynamic {
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfMulticastIgmpDynamicInterface[];
}

export interface GetLogicalRouterListDataVrfMulticastIgmpDynamicInterface {
    /**
     * Group filter
     */
    groupFilter: string;
    /**
     * Max groups
     */
    maxGroups: string;
    /**
     * Max sources
     */
    maxSources: string;
    /**
     * Name
     */
    name: string;
    /**
     * Query profile
     */
    queryProfile: string;
    /**
     * Robustness
     */
    robustness: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing: boolean;
    /**
     * Version
     */
    version: string;
}

export interface GetLogicalRouterListDataVrfMulticastIgmpStatic {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroup {
    /**
     * Description
     */
    description: string;
    /**
     * Group permission
     */
    groupPermission: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermission;
    /**
     * Igmp
     */
    igmp: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupIgmp;
    /**
     * Interface
     */
    interfaces: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Pim
     */
    pim: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupPim;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermission {
    /**
     * Any source multicast
     */
    anySourceMulticasts: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[];
    /**
     * Source specific multicast
     */
    sourceSpecificMulticasts: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[];
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupIgmp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Immediate leave
     */
    immediateLeave: boolean;
    /**
     * Last member query interval
     */
    lastMemberQueryInterval: number;
    /**
     * Max groups
     */
    maxGroups: string;
    /**
     * Max query response time
     */
    maxQueryResponseTime: number;
    /**
     * Max sources
     */
    maxSources: string;
    /**
     * Mode
     */
    mode: string;
    /**
     * Query interval
     */
    queryInterval: number;
    /**
     * Robustness
     */
    robustness: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing: boolean;
    /**
     * Version
     */
    version: string;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupPim {
    /**
     * Allowed neighbors
     */
    allowedNeighbors: outputs.GetLogicalRouterListDataVrfMulticastInterfaceGroupPimAllowedNeighbor[];
    /**
     * Assert interval
     */
    assertInterval: number;
    /**
     * Bsr border
     */
    bsrBorder: boolean;
    /**
     * Dr priority
     */
    drPriority: number;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Join prune interval
     */
    joinPruneInterval: number;
}

export interface GetLogicalRouterListDataVrfMulticastInterfaceGroupPimAllowedNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfMulticastMsdp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Global authentication
     */
    globalAuthentication: string;
    /**
     * Global timer
     */
    globalTimer: string;
    /**
     * Originator id
     */
    originatorId: outputs.GetLogicalRouterListDataVrfMulticastMsdpOriginatorId;
    /**
     * Peer
     */
    peers: outputs.GetLogicalRouterListDataVrfMulticastMsdpPeer[];
}

export interface GetLogicalRouterListDataVrfMulticastMsdpOriginatorId {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterListDataVrfMulticastMsdpPeer {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Inbound sa filter
     */
    inboundSaFilter: string;
    /**
     * Local address
     */
    localAddress: outputs.GetLogicalRouterListDataVrfMulticastMsdpPeerLocalAddress;
    /**
     * Max sa
     */
    maxSa: number;
    /**
     * Name
     */
    name: string;
    /**
     * Outbound sa filter
     */
    outboundSaFilter: string;
    /**
     * Peer address
     */
    peerAddress: outputs.GetLogicalRouterListDataVrfMulticastMsdpPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs: string;
}

export interface GetLogicalRouterListDataVrfMulticastMsdpPeerLocalAddress {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterListDataVrfMulticastMsdpPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip: string;
}

export interface GetLogicalRouterListDataVrfMulticastPim {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Group permission
     */
    groupPermission: string;
    /**
     * If timer global
     */
    ifTimerGlobal: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfMulticastPimInterface[];
    /**
     * Route ageout time
     */
    routeAgeoutTime: number;
    /**
     * Rp
     */
    rp: outputs.GetLogicalRouterListDataVrfMulticastPimRp;
    /**
     * Rpf lookup mode
     */
    rpfLookupMode: string;
    /**
     * Spt threshold
     */
    sptThresholds: outputs.GetLogicalRouterListDataVrfMulticastPimSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpace: outputs.GetLogicalRouterListDataVrfMulticastPimSsmAddressSpace;
}

export interface GetLogicalRouterListDataVrfMulticastPimInterface {
    /**
     * Description
     */
    description: string;
    /**
     * Dr priority
     */
    drPriority: number;
    /**
     * If timer
     */
    ifTimer: string;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor filter
     */
    neighborFilter: string;
    /**
     * Send bsm
     */
    sendBsm: boolean;
}

export interface GetLogicalRouterListDataVrfMulticastPimRp {
    /**
     * External rp
     */
    externalRps: outputs.GetLogicalRouterListDataVrfMulticastPimRpExternalRp[];
    /**
     * Local rp
     */
    localRp: outputs.GetLogicalRouterListDataVrfMulticastPimRpLocalRp;
}

export interface GetLogicalRouterListDataVrfMulticastPimRpExternalRp {
    /**
     * Group list
     */
    groupList: string;
    /**
     * Name
     */
    name: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterListDataVrfMulticastPimRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp: outputs.GetLogicalRouterListDataVrfMulticastPimRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp: outputs.GetLogicalRouterListDataVrfMulticastPimRpLocalRpStaticRp;
}

export interface GetLogicalRouterListDataVrfMulticastPimRpLocalRpCandidateRp {
    /**
     * Address
     */
    address: string;
    /**
     * Advertisement interval
     */
    advertisementInterval: number;
    /**
     * Group list
     */
    groupList: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterListDataVrfMulticastPimRpLocalRpStaticRp {
    /**
     * Address
     */
    address: string;
    /**
     * Group list
     */
    groupList: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterListDataVrfMulticastPimSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold: string;
}

export interface GetLogicalRouterListDataVrfMulticastPimSsmAddressSpace {
    /**
     * Group list
     */
    groupList: string;
}

export interface GetLogicalRouterListDataVrfMulticastRp {
    /**
     * External rp
     */
    externalRps: outputs.GetLogicalRouterListDataVrfMulticastRpExternalRp[];
    /**
     * Local rp
     */
    localRp: outputs.GetLogicalRouterListDataVrfMulticastRpLocalRp;
}

export interface GetLogicalRouterListDataVrfMulticastRpExternalRp {
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterListDataVrfMulticastRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp: outputs.GetLogicalRouterListDataVrfMulticastRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp: outputs.GetLogicalRouterListDataVrfMulticastRpLocalRpStaticRp;
}

export interface GetLogicalRouterListDataVrfMulticastRpLocalRpCandidateRp {
    /**
     * Address
     */
    address: string;
    /**
     * Advertisement interval
     */
    advertisementInterval: number;
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Interface
     */
    interface: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterListDataVrfMulticastRpLocalRpStaticRp {
    /**
     * Address
     */
    address: string;
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Interface
     */
    interface: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterListDataVrfMulticastSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold: string;
}

export interface GetLogicalRouterListDataVrfMulticastSsmAddressSpace {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfMulticastStaticRoute {
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterListDataVrfMulticastStaticRouteNexthop;
    /**
     * Preference
     */
    preference: number;
}

export interface GetLogicalRouterListDataVrfMulticastStaticRouteNexthop {
    /**
     * Ip address
     */
    ipAddress: string;
}

export interface GetLogicalRouterListDataVrfOspf {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Area
     */
    areas: outputs.GetLogicalRouterListDataVrfOspfArea[];
    /**
     * Auth profile
     */
    authProfiles: outputs.GetLogicalRouterListDataVrfOspfAuthProfile[];
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Export rules
     */
    exportRules: outputs.GetLogicalRouterListDataVrfOspfExportRule[];
    /**
     * Flood prevention
     */
    floodPrevention: outputs.GetLogicalRouterListDataVrfOspfFloodPrevention;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterListDataVrfOspfGlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer: string;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterListDataVrfOspfGracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Rfc1583
     */
    rfc1583: boolean;
    /**
     * Router id
     */
    routerId: string;
    /**
     * Spf timer
     */
    spfTimer: string;
    /**
     * Vr timers
     */
    vrTimers: outputs.GetLogicalRouterListDataVrfOspfVrTimers;
}

export interface GetLogicalRouterListDataVrfOspfArea {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfOspfAreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges: outputs.GetLogicalRouterListDataVrfOspfAreaRange[];
    /**
     * Type
     */
    type: outputs.GetLogicalRouterListDataVrfOspfAreaType;
    /**
     * Virtual link
     */
    virtualLinks: outputs.GetLogicalRouterListDataVrfOspfAreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges: outputs.GetLogicalRouterListDataVrfOspfAreaVrRange[];
}

export interface GetLogicalRouterListDataVrfOspfAreaInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Link type
     */
    linkType: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceLinkType;
    /**
     * Metric
     */
    metric: number;
    /**
     * Mtu ignore
     */
    mtuIgnore: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Priority
     */
    priority: number;
    /**
     * Timing
     */
    timing: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceVrTiming;
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2p;
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeBroadcast {
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceLinkTypeP2p {
}

export interface GetLogicalRouterListDataVrfOspfAreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Gr delay
     */
    grDelay: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterListDataVrfOspfAreaRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Substitute
     */
    substitute: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaType {
    /**
     * Normal
     */
    normal: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub: outputs.GetLogicalRouterListDataVrfOspfAreaTypeStub;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNormal {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNormalAbr;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssa {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRange[];
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric: number;
    /**
     * Metric type
     */
    metricType: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRouteDisable;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
    /**
     * Type
     */
    type: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaDefaultRouteDisable {
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRangeSuppress;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRangeAdvertise {
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeNssaNssaExtRangeSuppress {
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeStub {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfAreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric: number;
    /**
     * No summary
     */
    noSummary: boolean;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeStubAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRouteDisable;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterListDataVrfOspfAreaTypeStubDefaultRouteDisable {
}

export interface GetLogicalRouterListDataVrfOspfAreaVirtualLink {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfOspfAreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Interface id
     */
    interfaceId: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Timing
     */
    timing: string;
    /**
     * Transit area id
     */
    transitAreaId: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterListDataVrfOspfAreaVirtualLinkVrTiming;
}

export interface GetLogicalRouterListDataVrfOspfAreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfAreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterListDataVrfOspfAreaVrRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfAreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterListDataVrfOspfAreaVrRangeSuppress;
}

export interface GetLogicalRouterListDataVrfOspfAreaVrRangeAdvertise {
}

export interface GetLogicalRouterListDataVrfOspfAreaVrRangeSuppress {
}

export interface GetLogicalRouterListDataVrfOspfAuthProfile {
    /**
     * Md5
     */
    md5s: outputs.GetLogicalRouterListDataVrfOspfAuthProfileMd5[];
    /**
     * Name
     */
    name: string;
    /**
     * Password
     */
    password: string;
}

export interface GetLogicalRouterListDataVrfOspfAuthProfileMd5 {
    /**
     * Key
     */
    key: string;
    /**
     * Name
     */
    name: number;
    /**
     * Preferred
     */
    preferred: boolean;
}

export interface GetLogicalRouterListDataVrfOspfExportRule {
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType: string;
    /**
     * New tag
     */
    newTag: string;
}

export interface GetLogicalRouterListDataVrfOspfFloodPrevention {
    /**
     * Hello
     */
    hello: outputs.GetLogicalRouterListDataVrfOspfFloodPreventionHello;
    /**
     * Lsa
     */
    lsa: outputs.GetLogicalRouterListDataVrfOspfFloodPreventionLsa;
}

export interface GetLogicalRouterListDataVrfOspfFloodPreventionHello {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max packet
     */
    maxPacket: number;
}

export interface GetLogicalRouterListDataVrfOspfFloodPreventionLsa {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max packet
     */
    maxPacket: number;
}

export interface GetLogicalRouterListDataVrfOspfGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfGracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Grace period
     */
    gracePeriod: number;
    /**
     * Helper enable
     */
    helperEnable: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking: boolean;
}

export interface GetLogicalRouterListDataVrfOspfVrTimers {
    /**
     * Lsa interval
     */
    lsaInterval: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay: number;
}

export interface GetLogicalRouterListDataVrfOspfv3 {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Area
     */
    areas: outputs.GetLogicalRouterListDataVrfOspfv3Area[];
    /**
     * Auth profile
     */
    authProfiles: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfile[];
    /**
     * Disable transit traffic
     */
    disableTransitTraffic: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Export rules
     */
    exportRules: outputs.GetLogicalRouterListDataVrfOspfv3ExportRule[];
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterListDataVrfOspfv3GlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer: string;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterListDataVrfOspfv3GracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Router id
     */
    routerId: string;
    /**
     * Spf timer
     */
    spfTimer: string;
    /**
     * Vr timers
     */
    vrTimers: outputs.GetLogicalRouterListDataVrfOspfv3VrTimers;
}

export interface GetLogicalRouterListDataVrfOspfv3Area {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges: outputs.GetLogicalRouterListDataVrfOspfv3AreaRange[];
    /**
     * Type
     */
    type: outputs.GetLogicalRouterListDataVrfOspfv3AreaType;
    /**
     * Virtual link
     */
    virtualLinks: outputs.GetLogicalRouterListDataVrfOspfv3AreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges: outputs.GetLogicalRouterListDataVrfOspfv3AreaVrRange[];
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Link type
     */
    linkType: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkType;
    /**
     * Metric
     */
    metric: number;
    /**
     * Mtu ignore
     */
    mtuIgnore: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceNeighbor[];
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Priority
     */
    priority: number;
    /**
     * Timing
     */
    timing: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceVrTiming;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2p;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeBroadcast {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceLinkTypeP2p {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Gr delay
     */
    grDelay: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaType {
    /**
     * Normal
     */
    normal: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeStub;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNormal {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNormalAbr;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssa {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRange[];
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric: number;
    /**
     * Metric type
     */
    metricType: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRouteDisable;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
    /**
     * Type
     */
    type: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaDefaultRouteDisable {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRangeSuppress;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeNssaNssaExtRangeSuppress {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeStub {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric: number;
    /**
     * No summary
     */
    noSummary: boolean;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeStubAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRouteDisable;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaTypeStubDefaultRouteDisable {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVirtualLink {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfOspfv3AreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Interface id
     */
    interfaceId: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Timing
     */
    timing: string;
    /**
     * Transit area id
     */
    transitAreaId: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterListDataVrfOspfv3AreaVirtualLinkVrTiming;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVrRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterListDataVrfOspfv3AreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterListDataVrfOspfv3AreaVrRangeSuppress;
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVrRangeAdvertise {
}

export interface GetLogicalRouterListDataVrfOspfv3AreaVrRangeSuppress {
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfile {
    /**
     * Ah
     */
    ah: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAh;
    /**
     * Esp
     */
    esp: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEsp;
    /**
     * Name
     */
    name: string;
    /**
     * Spi
     */
    spi: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAh {
    /**
     * Md5
     */
    md5: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAhMd5;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha512;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAhMd5 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha1 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha256 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha384 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileAhSha512 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEsp {
    /**
     * Authentication
     */
    authentication: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthentication;
    /**
     * Encryption
     */
    encryption: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspEncryption;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthentication {
    /**
     * Md5
     */
    md5: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationMd5;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    none: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationNone;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512: outputs.GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha512;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationMd5 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationNone {
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha1 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha256 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha384 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspAuthenticationSha512 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3AuthProfileEspEncryption {
    /**
     * Algorithm
     */
    algorithm: string;
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterListDataVrfOspfv3ExportRule {
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType: string;
    /**
     * New tag
     */
    newTag: string;
}

export interface GetLogicalRouterListDataVrfOspfv3GlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfOspfv3GracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Grace period
     */
    gracePeriod: number;
    /**
     * Helper enable
     */
    helperEnable: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking: boolean;
}

export interface GetLogicalRouterListDataVrfOspfv3VrTimers {
    /**
     * Lsa interval
     */
    lsaInterval: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay: number;
}

export interface GetLogicalRouterListDataVrfRibFilter {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterListDataVrfRibFilterIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterListDataVrfRibFilterIpv6;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv4 {
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterListDataVrfRibFilterIpv4Bgp;
    /**
     * Ospf
     */
    ospf: outputs.GetLogicalRouterListDataVrfRibFilterIpv4Ospf;
    /**
     * Rip
     */
    rip: outputs.GetLogicalRouterListDataVrfRibFilterIpv4Rip;
    /**
     * Static
     */
    static: outputs.GetLogicalRouterListDataVrfRibFilterIpv4Static;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv4Bgp {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv4Ospf {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv4Rip {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv4Static {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv6 {
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterListDataVrfRibFilterIpv6Bgp;
    /**
     * Ospfv3
     */
    ospfv3: outputs.GetLogicalRouterListDataVrfRibFilterIpv6Ospfv3;
    /**
     * Static
     */
    static: outputs.GetLogicalRouterListDataVrfRibFilterIpv6Static;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv6Bgp {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv6Ospfv3 {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRibFilterIpv6Static {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterListDataVrfRip {
    /**
     * Auth profile
     */
    authProfile: string;
    /**
     * Default information originate
     */
    defaultInformationOriginate: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterListDataVrfRipGlobalBfd;
    /**
     * Global inbound distribute list
     */
    globalInboundDistributeList: outputs.GetLogicalRouterListDataVrfRipGlobalInboundDistributeList;
    /**
     * Global outbound distribute list
     */
    globalOutboundDistributeList: outputs.GetLogicalRouterListDataVrfRipGlobalOutboundDistributeList;
    /**
     * Global timer
     */
    globalTimer: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterListDataVrfRipInterface[];
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
}

export interface GetLogicalRouterListDataVrfRipGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfRipGlobalInboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
}

export interface GetLogicalRouterListDataVrfRipGlobalOutboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
}

export interface GetLogicalRouterListDataVrfRipInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfRipInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interface inbound distribute list
     */
    interfaceInboundDistributeList: outputs.GetLogicalRouterListDataVrfRipInterfaceInterfaceInboundDistributeList;
    /**
     * Interface outbound distribute list
     */
    interfaceOutboundDistributeList: outputs.GetLogicalRouterListDataVrfRipInterfaceInterfaceOutboundDistributeList;
    /**
     * Mode
     */
    mode: string;
    /**
     * Name
     */
    name: string;
    /**
     * Split horizon
     */
    splitHorizon: string;
}

export interface GetLogicalRouterListDataVrfRipInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfRipInterfaceInterfaceInboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterListDataVrfRipInterfaceInterfaceOutboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterListDataVrfRoutingTable {
    /**
     * Ip
     */
    ip: outputs.GetLogicalRouterListDataVrfRoutingTableIp;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6;
}

export interface GetLogicalRouterListDataVrfRoutingTableIp {
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRoute[];
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRoute {
    /**
     * Admin dist
     */
    adminDist: number;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteBfd;
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthop;
    /**
     * Path monitor
     */
    pathMonitor: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTable;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthop {
    /**
     * Discard
     */
    discard: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn: string;
    /**
     * Ip address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipAddress: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthopDiscard {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteNexthopReceive {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRoutePathMonitor {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Failure condition
     */
    failureCondition: string;
    /**
     * Hold time
     */
    holdTime: number;
    /**
     * Monitor destinations
     */
    monitorDestinations: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination[];
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count: number;
    /**
     * Destination
     */
    destination: string;
    /**
     * Destination fqdn
     */
    destinationFqdn: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interval
     */
    interval: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTable {
    /**
     * Both
     */
    both: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableBoth;
    /**
     * Multicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    multicast: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableMulticast;
    /**
     * No install
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    noInstall: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableNoInstall;
    /**
     * Unicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    unicast: outputs.GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableUnicast;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableBoth {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableMulticast {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableNoInstall {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpStaticRouteRouteTableUnicast {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6 {
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoute[];
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoute {
    /**
     * Admin dist
     */
    adminDist: number;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteBfd;
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthop;
    /**
     * Option
     */
    option: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteOption;
    /**
     * Path monitor
     */
    pathMonitor: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTable;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthop {
    /**
     * Discard
     */
    discard: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthopDiscard {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteNexthopReceive {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteOption {
    /**
     * Passive
     */
    passive: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteOptionPassive;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteOptionPassive {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoutePathMonitor {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Failure condition
     */
    failureCondition: string;
    /**
     * Hold time
     */
    holdTime: number;
    /**
     * Monitor destinations
     */
    monitorDestinations: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination[];
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count: number;
    /**
     * Destination
     */
    destination: string;
    /**
     * Destination fqdn
     */
    destinationFqdn: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interval
     */
    interval: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: string;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTable {
    /**
     * Both
     */
    both: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableBoth;
    /**
     * Multicast
     */
    multicast: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableMulticast;
    /**
     * No install
     */
    noInstall: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableNoInstall;
    /**
     * Unicast
     */
    unicast: outputs.GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableUnicast;
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableBoth {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableMulticast {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableNoInstall {
}

export interface GetLogicalRouterListDataVrfRoutingTableIpv6StaticRouteRouteTableUnicast {
}

export interface GetLogicalRouterListDataVrfVrAdminDists {
    /**
     * Ebgp
     */
    ebgp: number;
    /**
     * Ibgp
     */
    ibgp: number;
    /**
     * Ospf ext
     */
    ospfExt: number;
    /**
     * Ospf int
     */
    ospfInt: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext: number;
    /**
     * Ospfv3 int
     */
    ospfv3Int: number;
    /**
     * Rip
     */
    rip: number;
    /**
     * Static
     */
    static: number;
    /**
     * Static ipv6
     */
    staticIpv6: number;
}

export interface GetLogicalRouterVrf {
    /**
     * Admin dists
     */
    adminDists: outputs.GetLogicalRouterVrfAdminDists;
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterVrfBgp;
    /**
     * Ecmp
     */
    ecmp: outputs.GetLogicalRouterVrfEcmp;
    /**
     * Global vrid
     */
    globalVrid: number;
    /**
     * Interface
     */
    interfaces: string[];
    /**
     * Multicast
     */
    multicast: outputs.GetLogicalRouterVrfMulticast;
    /**
     * Name
     */
    name: string;
    /**
     * Ospf
     */
    ospf: outputs.GetLogicalRouterVrfOspf;
    /**
     * Ospfv3
     */
    ospfv3: outputs.GetLogicalRouterVrfOspfv3;
    /**
     * Rib filter
     */
    ribFilter: outputs.GetLogicalRouterVrfRibFilter;
    /**
     * Rip
     */
    rip: outputs.GetLogicalRouterVrfRip;
    /**
     * Routing table
     */
    routingTable: outputs.GetLogicalRouterVrfRoutingTable;
    /**
     * Sdwan type
     */
    sdwanType: string;
    /**
     * Vr admin dists
     */
    vrAdminDists: outputs.GetLogicalRouterVrfVrAdminDists;
    /**
     * Zone name
     */
    zoneName: string;
}

export interface GetLogicalRouterVrfAdminDists {
    /**
     * Bgp external
     */
    bgpExternal: number;
    /**
     * Bgp internal
     */
    bgpInternal: number;
    /**
     * Bgp local
     */
    bgpLocal: number;
    /**
     * Ospf ext
     */
    ospfExt: number;
    /**
     * Ospf inter
     */
    ospfInter: number;
    /**
     * Ospf intra
     */
    ospfIntra: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext: number;
    /**
     * Ospfv3 inter
     */
    ospfv3Inter: number;
    /**
     * Ospfv3 intra
     */
    ospfv3Intra: number;
    /**
     * Rip
     */
    rip: number;
    /**
     * Static
     */
    static: number;
    /**
     * Static ipv6
     */
    staticIpv6: number;
}

export interface GetLogicalRouterVrfBgp {
    /**
     * Advertise network
     */
    advertiseNetwork: outputs.GetLogicalRouterVrfBgpAdvertiseNetwork;
    /**
     * Aggregate
     */
    aggregate: outputs.GetLogicalRouterVrfBgpAggregate;
    /**
     * Aggregate routes
     */
    aggregateRoutes: outputs.GetLogicalRouterVrfBgpAggregateRoute[];
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Always advertise network route
     */
    alwaysAdvertiseNetworkRoute: boolean;
    /**
     * As format
     */
    asFormat: string;
    /**
     * Confederation member as
     */
    confederationMemberAs: string;
    /**
     * Default local preference
     */
    defaultLocalPreference: number;
    /**
     * Ecmp multi as
     */
    ecmpMultiAs: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enforce first as
     */
    enforceFirstAs: boolean;
    /**
     * Fast external failover
     */
    fastExternalFailover: boolean;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterVrfBgpGlobalBfd;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterVrfBgpGracefulRestart;
    /**
     * Graceful shutdown
     */
    gracefulShutdown: boolean;
    /**
     * Install route
     */
    installRoute: boolean;
    /**
     * Local as
     */
    localAs: string;
    /**
     * Med
     */
    med: outputs.GetLogicalRouterVrfBgpMed;
    /**
     * Peer group
     */
    peerGroups: outputs.GetLogicalRouterVrfBgpPeerGroup[];
    /**
     * Policy
     */
    policy: outputs.GetLogicalRouterVrfBgpPolicy;
    /**
     * Redist rules
     */
    redistRules: outputs.GetLogicalRouterVrfBgpRedistRule[];
    /**
     * Redistribution profile
     */
    redistributionProfile: outputs.GetLogicalRouterVrfBgpRedistributionProfile;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Router id
     */
    routerId: string;
}

export interface GetLogicalRouterVrfBgpAdvertiseNetwork {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterVrfBgpAdvertiseNetworkIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterVrfBgpAdvertiseNetworkIpv6;
}

export interface GetLogicalRouterVrfBgpAdvertiseNetworkIpv4 {
    /**
     * Network
     */
    networks: outputs.GetLogicalRouterVrfBgpAdvertiseNetworkIpv4Network[];
}

export interface GetLogicalRouterVrfBgpAdvertiseNetworkIpv4Network {
    /**
     * Backdoor
     */
    backdoor: boolean;
    /**
     * Multicast
     */
    multicast: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterVrfBgpAdvertiseNetworkIpv6 {
    /**
     * Network
     */
    networks: outputs.GetLogicalRouterVrfBgpAdvertiseNetworkIpv6Network[];
}

export interface GetLogicalRouterVrfBgpAdvertiseNetworkIpv6Network {
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterVrfBgpAggregate {
    /**
     * Aggregate med
     */
    aggregateMed: boolean;
}

export interface GetLogicalRouterVrfBgpAggregateRoute {
    /**
     * As set
     */
    asSet: boolean;
    /**
     * Description
     */
    description: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Same med
     */
    sameMed: boolean;
    /**
     * Summary only
     */
    summaryOnly: boolean;
    /**
     * Type
     */
    type: outputs.GetLogicalRouterVrfBgpAggregateRouteType;
}

export interface GetLogicalRouterVrfBgpAggregateRouteType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterVrfBgpAggregateRouteTypeIpv4;
    /**
     * Ipv6
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4` and `ipv6`.
     */
    ipv6: outputs.GetLogicalRouterVrfBgpAggregateRouteTypeIpv6;
}

export interface GetLogicalRouterVrfBgpAggregateRouteTypeIpv4 {
    /**
     * Attribute map
     */
    attributeMap: string;
    /**
     * Summary prefix
     */
    summaryPrefix: string;
    /**
     * Suppress map
     */
    suppressMap: string;
}

export interface GetLogicalRouterVrfBgpAggregateRouteTypeIpv6 {
    /**
     * Attribute map
     */
    attributeMap: string;
    /**
     * Summary prefix
     */
    summaryPrefix: string;
    /**
     * Suppress map
     */
    suppressMap: string;
}

export interface GetLogicalRouterVrfBgpGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfBgpGracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Local restart time
     */
    localRestartTime: number;
    /**
     * Max peer restart time
     */
    maxPeerRestartTime: number;
    /**
     * Stale route time
     */
    staleRouteTime: number;
}

export interface GetLogicalRouterVrfBgpMed {
    /**
     * Always compare med
     */
    alwaysCompareMed: boolean;
    /**
     * Deterministic med comparison
     */
    deterministicMedComparison: boolean;
}

export interface GetLogicalRouterVrfBgpPeerGroup {
    /**
     * Address family
     */
    addressFamily: outputs.GetLogicalRouterVrfBgpPeerGroupAddressFamily;
    /**
     * Aggregated confed as path
     */
    aggregatedConfedAsPath: boolean;
    /**
     * Connection options
     */
    connectionOptions: outputs.GetLogicalRouterVrfBgpPeerGroupConnectionOptions;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Filtering profile
     */
    filteringProfile: outputs.GetLogicalRouterVrfBgpPeerGroupFilteringProfile;
    /**
     * Name
     */
    name: string;
    /**
     * Peer
     */
    peers: outputs.GetLogicalRouterVrfBgpPeerGroupPeer[];
    /**
     * Soft reset with stored info
     */
    softResetWithStoredInfo: boolean;
    /**
     * Type
     */
    type: outputs.GetLogicalRouterVrfBgpPeerGroupType;
}

export interface GetLogicalRouterVrfBgpPeerGroupAddressFamily {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupConnectionOptions {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Multihop
     */
    multihop: number;
    /**
     * Timers
     */
    timers: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupFilteringProfile {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeer {
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfBgpPeerGroupPeerBfd;
    /**
     * Connection options
     */
    connectionOptions: outputs.GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptions;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enable mp bgp
     */
    enableMpBgp: boolean;
    /**
     * Enable sender side loop detection
     */
    enableSenderSideLoopDetection: boolean;
    /**
     * Inherit
     */
    inherit: outputs.GetLogicalRouterVrfBgpPeerGroupPeerInherit;
    /**
     * Local address
     */
    localAddress: outputs.GetLogicalRouterVrfBgpPeerGroupPeerLocalAddress;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Peer address
     */
    peerAddress: outputs.GetLogicalRouterVrfBgpPeerGroupPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs: string;
    /**
     * Peering type
     */
    peeringType: string;
    /**
     * Reflector client
     */
    reflectorClient: string;
    /**
     * Subsequent address family identifier
     */
    subsequentAddressFamilyIdentifier: outputs.GetLogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerBfd {
    /**
     * Multihop
     */
    multihop: outputs.GetLogicalRouterVrfBgpPeerGroupPeerBfdMultihop;
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerBfdMultihop {
    /**
     * Min received ttl
     */
    minReceivedTtl: number;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptions {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Hold time
     */
    holdTime: string;
    /**
     * Idle hold time
     */
    idleHoldTime: number;
    /**
     * Incoming bgp connection
     */
    incomingBgpConnection: outputs.GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection;
    /**
     * Keep alive interval
     */
    keepAliveInterval: string;
    /**
     * Max prefixes
     */
    maxPrefixes: string;
    /**
     * Min route adv interval
     */
    minRouteAdvInterval: number;
    /**
     * Multihop
     */
    multihop: string;
    /**
     * Open delay time
     */
    openDelayTime: number;
    /**
     * Outgoing bgp connection
     */
    outgoingBgpConnection: outputs.GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection;
    /**
     * Timers
     */
    timers: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection {
    /**
     * Allow
     */
    allow: boolean;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection {
    /**
     * Allow
     */
    allow: boolean;
    /**
     * Local port
     */
    localPort: number;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerInherit {
    /**
     * No
     */
    no: outputs.GetLogicalRouterVrfBgpPeerGroupPeerInheritNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
     */
    yes: outputs.GetLogicalRouterVrfBgpPeerGroupPeerInheritYes;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerInheritNo {
    /**
     * Address family
     */
    addressFamily: outputs.GetLogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily;
    /**
     * Filtering profile
     */
    filteringProfile: outputs.GetLogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerInheritYes {
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerLocalAddress {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier {
    /**
     * Multicast
     */
    multicast: boolean;
    /**
     * Unicast
     */
    unicast: boolean;
}

export interface GetLogicalRouterVrfBgpPeerGroupType {
    /**
     * Ebgp
     */
    ebgp: outputs.GetLogicalRouterVrfBgpPeerGroupTypeEbgp;
    /**
     * Ebgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ebgpConfed: outputs.GetLogicalRouterVrfBgpPeerGroupTypeEbgpConfed;
    /**
     * Ibgp
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgp: outputs.GetLogicalRouterVrfBgpPeerGroupTypeIbgp;
    /**
     * Ibgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgpConfed: outputs.GetLogicalRouterVrfBgpPeerGroupTypeIbgpConfed;
}

export interface GetLogicalRouterVrfBgpPeerGroupTypeEbgp {
    /**
     * Export nexthop
     */
    exportNexthop: string;
    /**
     * Import nexthop
     */
    importNexthop: string;
    /**
     * Remove private as
     */
    removePrivateAs: boolean;
}

export interface GetLogicalRouterVrfBgpPeerGroupTypeEbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupTypeIbgp {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterVrfBgpPeerGroupTypeIbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop: string;
}

export interface GetLogicalRouterVrfBgpPolicy {
    /**
     * Aggregation
     */
    aggregation: outputs.GetLogicalRouterVrfBgpPolicyAggregation;
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisement;
    /**
     * Export
     */
    export: outputs.GetLogicalRouterVrfBgpPolicyExport;
    /**
     * Import
     */
    import: outputs.GetLogicalRouterVrfBgpPolicyImport;
}

export interface GetLogicalRouterVrfBgpPolicyAggregation {
    /**
     * Address
     */
    addresses: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddress[];
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddress {
    /**
     * Advertise filters
     */
    advertiseFilters: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilter[];
    /**
     * Aggregate route attributes
     */
    aggregateRouteAttributes: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes;
    /**
     * As set
     */
    asSet: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Prefix
     */
    prefix: string;
    /**
     * Summary
     */
    summary: boolean;
    /**
     * Suppress filters
     */
    suppressFilters: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilter[];
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisement {
    /**
     * Policy
     */
    policies: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy[];
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy {
    /**
     * Advertise filters
     */
    advertiseFilters: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter[];
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Non exist filters
     */
    nonExistFilters: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter[];
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyExport {
    /**
     * Rules
     */
    rules: outputs.GetLogicalRouterVrfBgpPolicyExportRule[];
}

export interface GetLogicalRouterVrfBgpPolicyExportRule {
    /**
     * Action
     */
    action: outputs.GetLogicalRouterVrfBgpPolicyExportRuleAction;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyExportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleAction {
    /**
     * Allow
     */
    allow: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionDeny;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllow {
    /**
     * Update
     */
    update: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdate;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleActionDeny {
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyExportRuleMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyExportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyImport {
    /**
     * Rules
     */
    rules: outputs.GetLogicalRouterVrfBgpPolicyImportRule[];
}

export interface GetLogicalRouterVrfBgpPolicyImportRule {
    /**
     * Action
     */
    action: outputs.GetLogicalRouterVrfBgpPolicyImportRuleAction;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Match
     */
    match: outputs.GetLogicalRouterVrfBgpPolicyImportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies: string[];
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleAction {
    /**
     * Allow
     */
    allow: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionDeny;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllow {
    /**
     * Dampening
     */
    dampening: string;
    /**
     * Update
     */
    update: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdate;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit: number;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference: number;
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthop: string;
    /**
     * Origin
     */
    origin: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend: number;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll: outputs.GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleActionDeny {
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes: outputs.GetLogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi: string;
    /**
     * As path
     */
    asPath: outputs.GetLogicalRouterVrfBgpPolicyImportRuleMatchAsPath;
    /**
     * Community
     */
    community: outputs.GetLogicalRouterVrfBgpPolicyImportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity: outputs.GetLogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers: string[];
    /**
     * Med
     */
    med: number;
    /**
     * Nexthop
     */
    nexthops: string[];
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Safi
     */
    safi: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleMatchAsPath {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleMatchCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex: string;
}

export interface GetLogicalRouterVrfBgpRedistRule {
    /**
     * Address family identifier
     */
    addressFamilyIdentifier: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Route table
     */
    routeTable: string;
    /**
     * Set as path limit
     */
    setAsPathLimit: number;
    /**
     * Set community
     */
    setCommunities: string[];
    /**
     * Set extended community
     */
    setExtendedCommunities: string[];
    /**
     * Set local preference
     */
    setLocalPreference: number;
    /**
     * Set med
     */
    setMed: number;
    /**
     * Set origin
     */
    setOrigin: string;
}

export interface GetLogicalRouterVrfBgpRedistributionProfile {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterVrfBgpRedistributionProfileIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterVrfBgpRedistributionProfileIpv6;
}

export interface GetLogicalRouterVrfBgpRedistributionProfileIpv4 {
    /**
     * Unicast
     */
    unicast: string;
}

export interface GetLogicalRouterVrfBgpRedistributionProfileIpv6 {
    /**
     * Unicast
     */
    unicast: string;
}

export interface GetLogicalRouterVrfEcmp {
    /**
     * Algorithm
     */
    algorithm: outputs.GetLogicalRouterVrfEcmpAlgorithm;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max path
     */
    maxPath: number;
    /**
     * Strict source path
     */
    strictSourcePath: boolean;
    /**
     * Symmetric return
     */
    symmetricReturn: boolean;
}

export interface GetLogicalRouterVrfEcmpAlgorithm {
    /**
     * Balanced round robin
     */
    balancedRoundRobin: outputs.GetLogicalRouterVrfEcmpAlgorithmBalancedRoundRobin;
    /**
     * Ip hash
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipHash: outputs.GetLogicalRouterVrfEcmpAlgorithmIpHash;
    /**
     * Ip modulo
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipModulo: outputs.GetLogicalRouterVrfEcmpAlgorithmIpModulo;
    /**
     * Weighted round robin
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    weightedRoundRobin: outputs.GetLogicalRouterVrfEcmpAlgorithmWeightedRoundRobin;
}

export interface GetLogicalRouterVrfEcmpAlgorithmBalancedRoundRobin {
}

export interface GetLogicalRouterVrfEcmpAlgorithmIpHash {
    /**
     * Hash seed
     */
    hashSeed: number;
    /**
     * Src only
     */
    srcOnly: boolean;
    /**
     * Use port
     */
    usePort: boolean;
}

export interface GetLogicalRouterVrfEcmpAlgorithmIpModulo {
}

export interface GetLogicalRouterVrfEcmpAlgorithmWeightedRoundRobin {
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface[];
}

export interface GetLogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface {
    /**
     * Name
     */
    name: string;
    /**
     * Weight
     */
    weight: number;
}

export interface GetLogicalRouterVrfMulticast {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Enable v6
     */
    enableV6: boolean;
    /**
     * Igmp
     */
    igmp: outputs.GetLogicalRouterVrfMulticastIgmp;
    /**
     * Interface group
     */
    interfaceGroups: outputs.GetLogicalRouterVrfMulticastInterfaceGroup[];
    /**
     * Mode
     */
    mode: string;
    /**
     * Msdp
     */
    msdp: outputs.GetLogicalRouterVrfMulticastMsdp;
    /**
     * Pim
     */
    pim: outputs.GetLogicalRouterVrfMulticastPim;
    /**
     * Route ageout time
     */
    routeAgeoutTime: number;
    /**
     * Rp
     */
    rp: outputs.GetLogicalRouterVrfMulticastRp;
    /**
     * Spt threshold
     */
    sptThresholds: outputs.GetLogicalRouterVrfMulticastSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpaces: outputs.GetLogicalRouterVrfMulticastSsmAddressSpace[];
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterVrfMulticastStaticRoute[];
}

export interface GetLogicalRouterVrfMulticastIgmp {
    /**
     * Dynamic
     */
    dynamic: outputs.GetLogicalRouterVrfMulticastIgmpDynamic;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Static
     */
    statics: outputs.GetLogicalRouterVrfMulticastIgmpStatic[];
}

export interface GetLogicalRouterVrfMulticastIgmpDynamic {
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfMulticastIgmpDynamicInterface[];
}

export interface GetLogicalRouterVrfMulticastIgmpDynamicInterface {
    /**
     * Group filter
     */
    groupFilter: string;
    /**
     * Max groups
     */
    maxGroups: string;
    /**
     * Max sources
     */
    maxSources: string;
    /**
     * Name
     */
    name: string;
    /**
     * Query profile
     */
    queryProfile: string;
    /**
     * Robustness
     */
    robustness: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing: boolean;
    /**
     * Version
     */
    version: string;
}

export interface GetLogicalRouterVrfMulticastIgmpStatic {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroup {
    /**
     * Description
     */
    description: string;
    /**
     * Group permission
     */
    groupPermission: outputs.GetLogicalRouterVrfMulticastInterfaceGroupGroupPermission;
    /**
     * Igmp
     */
    igmp: outputs.GetLogicalRouterVrfMulticastInterfaceGroupIgmp;
    /**
     * Interface
     */
    interfaces: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Pim
     */
    pim: outputs.GetLogicalRouterVrfMulticastInterfaceGroupPim;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupGroupPermission {
    /**
     * Any source multicast
     */
    anySourceMulticasts: outputs.GetLogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[];
    /**
     * Source specific multicast
     */
    sourceSpecificMulticasts: outputs.GetLogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[];
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress: string;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupIgmp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Immediate leave
     */
    immediateLeave: boolean;
    /**
     * Last member query interval
     */
    lastMemberQueryInterval: number;
    /**
     * Max groups
     */
    maxGroups: string;
    /**
     * Max query response time
     */
    maxQueryResponseTime: number;
    /**
     * Max sources
     */
    maxSources: string;
    /**
     * Mode
     */
    mode: string;
    /**
     * Query interval
     */
    queryInterval: number;
    /**
     * Robustness
     */
    robustness: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing: boolean;
    /**
     * Version
     */
    version: string;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupPim {
    /**
     * Allowed neighbors
     */
    allowedNeighbors: outputs.GetLogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbor[];
    /**
     * Assert interval
     */
    assertInterval: number;
    /**
     * Bsr border
     */
    bsrBorder: boolean;
    /**
     * Dr priority
     */
    drPriority: number;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Join prune interval
     */
    joinPruneInterval: number;
}

export interface GetLogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfMulticastMsdp {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Global authentication
     */
    globalAuthentication: string;
    /**
     * Global timer
     */
    globalTimer: string;
    /**
     * Originator id
     */
    originatorId: outputs.GetLogicalRouterVrfMulticastMsdpOriginatorId;
    /**
     * Peer
     */
    peers: outputs.GetLogicalRouterVrfMulticastMsdpPeer[];
}

export interface GetLogicalRouterVrfMulticastMsdpOriginatorId {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterVrfMulticastMsdpPeer {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Inbound sa filter
     */
    inboundSaFilter: string;
    /**
     * Local address
     */
    localAddress: outputs.GetLogicalRouterVrfMulticastMsdpPeerLocalAddress;
    /**
     * Max sa
     */
    maxSa: number;
    /**
     * Name
     */
    name: string;
    /**
     * Outbound sa filter
     */
    outboundSaFilter: string;
    /**
     * Peer address
     */
    peerAddress: outputs.GetLogicalRouterVrfMulticastMsdpPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs: string;
}

export interface GetLogicalRouterVrfMulticastMsdpPeerLocalAddress {
    /**
     * Interface
     */
    interface: string;
    /**
     * Ip
     */
    ip: string;
}

export interface GetLogicalRouterVrfMulticastMsdpPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip: string;
}

export interface GetLogicalRouterVrfMulticastPim {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Group permission
     */
    groupPermission: string;
    /**
     * If timer global
     */
    ifTimerGlobal: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfMulticastPimInterface[];
    /**
     * Route ageout time
     */
    routeAgeoutTime: number;
    /**
     * Rp
     */
    rp: outputs.GetLogicalRouterVrfMulticastPimRp;
    /**
     * Rpf lookup mode
     */
    rpfLookupMode: string;
    /**
     * Spt threshold
     */
    sptThresholds: outputs.GetLogicalRouterVrfMulticastPimSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpace: outputs.GetLogicalRouterVrfMulticastPimSsmAddressSpace;
}

export interface GetLogicalRouterVrfMulticastPimInterface {
    /**
     * Description
     */
    description: string;
    /**
     * Dr priority
     */
    drPriority: number;
    /**
     * If timer
     */
    ifTimer: string;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor filter
     */
    neighborFilter: string;
    /**
     * Send bsm
     */
    sendBsm: boolean;
}

export interface GetLogicalRouterVrfMulticastPimRp {
    /**
     * External rp
     */
    externalRps: outputs.GetLogicalRouterVrfMulticastPimRpExternalRp[];
    /**
     * Local rp
     */
    localRp: outputs.GetLogicalRouterVrfMulticastPimRpLocalRp;
}

export interface GetLogicalRouterVrfMulticastPimRpExternalRp {
    /**
     * Group list
     */
    groupList: string;
    /**
     * Name
     */
    name: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterVrfMulticastPimRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp: outputs.GetLogicalRouterVrfMulticastPimRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp: outputs.GetLogicalRouterVrfMulticastPimRpLocalRpStaticRp;
}

export interface GetLogicalRouterVrfMulticastPimRpLocalRpCandidateRp {
    /**
     * Address
     */
    address: string;
    /**
     * Advertisement interval
     */
    advertisementInterval: number;
    /**
     * Group list
     */
    groupList: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterVrfMulticastPimRpLocalRpStaticRp {
    /**
     * Address
     */
    address: string;
    /**
     * Group list
     */
    groupList: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterVrfMulticastPimSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold: string;
}

export interface GetLogicalRouterVrfMulticastPimSsmAddressSpace {
    /**
     * Group list
     */
    groupList: string;
}

export interface GetLogicalRouterVrfMulticastRp {
    /**
     * External rp
     */
    externalRps: outputs.GetLogicalRouterVrfMulticastRpExternalRp[];
    /**
     * Local rp
     */
    localRp: outputs.GetLogicalRouterVrfMulticastRpLocalRp;
}

export interface GetLogicalRouterVrfMulticastRpExternalRp {
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterVrfMulticastRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp: outputs.GetLogicalRouterVrfMulticastRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp: outputs.GetLogicalRouterVrfMulticastRpLocalRpStaticRp;
}

export interface GetLogicalRouterVrfMulticastRpLocalRpCandidateRp {
    /**
     * Address
     */
    address: string;
    /**
     * Advertisement interval
     */
    advertisementInterval: number;
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Interface
     */
    interface: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterVrfMulticastRpLocalRpStaticRp {
    /**
     * Address
     */
    address: string;
    /**
     * Group addresses
     */
    groupAddresses: string[];
    /**
     * Interface
     */
    interface: string;
    /**
     * Override
     */
    override: boolean;
}

export interface GetLogicalRouterVrfMulticastSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold: string;
}

export interface GetLogicalRouterVrfMulticastSsmAddressSpace {
    /**
     * Group address
     */
    groupAddress: string;
    /**
     * Included
     */
    included: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfMulticastStaticRoute {
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterVrfMulticastStaticRouteNexthop;
    /**
     * Preference
     */
    preference: number;
}

export interface GetLogicalRouterVrfMulticastStaticRouteNexthop {
    /**
     * Ip address
     */
    ipAddress: string;
}

export interface GetLogicalRouterVrfOspf {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Area
     */
    areas: outputs.GetLogicalRouterVrfOspfArea[];
    /**
     * Auth profile
     */
    authProfiles: outputs.GetLogicalRouterVrfOspfAuthProfile[];
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Export rules
     */
    exportRules: outputs.GetLogicalRouterVrfOspfExportRule[];
    /**
     * Flood prevention
     */
    floodPrevention: outputs.GetLogicalRouterVrfOspfFloodPrevention;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterVrfOspfGlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer: string;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterVrfOspfGracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Rfc1583
     */
    rfc1583: boolean;
    /**
     * Router id
     */
    routerId: string;
    /**
     * Spf timer
     */
    spfTimer: string;
    /**
     * Vr timers
     */
    vrTimers: outputs.GetLogicalRouterVrfOspfVrTimers;
}

export interface GetLogicalRouterVrfOspfArea {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfOspfAreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges: outputs.GetLogicalRouterVrfOspfAreaRange[];
    /**
     * Type
     */
    type: outputs.GetLogicalRouterVrfOspfAreaType;
    /**
     * Virtual link
     */
    virtualLinks: outputs.GetLogicalRouterVrfOspfAreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges: outputs.GetLogicalRouterVrfOspfAreaVrRange[];
}

export interface GetLogicalRouterVrfOspfAreaInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfOspfAreaInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Link type
     */
    linkType: outputs.GetLogicalRouterVrfOspfAreaInterfaceLinkType;
    /**
     * Metric
     */
    metric: number;
    /**
     * Mtu ignore
     */
    mtuIgnore: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Priority
     */
    priority: number;
    /**
     * Timing
     */
    timing: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterVrfOspfAreaInterfaceVrTiming;
}

export interface GetLogicalRouterVrfOspfAreaInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfAreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast: outputs.GetLogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp: outputs.GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p: outputs.GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2p;
}

export interface GetLogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast {
}

export interface GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterVrfOspfAreaInterfaceLinkTypeP2p {
}

export interface GetLogicalRouterVrfOspfAreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Gr delay
     */
    grDelay: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterVrfOspfAreaRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Substitute
     */
    substitute: string;
}

export interface GetLogicalRouterVrfOspfAreaType {
    /**
     * Normal
     */
    normal: outputs.GetLogicalRouterVrfOspfAreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa: outputs.GetLogicalRouterVrfOspfAreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub: outputs.GetLogicalRouterVrfOspfAreaTypeStub;
}

export interface GetLogicalRouterVrfOspfAreaTypeNormal {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfAreaTypeNormalAbr;
}

export interface GetLogicalRouterVrfOspfAreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssa {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfAreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate: outputs.GetLogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterVrfOspfAreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRange[];
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric: number;
    /**
     * Metric type
     */
    metricType: string;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisable;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
    /**
     * Type
     */
    type: string;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisable {
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppress;
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertise {
}

export interface GetLogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppress {
}

export interface GetLogicalRouterVrfOspfAreaTypeStub {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfAreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterVrfOspfAreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric: number;
    /**
     * No summary
     */
    noSummary: boolean;
}

export interface GetLogicalRouterVrfOspfAreaTypeStubAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfAreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterVrfOspfAreaTypeStubDefaultRouteDisable;
}

export interface GetLogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterVrfOspfAreaTypeStubDefaultRouteDisable {
}

export interface GetLogicalRouterVrfOspfAreaVirtualLink {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfOspfAreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Interface id
     */
    interfaceId: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Timing
     */
    timing: string;
    /**
     * Transit area id
     */
    transitAreaId: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterVrfOspfAreaVirtualLinkVrTiming;
}

export interface GetLogicalRouterVrfOspfAreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfAreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterVrfOspfAreaVrRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfAreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterVrfOspfAreaVrRangeSuppress;
}

export interface GetLogicalRouterVrfOspfAreaVrRangeAdvertise {
}

export interface GetLogicalRouterVrfOspfAreaVrRangeSuppress {
}

export interface GetLogicalRouterVrfOspfAuthProfile {
    /**
     * Md5
     */
    md5s: outputs.GetLogicalRouterVrfOspfAuthProfileMd5[];
    /**
     * Name
     */
    name: string;
    /**
     * Password
     */
    password: string;
}

export interface GetLogicalRouterVrfOspfAuthProfileMd5 {
    /**
     * Key
     */
    key: string;
    /**
     * Name
     */
    name: number;
    /**
     * Preferred
     */
    preferred: boolean;
}

export interface GetLogicalRouterVrfOspfExportRule {
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType: string;
    /**
     * New tag
     */
    newTag: string;
}

export interface GetLogicalRouterVrfOspfFloodPrevention {
    /**
     * Hello
     */
    hello: outputs.GetLogicalRouterVrfOspfFloodPreventionHello;
    /**
     * Lsa
     */
    lsa: outputs.GetLogicalRouterVrfOspfFloodPreventionLsa;
}

export interface GetLogicalRouterVrfOspfFloodPreventionHello {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max packet
     */
    maxPacket: number;
}

export interface GetLogicalRouterVrfOspfFloodPreventionLsa {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Max packet
     */
    maxPacket: number;
}

export interface GetLogicalRouterVrfOspfGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfGracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Grace period
     */
    gracePeriod: number;
    /**
     * Helper enable
     */
    helperEnable: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking: boolean;
}

export interface GetLogicalRouterVrfOspfVrTimers {
    /**
     * Lsa interval
     */
    lsaInterval: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay: number;
}

export interface GetLogicalRouterVrfOspfv3 {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute: boolean;
    /**
     * Area
     */
    areas: outputs.GetLogicalRouterVrfOspfv3Area[];
    /**
     * Auth profile
     */
    authProfiles: outputs.GetLogicalRouterVrfOspfv3AuthProfile[];
    /**
     * Disable transit traffic
     */
    disableTransitTraffic: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Export rules
     */
    exportRules: outputs.GetLogicalRouterVrfOspfv3ExportRule[];
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterVrfOspfv3GlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer: string;
    /**
     * Graceful restart
     */
    gracefulRestart: outputs.GetLogicalRouterVrfOspfv3GracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute: boolean;
    /**
     * Router id
     */
    routerId: string;
    /**
     * Spf timer
     */
    spfTimer: string;
    /**
     * Vr timers
     */
    vrTimers: outputs.GetLogicalRouterVrfOspfv3VrTimers;
}

export interface GetLogicalRouterVrfOspfv3Area {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfOspfv3AreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges: outputs.GetLogicalRouterVrfOspfv3AreaRange[];
    /**
     * Type
     */
    type: outputs.GetLogicalRouterVrfOspfv3AreaType;
    /**
     * Virtual link
     */
    virtualLinks: outputs.GetLogicalRouterVrfOspfv3AreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges: outputs.GetLogicalRouterVrfOspfv3AreaVrRange[];
}

export interface GetLogicalRouterVrfOspfv3AreaInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Link type
     */
    linkType: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceLinkType;
    /**
     * Metric
     */
    metric: number;
    /**
     * Mtu ignore
     */
    mtuIgnore: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceNeighbor[];
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Priority
     */
    priority: number;
    /**
     * Timing
     */
    timing: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceVrTiming;
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2p;
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcast {
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors: outputs.GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority: number;
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2p {
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfOspfv3AreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Gr delay
     */
    grDelay: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterVrfOspfv3AreaRange {
    /**
     * Advertise
     */
    advertise: boolean;
    /**
     * Name
     */
    name: string;
}

export interface GetLogicalRouterVrfOspfv3AreaType {
    /**
     * Normal
     */
    normal: outputs.GetLogicalRouterVrfOspfv3AreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub: outputs.GetLogicalRouterVrfOspfv3AreaTypeStub;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNormal {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfv3AreaTypeNormalAbr;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssa {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRange[];
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise {
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress {
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric: number;
    /**
     * Metric type
     */
    metricType: string;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisable;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
    /**
     * Type
     */
    type: string;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisable {
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag: number;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppress;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise {
}

export interface GetLogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppress {
}

export interface GetLogicalRouterVrfOspfv3AreaTypeStub {
    /**
     * Abr
     */
    abr: outputs.GetLogicalRouterVrfOspfv3AreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary: boolean;
    /**
     * Default route
     */
    defaultRoute: outputs.GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric: number;
    /**
     * No summary
     */
    noSummary: boolean;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeStubAbr {
    /**
     * Export list
     */
    exportList: string;
    /**
     * Import list
     */
    importList: string;
    /**
     * Inbound filter list
     */
    inboundFilterList: string;
    /**
     * Outbound filter list
     */
    outboundFilterList: string;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable: outputs.GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisable;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisable {
}

export interface GetLogicalRouterVrfOspfv3AreaVirtualLink {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfOspfv3AreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Instance id
     */
    instanceId: number;
    /**
     * Interface id
     */
    interfaceId: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId: string;
    /**
     * Passive
     */
    passive: boolean;
    /**
     * Timing
     */
    timing: string;
    /**
     * Transit area id
     */
    transitAreaId: string;
    /**
     * Vr timing
     */
    vrTiming: outputs.GetLogicalRouterVrfOspfv3AreaVirtualLinkVrTiming;
}

export interface GetLogicalRouterVrfOspfv3AreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfv3AreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts: number;
    /**
     * Hello interval
     */
    helloInterval: number;
    /**
     * Retransmit interval
     */
    retransmitInterval: number;
    /**
     * Transit delay
     */
    transitDelay: number;
}

export interface GetLogicalRouterVrfOspfv3AreaVrRange {
    /**
     * Advertise
     */
    advertise: outputs.GetLogicalRouterVrfOspfv3AreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress: outputs.GetLogicalRouterVrfOspfv3AreaVrRangeSuppress;
}

export interface GetLogicalRouterVrfOspfv3AreaVrRangeAdvertise {
}

export interface GetLogicalRouterVrfOspfv3AreaVrRangeSuppress {
}

export interface GetLogicalRouterVrfOspfv3AuthProfile {
    /**
     * Ah
     */
    ah: outputs.GetLogicalRouterVrfOspfv3AuthProfileAh;
    /**
     * Esp
     */
    esp: outputs.GetLogicalRouterVrfOspfv3AuthProfileEsp;
    /**
     * Name
     */
    name: string;
    /**
     * Spi
     */
    spi: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAh {
    /**
     * Md5
     */
    md5: outputs.GetLogicalRouterVrfOspfv3AuthProfileAhMd5;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1: outputs.GetLogicalRouterVrfOspfv3AuthProfileAhSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256: outputs.GetLogicalRouterVrfOspfv3AuthProfileAhSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384: outputs.GetLogicalRouterVrfOspfv3AuthProfileAhSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512: outputs.GetLogicalRouterVrfOspfv3AuthProfileAhSha512;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAhMd5 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAhSha1 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAhSha256 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAhSha384 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileAhSha512 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEsp {
    /**
     * Authentication
     */
    authentication: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthentication;
    /**
     * Encryption
     */
    encryption: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspEncryption;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthentication {
    /**
     * Md5
     */
    md5: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    none: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationNone;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512: outputs.GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationNone {
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512 {
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3AuthProfileEspEncryption {
    /**
     * Algorithm
     */
    algorithm: string;
    /**
     * Key
     */
    key: string;
}

export interface GetLogicalRouterVrfOspfv3ExportRule {
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType: string;
    /**
     * New tag
     */
    newTag: string;
}

export interface GetLogicalRouterVrfOspfv3GlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfOspfv3GracefulRestart {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Grace period
     */
    gracePeriod: number;
    /**
     * Helper enable
     */
    helperEnable: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking: boolean;
}

export interface GetLogicalRouterVrfOspfv3VrTimers {
    /**
     * Lsa interval
     */
    lsaInterval: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay: number;
}

export interface GetLogicalRouterVrfRibFilter {
    /**
     * Ipv4
     */
    ipv4: outputs.GetLogicalRouterVrfRibFilterIpv4;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterVrfRibFilterIpv6;
}

export interface GetLogicalRouterVrfRibFilterIpv4 {
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterVrfRibFilterIpv4Bgp;
    /**
     * Ospf
     */
    ospf: outputs.GetLogicalRouterVrfRibFilterIpv4Ospf;
    /**
     * Rip
     */
    rip: outputs.GetLogicalRouterVrfRibFilterIpv4Rip;
    /**
     * Static
     */
    static: outputs.GetLogicalRouterVrfRibFilterIpv4Static;
}

export interface GetLogicalRouterVrfRibFilterIpv4Bgp {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv4Ospf {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv4Rip {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv4Static {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv6 {
    /**
     * Bgp
     */
    bgp: outputs.GetLogicalRouterVrfRibFilterIpv6Bgp;
    /**
     * Ospfv3
     */
    ospfv3: outputs.GetLogicalRouterVrfRibFilterIpv6Ospfv3;
    /**
     * Static
     */
    static: outputs.GetLogicalRouterVrfRibFilterIpv6Static;
}

export interface GetLogicalRouterVrfRibFilterIpv6Bgp {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv6Ospfv3 {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRibFilterIpv6Static {
    /**
     * Route map
     */
    routeMap: string;
}

export interface GetLogicalRouterVrfRip {
    /**
     * Auth profile
     */
    authProfile: string;
    /**
     * Default information originate
     */
    defaultInformationOriginate: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Global bfd
     */
    globalBfd: outputs.GetLogicalRouterVrfRipGlobalBfd;
    /**
     * Global inbound distribute list
     */
    globalInboundDistributeList: outputs.GetLogicalRouterVrfRipGlobalInboundDistributeList;
    /**
     * Global outbound distribute list
     */
    globalOutboundDistributeList: outputs.GetLogicalRouterVrfRipGlobalOutboundDistributeList;
    /**
     * Global timer
     */
    globalTimer: string;
    /**
     * Interface
     */
    interfaces: outputs.GetLogicalRouterVrfRipInterface[];
    /**
     * Redistribution profile
     */
    redistributionProfile: string;
}

export interface GetLogicalRouterVrfRipGlobalBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfRipGlobalInboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
}

export interface GetLogicalRouterVrfRipGlobalOutboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
}

export interface GetLogicalRouterVrfRipInterface {
    /**
     * Authentication
     */
    authentication: string;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfRipInterfaceBfd;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interface inbound distribute list
     */
    interfaceInboundDistributeList: outputs.GetLogicalRouterVrfRipInterfaceInterfaceInboundDistributeList;
    /**
     * Interface outbound distribute list
     */
    interfaceOutboundDistributeList: outputs.GetLogicalRouterVrfRipInterfaceInterfaceOutboundDistributeList;
    /**
     * Mode
     */
    mode: string;
    /**
     * Name
     */
    name: string;
    /**
     * Split horizon
     */
    splitHorizon: string;
}

export interface GetLogicalRouterVrfRipInterfaceBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfRipInterfaceInterfaceInboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterVrfRipInterfaceInterfaceOutboundDistributeList {
    /**
     * Access list
     */
    accessList: string;
    /**
     * Metric
     */
    metric: number;
}

export interface GetLogicalRouterVrfRoutingTable {
    /**
     * Ip
     */
    ip: outputs.GetLogicalRouterVrfRoutingTableIp;
    /**
     * Ipv6
     */
    ipv6: outputs.GetLogicalRouterVrfRoutingTableIpv6;
}

export interface GetLogicalRouterVrfRoutingTableIp {
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterVrfRoutingTableIpStaticRoute[];
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRoute {
    /**
     * Admin dist
     */
    adminDist: number;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteBfd;
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteNexthop;
    /**
     * Path monitor
     */
    pathMonitor: outputs.GetLogicalRouterVrfRoutingTableIpStaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTable;
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteNexthop {
    /**
     * Discard
     */
    discard: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn: string;
    /**
     * Ip address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipAddress: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel: string;
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscard {
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteNexthopReceive {
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRoutePathMonitor {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Failure condition
     */
    failureCondition: string;
    /**
     * Hold time
     */
    holdTime: number;
    /**
     * Monitor destinations
     */
    monitorDestinations: outputs.GetLogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination[];
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count: number;
    /**
     * Destination
     */
    destination: string;
    /**
     * Destination fqdn
     */
    destinationFqdn: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interval
     */
    interval: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: string;
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTable {
    /**
     * Both
     */
    both: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableBoth;
    /**
     * Multicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    multicast: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticast;
    /**
     * No install
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    noInstall: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstall;
    /**
     * Unicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    unicast: outputs.GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicast;
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableBoth {
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticast {
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstall {
}

export interface GetLogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicast {
}

export interface GetLogicalRouterVrfRoutingTableIpv6 {
    /**
     * Static route
     */
    staticRoutes: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRoute[];
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRoute {
    /**
     * Admin dist
     */
    adminDist: number;
    /**
     * Bfd
     */
    bfd: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteBfd;
    /**
     * Destination
     */
    destination: string;
    /**
     * Interface
     */
    interface: string;
    /**
     * Metric
     */
    metric: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthop;
    /**
     * Option
     */
    option: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteOption;
    /**
     * Path monitor
     */
    pathMonitor: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTable;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteBfd {
    /**
     * Profile
     */
    profile: string;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthop {
    /**
     * Discard
     */
    discard: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel: string;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscard {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceive {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteOption {
    /**
     * Passive
     */
    passive: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassive;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassive {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitor {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Failure condition
     */
    failureCondition: string;
    /**
     * Hold time
     */
    holdTime: number;
    /**
     * Monitor destinations
     */
    monitorDestinations: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination[];
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count: number;
    /**
     * Destination
     */
    destination: string;
    /**
     * Destination fqdn
     */
    destinationFqdn: string;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Interval
     */
    interval: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: string;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTable {
    /**
     * Both
     */
    both: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBoth;
    /**
     * Multicast
     */
    multicast: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticast;
    /**
     * No install
     */
    noInstall: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstall;
    /**
     * Unicast
     */
    unicast: outputs.GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicast;
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBoth {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticast {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstall {
}

export interface GetLogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicast {
}

export interface GetLogicalRouterVrfVrAdminDists {
    /**
     * Ebgp
     */
    ebgp: number;
    /**
     * Ibgp
     */
    ibgp: number;
    /**
     * Ospf ext
     */
    ospfExt: number;
    /**
     * Ospf int
     */
    ospfInt: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext: number;
    /**
     * Ospfv3 int
     */
    ospfv3Int: number;
    /**
     * Rip
     */
    rip: number;
    /**
     * Static
     */
    static: number;
    /**
     * Static ipv6
     */
    staticIpv6: number;
}

export interface GetLoopbackInterfaceIp {
    /**
     * Loopback IP address(es)
     */
    name: string;
}

export interface GetLoopbackInterfaceIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses: outputs.GetLoopbackInterfaceIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface GetLoopbackInterfaceIpv6Address {
    /**
     * Anycast
     */
    anycast: outputs.GetLoopbackInterfaceIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name: string;
    /**
     * Use interface ID as host portion
     */
    prefix: outputs.GetLoopbackInterfaceIpv6AddressPrefix;
}

export interface GetLoopbackInterfaceIpv6AddressAnycast {
}

export interface GetLoopbackInterfaceIpv6AddressPrefix {
}

export interface GetLoopbackInterfaceListData {
    /**
     * Description
     */
    comment: string;
    /**
     * Default interface assignment
     */
    defaultValue: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Loopback IP Parent
     */
    ips: outputs.GetLoopbackInterfaceListDataIp[];
    /**
     * Loopback IPv6 Configuration
     */
    ipv6: outputs.GetLoopbackInterfaceListDataIpv6;
    /**
     * MTU
     */
    mtu: number;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetLoopbackInterfaceListDataIp {
    /**
     * Loopback IP address(es)
     */
    name: string;
}

export interface GetLoopbackInterfaceListDataIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses: outputs.GetLoopbackInterfaceListDataIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface GetLoopbackInterfaceListDataIpv6Address {
    /**
     * Anycast
     */
    anycast: outputs.GetLoopbackInterfaceListDataIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name: string;
    /**
     * Use interface ID as host portion
     */
    prefix: outputs.GetLoopbackInterfaceListDataIpv6AddressPrefix;
}

export interface GetLoopbackInterfaceListDataIpv6AddressAnycast {
}

export interface GetLoopbackInterfaceListDataIpv6AddressPrefix {
}

export interface GetManagementInterfaceListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Management interface
     */
    managementInterface: outputs.GetManagementInterfaceListDataManagementInterface;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetManagementInterfaceListDataManagementInterface {
    /**
     * IP type
     */
    mgmtType: outputs.GetManagementInterfaceListDataManagementInterfaceMgmtType;
    /**
     * MTU
     */
    mtu: number;
    /**
     * Permitting IP addresses
     */
    permittedIps: outputs.GetManagementInterfaceListDataManagementInterfacePermittedIp[];
    /**
     * Network services
     */
    service: outputs.GetManagementInterfaceListDataManagementInterfaceService;
    /**
     * Speed and duplex
     */
    speedDuplex: string;
}

export interface GetManagementInterfaceListDataManagementInterfaceMgmtType {
    /**
     * Dhcp client
     */
    dhcpClient: outputs.GetManagementInterfaceListDataManagementInterfaceMgmtTypeDhcpClient;
    /**
     * Static
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `static`.
     */
    static: outputs.GetManagementInterfaceListDataManagementInterfaceMgmtTypeStatic;
}

export interface GetManagementInterfaceListDataManagementInterfaceMgmtTypeDhcpClient {
    /**
     * Accept DHCP server provided domain name
     */
    acceptDhcpDomain: boolean;
    /**
     * Accept DHCP server provided hostname
     */
    acceptDhcpHostname: boolean;
    /**
     * Send client ID
     */
    sendClientId: boolean;
    /**
     * Send hostname
     */
    sendHostname: boolean;
}

export interface GetManagementInterfaceListDataManagementInterfaceMgmtTypeStatic {
    /**
     * Default gateway
     */
    defaultGateway: string;
    /**
     * IP address
     */
    ipAddress: string;
    /**
     * Netmask
     */
    netmask: string;
}

export interface GetManagementInterfaceListDataManagementInterfacePermittedIp {
    /**
     * Description
     */
    description: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetManagementInterfaceListDataManagementInterfaceService {
    /**
     * HTTP
     */
    disableHttp: boolean;
    /**
     * HTTP OCSP
     */
    disableHttpOcsp: boolean;
    /**
     * HTTPS
     */
    disableHttps: boolean;
    /**
     * Ping
     */
    disableIcmp: boolean;
    /**
     * SNMP
     */
    disableSnmp: boolean;
    /**
     * SSH
     */
    disableSsh: boolean;
    /**
     * Telnet
     */
    disableTelnet: boolean;
    /**
     * User-ID
     */
    disableUseridService: boolean;
    /**
     * User-ID syslog listener over SSL
     */
    disableUseridSyslogListenerSsl: boolean;
    /**
     * User-ID syslog listener over UDP
     */
    disableUseridSyslogListenerUdp: boolean;
}

export interface GetManagementInterfaceManagementInterface {
    /**
     * IP type
     */
    mgmtType: outputs.GetManagementInterfaceManagementInterfaceMgmtType;
    /**
     * MTU
     */
    mtu: number;
    /**
     * Permitting IP addresses
     */
    permittedIps: outputs.GetManagementInterfaceManagementInterfacePermittedIp[];
    /**
     * Network services
     */
    service: outputs.GetManagementInterfaceManagementInterfaceService;
    /**
     * Speed and duplex
     */
    speedDuplex: string;
}

export interface GetManagementInterfaceManagementInterfaceMgmtType {
    /**
     * Dhcp client
     */
    dhcpClient: outputs.GetManagementInterfaceManagementInterfaceMgmtTypeDhcpClient;
    /**
     * Static
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `static`.
     */
    static: outputs.GetManagementInterfaceManagementInterfaceMgmtTypeStatic;
}

export interface GetManagementInterfaceManagementInterfaceMgmtTypeDhcpClient {
    /**
     * Accept DHCP server provided domain name
     */
    acceptDhcpDomain: boolean;
    /**
     * Accept DHCP server provided hostname
     */
    acceptDhcpHostname: boolean;
    /**
     * Send client ID
     */
    sendClientId: boolean;
    /**
     * Send hostname
     */
    sendHostname: boolean;
}

export interface GetManagementInterfaceManagementInterfaceMgmtTypeStatic {
    /**
     * Default gateway
     */
    defaultGateway: string;
    /**
     * IP address
     */
    ipAddress: string;
    /**
     * Netmask
     */
    netmask: string;
}

export interface GetManagementInterfaceManagementInterfacePermittedIp {
    /**
     * Description
     */
    description: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetManagementInterfaceManagementInterfaceService {
    /**
     * HTTP
     */
    disableHttp: boolean;
    /**
     * HTTP OCSP
     */
    disableHttpOcsp: boolean;
    /**
     * HTTPS
     */
    disableHttps: boolean;
    /**
     * Ping
     */
    disableIcmp: boolean;
    /**
     * SNMP
     */
    disableSnmp: boolean;
    /**
     * SSH
     */
    disableSsh: boolean;
    /**
     * Telnet
     */
    disableTelnet: boolean;
    /**
     * User-ID
     */
    disableUseridService: boolean;
    /**
     * User-ID syslog listener over SSL
     */
    disableUseridSyslogListenerSsl: boolean;
    /**
     * User-ID syslog listener over UDP
     */
    disableUseridSyslogListenerUdp: boolean;
}

export interface GetMotdBannerSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Motd and banner
     */
    motdAndBanner: outputs.GetMotdBannerSettingListDataMotdAndBanner;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetMotdBannerSettingListDataMotdAndBanner {
    /**
     * Banner footer
     */
    bannerFooter: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterColor: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterTextColor: string;
    /**
     * Banner header
     */
    bannerHeader: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderColor: string;
    /**
     * Banner header footer match
     */
    bannerHeaderFooterMatch: boolean;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderTextColor: string;
    /**
     * Message
     */
    message: string;
    /**
     * The following list details the supported values and their colors.
     */
    motdColor: string;
    /**
     * Motd do not display again
     */
    motdDoNotDisplayAgain: boolean;
    /**
     * Motd enable
     */
    motdEnable: boolean;
    /**
     * Motd title
     */
    motdTitle: string;
    /**
     * Severity
     */
    severity: string;
}

export interface GetMotdBannerSettingMotdAndBanner {
    /**
     * Banner footer
     */
    bannerFooter: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterColor: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterTextColor: string;
    /**
     * Banner header
     */
    bannerHeader: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderColor: string;
    /**
     * Banner header footer match
     */
    bannerHeaderFooterMatch: boolean;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderTextColor: string;
    /**
     * Message
     */
    message: string;
    /**
     * The following list details the supported values and their colors.
     */
    motdColor: string;
    /**
     * Motd do not display again
     */
    motdDoNotDisplayAgain: boolean;
    /**
     * Motd enable
     */
    motdEnable: boolean;
    /**
     * Motd title
     */
    motdTitle: string;
    /**
     * Severity
     */
    severity: string;
}

export interface GetNatRuleDestinationTranslation {
    /**
     * DNS rewrite
     */
    dnsRewrite: outputs.GetNatRuleDestinationTranslationDnsRewrite;
    /**
     * Translated destination IP address
     */
    translatedAddress: string;
    /**
     * Translated destination port
     */
    translatedPort: number;
}

export interface GetNatRuleDestinationTranslationDnsRewrite {
    /**
     * Direction
     */
    direction: string;
}

export interface GetNatRuleDynamicDestinationTranslation {
    /**
     * Distribution method
     */
    distribution: string;
    /**
     * Translated destination IP address
     */
    translatedAddress: string;
    /**
     * Translated destination port
     */
    translatedPort: number;
}

export interface GetNatRuleListData {
    /**
     * Active active device binding
     */
    activeActiveDeviceBinding: string;
    /**
     * NAT rule description
     */
    description: string;
    /**
     * Destination translation
     */
    destinationTranslation: outputs.GetNatRuleListDataDestinationTranslation;
    /**
     * Destination address(es) of the original packet
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Disable NAT rule?
     */
    disabled: boolean;
    /**
     * Dynamic destination translation
     */
    dynamicDestinationTranslation: outputs.GetNatRuleListDataDynamicDestinationTranslation;
    /**
     * The folder in which the resource is defined
     */
    folder: string;
    /**
     * Source zone(s) of the original packet
     */
    froms: string[];
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * NAT rule name
     */
    name: string;
    /**
     * NAT type
     */
    natType: string;
    /**
     * The relative position of the rule
     */
    position: string;
    /**
     * The service of the original packet
     */
    service: string;
    /**
     * The snippet in which the resource is defined
     */
    snippet: string;
    /**
     * Source translation
     */
    sourceTranslation: outputs.GetNatRuleListDataSourceTranslation;
    /**
     * Source address(es) of the original packet
     */
    sources: string[];
    /**
     * NAT rule tags
     */
    tags: string[];
    tfid: string;
    /**
     * Destination interface of the original packet
     */
    toInterface: string;
    /**
     * Destination zone of the original packet
     */
    tos: string[];
}

export interface GetNatRuleListDataDestinationTranslation {
    /**
     * DNS rewrite
     */
    dnsRewrite: outputs.GetNatRuleListDataDestinationTranslationDnsRewrite;
    /**
     * Translated destination IP address
     */
    translatedAddress: string;
    /**
     * Translated destination port
     */
    translatedPort: number;
}

export interface GetNatRuleListDataDestinationTranslationDnsRewrite {
    /**
     * Direction
     */
    direction: string;
}

export interface GetNatRuleListDataDynamicDestinationTranslation {
    /**
     * Distribution method
     */
    distribution: string;
    /**
     * Translated destination IP address
     */
    translatedAddress: string;
    /**
     * Translated destination port
     */
    translatedPort: number;
}

export interface GetNatRuleListDataSourceTranslation {
    /**
     * Dynamic IP
     */
    dynamicIp: outputs.GetNatRuleListDataSourceTranslationDynamicIp;
    /**
     * Dynamic IP and port
     */
    dynamicIpAndPort: outputs.GetNatRuleListDataSourceTranslationDynamicIpAndPort;
    /**
     * Static IP
     */
    staticIp: outputs.GetNatRuleListDataSourceTranslationStaticIp;
}

export interface GetNatRuleListDataSourceTranslationDynamicIp {
    /**
     * Fallback
     */
    fallback: outputs.GetNatRuleListDataSourceTranslationDynamicIpFallback;
    /**
     * Translated IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleListDataSourceTranslationDynamicIpAndPort {
    /**
     * Translated source interface
     */
    interfaceAddress: outputs.GetNatRuleListDataSourceTranslationDynamicIpAndPortInterfaceAddress;
    /**
     * Translated source IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleListDataSourceTranslationDynamicIpAndPortInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp: string;
    /**
     * Interface name
     */
    interface: string;
    /**
     * Translated source IP address
     */
    ip: string;
}

export interface GetNatRuleListDataSourceTranslationDynamicIpFallback {
    /**
     * Fallback interface
     */
    interfaceAddress: outputs.GetNatRuleListDataSourceTranslationDynamicIpFallbackInterfaceAddress;
    /**
     * Fallback IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleListDataSourceTranslationDynamicIpFallbackInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp: string;
    /**
     * Interface name
     */
    interface: string;
    /**
     * IP address
     */
    ip: string;
}

export interface GetNatRuleListDataSourceTranslationStaticIp {
    /**
     * Bi directional
     */
    biDirectional: string;
    /**
     * Translated IP address
     */
    translatedAddress: string;
}

export interface GetNatRuleSourceTranslation {
    /**
     * Dynamic IP
     */
    dynamicIp: outputs.GetNatRuleSourceTranslationDynamicIp;
    /**
     * Dynamic IP and port
     */
    dynamicIpAndPort: outputs.GetNatRuleSourceTranslationDynamicIpAndPort;
    /**
     * Static IP
     */
    staticIp: outputs.GetNatRuleSourceTranslationStaticIp;
}

export interface GetNatRuleSourceTranslationDynamicIp {
    /**
     * Fallback
     */
    fallback: outputs.GetNatRuleSourceTranslationDynamicIpFallback;
    /**
     * Translated IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleSourceTranslationDynamicIpAndPort {
    /**
     * Translated source interface
     */
    interfaceAddress: outputs.GetNatRuleSourceTranslationDynamicIpAndPortInterfaceAddress;
    /**
     * Translated source IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleSourceTranslationDynamicIpAndPortInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp: string;
    /**
     * Interface name
     */
    interface: string;
    /**
     * Translated source IP address
     */
    ip: string;
}

export interface GetNatRuleSourceTranslationDynamicIpFallback {
    /**
     * Fallback interface
     */
    interfaceAddress: outputs.GetNatRuleSourceTranslationDynamicIpFallbackInterfaceAddress;
    /**
     * Fallback IP addresses
     */
    translatedAddresses: string[];
}

export interface GetNatRuleSourceTranslationDynamicIpFallbackInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp: string;
    /**
     * Interface name
     */
    interface: string;
    /**
     * IP address
     */
    ip: string;
}

export interface GetNatRuleSourceTranslationStaticIp {
    /**
     * Bi directional
     */
    biDirectional: string;
    /**
     * Translated IP address
     */
    translatedAddress: string;
}

export interface GetOspfAuthProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * MD5s
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5` and `password`.
     */
    md5s: outputs.GetOspfAuthProfileListDataMd5[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Password
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5` and `password`.
     */
    password: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetOspfAuthProfileListDataMd5 {
    /**
     * MD5 hash
     */
    key: string;
    /**
     * Key ID
     */
    name: number;
    /**
     * Preferred?
     */
    preferred: boolean;
}

export interface GetOspfAuthProfileMd5 {
    /**
     * MD5 hash
     */
    key: string;
    /**
     * Key ID
     */
    name: number;
    /**
     * Preferred?
     */
    preferred: boolean;
}

export interface GetPbfRuleAction {
    /**
     * Discard
     */
    discard: outputs.GetPbfRuleActionDiscard;
    /**
     * Forward
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    forward: outputs.GetPbfRuleActionForward;
    /**
     * No pbf
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    noPbf: outputs.GetPbfRuleActionNoPbf;
}

export interface GetPbfRuleActionDiscard {
}

export interface GetPbfRuleActionForward {
    /**
     * Egress interface
     */
    egressInterface: string;
    /**
     * Monitor
     */
    monitor: outputs.GetPbfRuleActionForwardMonitor;
    /**
     * Nexthop
     */
    nexthop: outputs.GetPbfRuleActionForwardNexthop;
}

export interface GetPbfRuleActionForwardMonitor {
    /**
     * Disable this rule if nexthop/monitor ip is unreachable?
     */
    disableIfUnreachable: boolean;
    /**
     * Monitor IP address
     */
    ipAddress: string;
    /**
     * Monitoring profile
     */
    profile: string;
}

export interface GetPbfRuleActionForwardNexthop {
    /**
     * Next hop FQDN
     */
    fqdn: string;
    /**
     * Next hop IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetPbfRuleActionNoPbf {
}

export interface GetPbfRuleEnforceSymmetricReturn {
    /**
     * Enforce symmetric return?
     */
    enabled: boolean;
    /**
     * Next hop IP addresses
     */
    nexthopAddressLists: outputs.GetPbfRuleEnforceSymmetricReturnNexthopAddressList[];
}

export interface GetPbfRuleEnforceSymmetricReturnNexthopAddressList {
    /**
     * Next hop IP address
     */
    name: string;
}

export interface GetPbfRuleFrom {
    /**
     * Source interfaces
     */
    interfaces: string[];
    /**
     * Source zones
     *
     * > ℹ️ **Note:** You must specify exactly one of `interface` and `zone`.
     */
    zones: string[];
}

export interface GetPbfRuleListData {
    /**
     * Action
     */
    action: outputs.GetPbfRuleListDataAction;
    /**
     * Applications
     */
    applications: string[];
    /**
     * Description
     */
    description: string;
    /**
     * Destination addresses
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Enforce symmetric return
     */
    enforceSymmetricReturn: outputs.GetPbfRuleListDataEnforceSymmetricReturn;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * From
     */
    from: outputs.GetPbfRuleListDataFrom;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Schedule
     */
    schedule: string;
    /**
     * Services
     */
    services: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Source users
     */
    sourceUsers: string[];
    /**
     * Source addresses
     */
    sources: string[];
    /**
     * Tags
     */
    tags: string[];
    tfid: string;
}

export interface GetPbfRuleListDataAction {
    /**
     * Discard
     */
    discard: outputs.GetPbfRuleListDataActionDiscard;
    /**
     * Forward
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    forward: outputs.GetPbfRuleListDataActionForward;
    /**
     * No pbf
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    noPbf: outputs.GetPbfRuleListDataActionNoPbf;
}

export interface GetPbfRuleListDataActionDiscard {
}

export interface GetPbfRuleListDataActionForward {
    /**
     * Egress interface
     */
    egressInterface: string;
    /**
     * Monitor
     */
    monitor: outputs.GetPbfRuleListDataActionForwardMonitor;
    /**
     * Nexthop
     */
    nexthop: outputs.GetPbfRuleListDataActionForwardNexthop;
}

export interface GetPbfRuleListDataActionForwardMonitor {
    /**
     * Disable this rule if nexthop/monitor ip is unreachable?
     */
    disableIfUnreachable: boolean;
    /**
     * Monitor IP address
     */
    ipAddress: string;
    /**
     * Monitoring profile
     */
    profile: string;
}

export interface GetPbfRuleListDataActionForwardNexthop {
    /**
     * Next hop FQDN
     */
    fqdn: string;
    /**
     * Next hop IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress: string;
}

export interface GetPbfRuleListDataActionNoPbf {
}

export interface GetPbfRuleListDataEnforceSymmetricReturn {
    /**
     * Enforce symmetric return?
     */
    enabled: boolean;
    /**
     * Next hop IP addresses
     */
    nexthopAddressLists: outputs.GetPbfRuleListDataEnforceSymmetricReturnNexthopAddressList[];
}

export interface GetPbfRuleListDataEnforceSymmetricReturnNexthopAddressList {
    /**
     * Next hop IP address
     */
    name: string;
}

export interface GetPbfRuleListDataFrom {
    /**
     * Source interfaces
     */
    interfaces: string[];
    /**
     * Source zones
     *
     * > ℹ️ **Note:** You must specify exactly one of `interface` and `zone`.
     */
    zones: string[];
}

export interface GetProfileGroupListData {
    /**
     * Ai security
     */
    aiSecurities: string[];
    /**
     * Data filtering
     */
    dataFilterings: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Dns security
     */
    dnsSecurities: string[];
    /**
     * File blocking
     */
    fileBlockings: string[];
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the profile group
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Saas security
     */
    saasSecurities: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Spyware
     */
    spywares: string[];
    tfid: string;
    /**
     * Url filtering
     */
    urlFilterings: string[];
    /**
     * Virus and wildfire analysis
     */
    virusAndWildfireAnalyses: string[];
    /**
     * Vulnerability
     */
    vulnerabilities: string[];
}

export interface GetQosPolicyRuleAction {
    /**
     * Class
     */
    class: string;
}

export interface GetQosPolicyRuleDscpTos {
    /**
     * Codepoints
     */
    codepoints: outputs.GetQosPolicyRuleDscpTosCodepoint[];
}

export interface GetQosPolicyRuleDscpTosCodepoint {
    /**
     * Name
     */
    name: string;
    /**
     * Type
     */
    type: outputs.GetQosPolicyRuleDscpTosCodepointType;
}

export interface GetQosPolicyRuleDscpTosCodepointType {
    /**
     * Af
     */
    af: outputs.GetQosPolicyRuleDscpTosCodepointTypeAf;
    /**
     * Cs
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    cs: outputs.GetQosPolicyRuleDscpTosCodepointTypeCs;
    /**
     * Custom
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    custom: outputs.GetQosPolicyRuleDscpTosCodepointTypeCustom;
    /**
     * Ef
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    ef: outputs.GetQosPolicyRuleDscpTosCodepointTypeEf;
    /**
     * Tos
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    tos: outputs.GetQosPolicyRuleDscpTosCodepointTypeTos;
}

export interface GetQosPolicyRuleDscpTosCodepointTypeAf {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosPolicyRuleDscpTosCodepointTypeCs {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosPolicyRuleDscpTosCodepointTypeCustom {
    /**
     * Codepoint
     */
    codepoint: outputs.GetQosPolicyRuleDscpTosCodepointTypeCustomCodepoint;
}

export interface GetQosPolicyRuleDscpTosCodepointTypeCustomCodepoint {
    /**
     * Binary value
     */
    binaryValue: string;
    /**
     * Codepoint name
     */
    codepointName: string;
}

export interface GetQosPolicyRuleDscpTosCodepointTypeEf {
}

export interface GetQosPolicyRuleDscpTosCodepointTypeTos {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosPolicyRuleListData {
    /**
     * Action
     */
    action: outputs.GetQosPolicyRuleListDataAction;
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Dscp tos
     */
    dscpTos: outputs.GetQosPolicyRuleListDataDscpTos;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The relative position of the rule
     */
    position: string;
    /**
     * Relative positioning rule. String must be one of these: `"before"`, `"after"`, `"top"`, `"bottom"`. If not specified, rule is created at the bottom of the ruleset.
     */
    relativePosition: string;
    /**
     * Schedule
     */
    schedule: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * The name or UUID of the rule to position this rule relative to. Required when `relativePosition` is `"before"` or `"after"`.
     */
    targetRule: string;
    tfid: string;
}

export interface GetQosPolicyRuleListDataAction {
    /**
     * Class
     */
    class: string;
}

export interface GetQosPolicyRuleListDataDscpTos {
    /**
     * Codepoints
     */
    codepoints: outputs.GetQosPolicyRuleListDataDscpTosCodepoint[];
}

export interface GetQosPolicyRuleListDataDscpTosCodepoint {
    /**
     * Name
     */
    name: string;
    /**
     * Type
     */
    type: outputs.GetQosPolicyRuleListDataDscpTosCodepointType;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointType {
    /**
     * Af
     */
    af: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeAf;
    /**
     * Cs
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    cs: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeCs;
    /**
     * Custom
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    custom: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeCustom;
    /**
     * Ef
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    ef: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeEf;
    /**
     * Tos
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    tos: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeTos;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeAf {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeCs {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeCustom {
    /**
     * Codepoint
     */
    codepoint: outputs.GetQosPolicyRuleListDataDscpTosCodepointTypeCustomCodepoint;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeCustomCodepoint {
    /**
     * Binary value
     */
    binaryValue: string;
    /**
     * Codepoint name
     */
    codepointName: string;
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeEf {
}

export interface GetQosPolicyRuleListDataDscpTosCodepointTypeTos {
    /**
     * Codepoint
     */
    codepoint: string;
}

export interface GetQosProfileAggregateBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax: number;
}

export interface GetQosProfileClassBandwidthType {
    /**
     * Mbps
     */
    mbps: outputs.GetQosProfileClassBandwidthTypeMbps;
    /**
     * Percentage
     *
     * > ℹ️ **Note:** You must specify exactly one of `mbps` and `percentage`.
     */
    percentage: outputs.GetQosProfileClassBandwidthTypePercentage;
}

export interface GetQosProfileClassBandwidthTypeMbps {
    /**
     * QoS setting for traffic classes
     */
    classes: outputs.GetQosProfileClassBandwidthTypeMbpsClass[];
}

export interface GetQosProfileClassBandwidthTypeMbpsClass {
    /**
     * Class bandwidth
     */
    classBandwidth: outputs.GetQosProfileClassBandwidthTypeMbpsClassClassBandwidth;
    /**
     * Traffic class
     */
    name: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface GetQosProfileClassBandwidthTypeMbpsClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax: number;
}

export interface GetQosProfileClassBandwidthTypePercentage {
    /**
     * QoS setting for traffic classes
     */
    classes: outputs.GetQosProfileClassBandwidthTypePercentageClass[];
}

export interface GetQosProfileClassBandwidthTypePercentageClass {
    /**
     * Class bandwidth
     */
    classBandwidth: outputs.GetQosProfileClassBandwidthTypePercentageClassClassBandwidth;
    /**
     * Traffic class
     */
    name: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface GetQosProfileClassBandwidthTypePercentageClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in percentage
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in percentage
     */
    egressMax: number;
}

export interface GetQosProfileListData {
    /**
     * Aggregate bandwidth
     */
    aggregateBandwidth: outputs.GetQosProfileListDataAggregateBandwidth;
    /**
     * Class bandwidth type
     */
    classBandwidthType: outputs.GetQosProfileListDataClassBandwidthType;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetQosProfileListDataAggregateBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax: number;
}

export interface GetQosProfileListDataClassBandwidthType {
    /**
     * Mbps
     */
    mbps: outputs.GetQosProfileListDataClassBandwidthTypeMbps;
    /**
     * Percentage
     *
     * > ℹ️ **Note:** You must specify exactly one of `mbps` and `percentage`.
     */
    percentage: outputs.GetQosProfileListDataClassBandwidthTypePercentage;
}

export interface GetQosProfileListDataClassBandwidthTypeMbps {
    /**
     * QoS setting for traffic classes
     */
    classes: outputs.GetQosProfileListDataClassBandwidthTypeMbpsClass[];
}

export interface GetQosProfileListDataClassBandwidthTypeMbpsClass {
    /**
     * Class bandwidth
     */
    classBandwidth: outputs.GetQosProfileListDataClassBandwidthTypeMbpsClassClassBandwidth;
    /**
     * Traffic class
     */
    name: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface GetQosProfileListDataClassBandwidthTypeMbpsClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax: number;
}

export interface GetQosProfileListDataClassBandwidthTypePercentage {
    /**
     * QoS setting for traffic classes
     */
    classes: outputs.GetQosProfileListDataClassBandwidthTypePercentageClass[];
}

export interface GetQosProfileListDataClassBandwidthTypePercentageClass {
    /**
     * Class bandwidth
     */
    classBandwidth: outputs.GetQosProfileListDataClassBandwidthTypePercentageClassClassBandwidth;
    /**
     * Traffic class
     */
    name: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface GetQosProfileListDataClassBandwidthTypePercentageClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in percentage
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in percentage
     */
    egressMax: number;
}

export interface GetRadiusServerProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the RADIUS server profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The RADIUS authentication protocol
     */
    protocol: outputs.GetRadiusServerProfileListDataProtocol;
    /**
     * The number of RADIUS server retries
     */
    retries: number;
    /**
     * Server
     */
    servers: outputs.GetRadiusServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * The RADIUS server authentication timeout (seconds)
     */
    timeout: number;
}

export interface GetRadiusServerProfileListDataProtocol {
    /**
     * C h a p
     */
    chap: outputs.GetRadiusServerProfileListDataProtocolChap;
    /**
     * E a p t t l s with p a p
     */
    eapTtlsWithPap: outputs.GetRadiusServerProfileListDataProtocolEapTtlsWithPap;
    /**
     * P a p
     */
    pap: outputs.GetRadiusServerProfileListDataProtocolPap;
    /**
     * P e a p m s c h a pv2
     */
    peapMschaPv2: outputs.GetRadiusServerProfileListDataProtocolPeapMschaPv2;
    /**
     * P e a p with g t c
     */
    peapWithGtc: outputs.GetRadiusServerProfileListDataProtocolPeapWithGtc;
}

export interface GetRadiusServerProfileListDataProtocolChap {
}

export interface GetRadiusServerProfileListDataProtocolEapTtlsWithPap {
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileListDataProtocolPap {
}

export interface GetRadiusServerProfileListDataProtocolPeapMschaPv2 {
    /**
     * Allow pwd change
     */
    allowPwdChange: boolean;
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileListDataProtocolPeapWithGtc {
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileListDataServer {
    /**
     * The IP address of the RADIUS server
     */
    ipAddress: string;
    /**
     * The name of the RADIUS server
     */
    name: string;
    /**
     * The RADIUS server port
     */
    port: number;
    /**
     * The RADIUS secret
     */
    secret: string;
}

export interface GetRadiusServerProfileProtocol {
    /**
     * C h a p
     */
    chap: outputs.GetRadiusServerProfileProtocolChap;
    /**
     * E a p t t l s with p a p
     */
    eapTtlsWithPap: outputs.GetRadiusServerProfileProtocolEapTtlsWithPap;
    /**
     * P a p
     */
    pap: outputs.GetRadiusServerProfileProtocolPap;
    /**
     * P e a p m s c h a pv2
     */
    peapMschaPv2: outputs.GetRadiusServerProfileProtocolPeapMschaPv2;
    /**
     * P e a p with g t c
     */
    peapWithGtc: outputs.GetRadiusServerProfileProtocolPeapWithGtc;
}

export interface GetRadiusServerProfileProtocolChap {
}

export interface GetRadiusServerProfileProtocolEapTtlsWithPap {
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileProtocolPap {
}

export interface GetRadiusServerProfileProtocolPeapMschaPv2 {
    /**
     * Allow pwd change
     */
    allowPwdChange: boolean;
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileProtocolPeapWithGtc {
    /**
     * Anon outer id
     */
    anonOuterId: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile: string;
}

export interface GetRadiusServerProfileServer {
    /**
     * The IP address of the RADIUS server
     */
    ipAddress: string;
    /**
     * The name of the RADIUS server
     */
    name: string;
    /**
     * The RADIUS server port
     */
    port: number;
    /**
     * The RADIUS secret
     */
    secret: string;
}

export interface GetRegionGeoLocation {
    /**
     * The latitudinal position of the region
     */
    latitude: number;
    /**
     * The longitudinal postition of the region
     */
    longitude: number;
}

export interface GetRegionListData {
    /**
     * Address
     */
    addresses: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Geo location
     */
    geoLocation: outputs.GetRegionListDataGeoLocation;
    /**
     * The UUID of the region
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetRegionListDataGeoLocation {
    /**
     * The latitudinal position of the region
     */
    latitude: number;
    /**
     * The longitudinal postition of the region
     */
    longitude: number;
}

export interface GetRemoteNetworkEcmpTunnel {
    /**
     * Ipsec tunnel
     */
    ipsecTunnel: string;
    /**
     * Name
     */
    name: string;
    /**
     * Protocol
     */
    protocol: outputs.GetRemoteNetworkEcmpTunnelProtocol;
}

export interface GetRemoteNetworkEcmpTunnelProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetRemoteNetworkEcmpTunnelProtocolBgp;
}

export interface GetRemoteNetworkEcmpTunnelProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes: boolean;
    /**
     * Enable BGP peering?
     */
    enable: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute: boolean;
    /**
     * BGP peer ASN
     */
    peerAs: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress: string;
    /**
     * Route exchange types
     */
    peeringType: string;
    /**
     * BGP peering secret
     */
    secret: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetRemoteNetworkListData {
    /**
     * Ecmp load balancing
     */
    ecmpLoadBalancing: string;
    /**
     * ecmp*tunnels is required when ecmp*load*balancing is enable
     */
    ecmpTunnels: outputs.GetRemoteNetworkListDataEcmpTunnel[];
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder that contains the remote network
     */
    folder: string;
    /**
     * The UUID of the remote network
     */
    id: string;
    /**
     * ipsec*tunnel is required when ecmp*load_balancing is disable
     */
    ipsecTunnel: string;
    /**
     * New customer will only be on aggregate bandwidth licensing
     */
    licenseType: string;
    /**
     * The name of the remote network
     */
    name: string;
    /**
     * setup the protocol when ecmp*load*balancing is disable
     */
    protocol: outputs.GetRemoteNetworkListDataProtocol;
    /**
     * Region
     */
    region: string;
    /**
     * specify secondary ipsecTunnel if needed
     */
    secondaryIpsecTunnel: string;
    /**
     * spn-name is needed when licenseType is FWAAS-AGGREGATE
     */
    spnName: string;
    /**
     * Subnets
     */
    subnets: string[];
    tfid: string;
}

export interface GetRemoteNetworkListDataEcmpTunnel {
    /**
     * Ipsec tunnel
     */
    ipsecTunnel: string;
    /**
     * Name
     */
    name: string;
    /**
     * Protocol
     */
    protocol: outputs.GetRemoteNetworkListDataEcmpTunnelProtocol;
}

export interface GetRemoteNetworkListDataEcmpTunnelProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetRemoteNetworkListDataEcmpTunnelProtocolBgp;
}

export interface GetRemoteNetworkListDataEcmpTunnelProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes: boolean;
    /**
     * Enable BGP peering?
     */
    enable: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute: boolean;
    /**
     * BGP peer ASN
     */
    peerAs: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress: string;
    /**
     * Route exchange types
     */
    peeringType: string;
    /**
     * BGP peering secret
     */
    secret: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetRemoteNetworkListDataProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetRemoteNetworkListDataProtocolBgp;
    /**
     * secondary bgp routing as bgp*peer
     */
    bgpPeer: outputs.GetRemoteNetworkListDataProtocolBgpPeer;
}

export interface GetRemoteNetworkListDataProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes: boolean;
    /**
     * Enable BGP peering?
     */
    enable: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute: boolean;
    /**
     * BGP peer ASN
     */
    peerAs: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress: string;
    /**
     * Route exchange types
     */
    peeringType: string;
    /**
     * BGP peering secret
     */
    secret: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetRemoteNetworkListDataProtocolBgpPeer {
    /**
     * Local peer IP address (secondary WAN)
     */
    localIpAddress: string;
    /**
     * Remote peer IP address (secondary WAN)
     */
    peerIpAddress: string;
    /**
     * BGP peering secret (secondary WAN)
     */
    secret: string;
}

export interface GetRemoteNetworkProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetRemoteNetworkProtocolBgp;
    /**
     * secondary bgp routing as bgp*peer
     */
    bgpPeer: outputs.GetRemoteNetworkProtocolBgpPeer;
}

export interface GetRemoteNetworkProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes: boolean;
    /**
     * Enable BGP peering?
     */
    enable: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute: boolean;
    /**
     * BGP peer ASN
     */
    peerAs: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress: string;
    /**
     * Route exchange types
     */
    peeringType: string;
    /**
     * BGP peering secret
     */
    secret: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetRemoteNetworkProtocolBgpPeer {
    /**
     * Local peer IP address (secondary WAN)
     */
    localIpAddress: string;
    /**
     * Remote peer IP address (secondary WAN)
     */
    peerIpAddress: string;
    /**
     * BGP peering secret (secondary WAN)
     */
    secret: string;
}

export interface GetRouteAccessListListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Type
     */
    type: outputs.GetRouteAccessListListDataType;
}

export interface GetRouteAccessListListDataType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetRouteAccessListListDataTypeIpv4;
}

export interface GetRouteAccessListListDataTypeIpv4 {
    /**
     * IPv4 access lists
     */
    ipv4Entries: outputs.GetRouteAccessListListDataTypeIpv4Ipv4Entry[];
}

export interface GetRouteAccessListListDataTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action: string;
    /**
     * Destination address
     */
    destinationAddress: outputs.GetRouteAccessListListDataTypeIpv4Ipv4EntryDestinationAddress;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Source address
     */
    sourceAddress: outputs.GetRouteAccessListListDataTypeIpv4Ipv4EntrySourceAddress;
}

export interface GetRouteAccessListListDataTypeIpv4Ipv4EntryDestinationAddress {
    /**
     * Destination IP address
     */
    address: string;
    /**
     * Entry
     */
    entry: outputs.GetRouteAccessListListDataTypeIpv4Ipv4EntryDestinationAddressEntry;
}

export interface GetRouteAccessListListDataTypeIpv4Ipv4EntryDestinationAddressEntry {
    /**
     * Destination IP address
     */
    address: string;
    /**
     * Destination IP wildcard
     */
    wildcard: string;
}

export interface GetRouteAccessListListDataTypeIpv4Ipv4EntrySourceAddress {
    /**
     * Source IP address
     */
    address: string;
    /**
     * Entry
     */
    entry: outputs.GetRouteAccessListListDataTypeIpv4Ipv4EntrySourceAddressEntry;
}

export interface GetRouteAccessListListDataTypeIpv4Ipv4EntrySourceAddressEntry {
    /**
     * Source IP address
     */
    address: string;
    /**
     * Source IP wildcard
     */
    wildcard: string;
}

export interface GetRouteAccessListType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetRouteAccessListTypeIpv4;
}

export interface GetRouteAccessListTypeIpv4 {
    /**
     * IPv4 access lists
     */
    ipv4Entries: outputs.GetRouteAccessListTypeIpv4Ipv4Entry[];
}

export interface GetRouteAccessListTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action: string;
    /**
     * Destination address
     */
    destinationAddress: outputs.GetRouteAccessListTypeIpv4Ipv4EntryDestinationAddress;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Source address
     */
    sourceAddress: outputs.GetRouteAccessListTypeIpv4Ipv4EntrySourceAddress;
}

export interface GetRouteAccessListTypeIpv4Ipv4EntryDestinationAddress {
    /**
     * Destination IP address
     */
    address: string;
    /**
     * Entry
     */
    entry: outputs.GetRouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntry;
}

export interface GetRouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntry {
    /**
     * Destination IP address
     */
    address: string;
    /**
     * Destination IP wildcard
     */
    wildcard: string;
}

export interface GetRouteAccessListTypeIpv4Ipv4EntrySourceAddress {
    /**
     * Source IP address
     */
    address: string;
    /**
     * Entry
     */
    entry: outputs.GetRouteAccessListTypeIpv4Ipv4EntrySourceAddressEntry;
}

export interface GetRouteAccessListTypeIpv4Ipv4EntrySourceAddressEntry {
    /**
     * Source IP address
     */
    address: string;
    /**
     * Source IP wildcard
     */
    wildcard: string;
}

export interface GetRouteCommunityListListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Type
     */
    type: outputs.GetRouteCommunityListListDataType;
}

export interface GetRouteCommunityListListDataType {
    /**
     * Extended
     */
    extended: outputs.GetRouteCommunityListListDataTypeExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    large: outputs.GetRouteCommunityListListDataTypeLarge;
    /**
     * Regular
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    regular: outputs.GetRouteCommunityListListDataTypeRegular;
}

export interface GetRouteCommunityListListDataTypeExtended {
    /**
     * Extended community lists
     */
    extendedEntries: outputs.GetRouteCommunityListListDataTypeExtendedExtendedEntry[];
}

export interface GetRouteCommunityListListDataTypeExtendedExtendedEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Extended community regular expression
     */
    lcRegexes: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRouteCommunityListListDataTypeLarge {
    /**
     * Large community lists
     */
    largeEntries: outputs.GetRouteCommunityListListDataTypeLargeLargeEntry[];
}

export interface GetRouteCommunityListListDataTypeLargeLargeEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Large community regular expression
     */
    lcRegexes: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRouteCommunityListListDataTypeRegular {
    /**
     * Regular community lists
     */
    regularEntries: outputs.GetRouteCommunityListListDataTypeRegularRegularEntry[];
}

export interface GetRouteCommunityListListDataTypeRegularRegularEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Communities
     */
    communities: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRouteCommunityListType {
    /**
     * Extended
     */
    extended: outputs.GetRouteCommunityListTypeExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    large: outputs.GetRouteCommunityListTypeLarge;
    /**
     * Regular
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    regular: outputs.GetRouteCommunityListTypeRegular;
}

export interface GetRouteCommunityListTypeExtended {
    /**
     * Extended community lists
     */
    extendedEntries: outputs.GetRouteCommunityListTypeExtendedExtendedEntry[];
}

export interface GetRouteCommunityListTypeExtendedExtendedEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Extended community regular expression
     */
    lcRegexes: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRouteCommunityListTypeLarge {
    /**
     * Large community lists
     */
    largeEntries: outputs.GetRouteCommunityListTypeLargeLargeEntry[];
}

export interface GetRouteCommunityListTypeLargeLargeEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Large community regular expression
     */
    lcRegexes: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRouteCommunityListTypeRegular {
    /**
     * Regular community lists
     */
    regularEntries: outputs.GetRouteCommunityListTypeRegularRegularEntry[];
}

export interface GetRouteCommunityListTypeRegularRegularEntry {
    /**
     * Action
     */
    action: string;
    /**
     * Communities
     */
    communities: string[];
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRoutePathAccessListAspathEntry {
    /**
     * Action
     */
    action: string;
    /**
     * AS path regular expression
     */
    aspathRegex: string;
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRoutePathAccessListListData {
    /**
     * AS paths
     */
    aspathEntries: outputs.GetRoutePathAccessListListDataAspathEntry[];
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetRoutePathAccessListListDataAspathEntry {
    /**
     * Action
     */
    action: string;
    /**
     * AS path regular expression
     */
    aspathRegex: string;
    /**
     * Sequence number
     */
    name: number;
}

export interface GetRoutePrefixListListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Address Family Type
     */
    type: outputs.GetRoutePrefixListListDataType;
}

export interface GetRoutePrefixListListDataType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetRoutePrefixListListDataTypeIpv4;
}

export interface GetRoutePrefixListListDataTypeIpv4 {
    /**
     * IPv4 prefix lists
     */
    ipv4Entries: outputs.GetRoutePrefixListListDataTypeIpv4Ipv4Entry[];
}

export interface GetRoutePrefixListListDataTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action: string;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Prefix
     */
    prefix: outputs.GetRoutePrefixListListDataTypeIpv4Ipv4EntryPrefix;
}

export interface GetRoutePrefixListListDataTypeIpv4Ipv4EntryPrefix {
    /**
     * Entry
     */
    entry: outputs.GetRoutePrefixListListDataTypeIpv4Ipv4EntryPrefixEntry;
    /**
     * Network
     *
     * > ℹ️ **Note:** You must specify exactly one of `entry` and `network`.
     */
    network: string;
}

export interface GetRoutePrefixListListDataTypeIpv4Ipv4EntryPrefixEntry {
    /**
     * Greater than or equal to
     */
    greaterThanOrEqual: number;
    /**
     * Less than or equal to
     */
    lessThanOrEqual: number;
    /**
     * Network
     */
    network: string;
}

export interface GetRoutePrefixListType {
    /**
     * Ipv4
     */
    ipv4: outputs.GetRoutePrefixListTypeIpv4;
}

export interface GetRoutePrefixListTypeIpv4 {
    /**
     * IPv4 prefix lists
     */
    ipv4Entries: outputs.GetRoutePrefixListTypeIpv4Ipv4Entry[];
}

export interface GetRoutePrefixListTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action: string;
    /**
     * Sequence number
     */
    name: number;
    /**
     * Prefix
     */
    prefix: outputs.GetRoutePrefixListTypeIpv4Ipv4EntryPrefix;
}

export interface GetRoutePrefixListTypeIpv4Ipv4EntryPrefix {
    /**
     * Entry
     */
    entry: outputs.GetRoutePrefixListTypeIpv4Ipv4EntryPrefixEntry;
    /**
     * Network
     *
     * > ℹ️ **Note:** You must specify exactly one of `entry` and `network`.
     */
    network: string;
}

export interface GetRoutePrefixListTypeIpv4Ipv4EntryPrefixEntry {
    /**
     * Greater than or equal to
     */
    greaterThanOrEqual: number;
    /**
     * Less than or equal to
     */
    lessThanOrEqual: number;
    /**
     * Network
     */
    network: string;
}

export interface GetSamlServerProfileListData {
    /**
     * The identity provider certificate
     */
    certificate: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The identity provider ID
     */
    entityId: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the SAML server profile
     */
    id: string;
    /**
     * Maxiumum clock skew
     */
    maxClockSkew: number;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * SAML HTTP binding for SLO requests to the identity provider
     */
    sloBindings: string;
    /**
     * Identity provider SLO URL
     */
    sloUrl: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * SAML HTTP binding for SSO requests to the identity provider
     */
    ssoBindings: string;
    /**
     * Identity provider SSO URL
     */
    ssoUrl: string;
    tfid: string;
    /**
     * Validate the identity provider certificate?
     */
    validateIdpCertificate: boolean;
    /**
     * Sign SAML message to the identity provider?
     */
    wantAuthRequestsSigned: boolean;
}

export interface GetScepProfileAlgorithm {
    /**
     * Key length (bits)
     */
    rsa: outputs.GetScepProfileAlgorithmRsa;
}

export interface GetScepProfileAlgorithmRsa {
    /**
     * Rsa nbits
     */
    rsaNbits: string;
}

export interface GetScepProfileCertificateAttributes {
    /**
     * Dnsname
     */
    dnsname: string;
    /**
     * Rfc822name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    rfc822name: string;
    /**
     * Uniform resource identifier
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    uniformResourceIdentifier: string;
}

export interface GetScepProfileListData {
    /**
     * Algorithm
     */
    algorithm: outputs.GetScepProfileListDataAlgorithm;
    /**
     * Certificate Authority Identity
     */
    caIdentityName: string;
    /**
     * Subject Alternative name type
     */
    certificateAttributes: outputs.GetScepProfileListDataCertificateAttributes;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Digest for CSR
     */
    digest: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * CA Certificate Fingerprint
     */
    fingerprint: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the SCEP profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * SCEP Server CA Certificate
     */
    scepCaCert: string;
    /**
     * One Time Password Challenge
     */
    scepChallenge: outputs.GetScepProfileListDataScepChallenge;
    /**
     * SCEP Client Certificate
     */
    scepClientCert: string;
    /**
     * SCEP server URL
     */
    scepUrl: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Subject
     */
    subject: string;
    tfid: string;
    /**
     * Use as digital signature?
     */
    useAsDigitalSignature: boolean;
    /**
     * Use for key encipherment?
     */
    useForKeyEncipherment: boolean;
}

export interface GetScepProfileListDataAlgorithm {
    /**
     * Key length (bits)
     */
    rsa: outputs.GetScepProfileListDataAlgorithmRsa;
}

export interface GetScepProfileListDataAlgorithmRsa {
    /**
     * Rsa nbits
     */
    rsaNbits: string;
}

export interface GetScepProfileListDataCertificateAttributes {
    /**
     * Dnsname
     */
    dnsname: string;
    /**
     * Rfc822name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    rfc822name: string;
    /**
     * Uniform resource identifier
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    uniformResourceIdentifier: string;
}

export interface GetScepProfileListDataScepChallenge {
    /**
     * Dynamic
     */
    dynamic: outputs.GetScepProfileListDataScepChallengeDynamic;
    /**
     * Challenge to use for SCEP server on mobile clients
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    fixed: string;
    /**
     * No OTP
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    none: outputs.GetScepProfileListDataScepChallengeNone;
}

export interface GetScepProfileListDataScepChallengeDynamic {
    /**
     * OTP server URL
     */
    otpServerUrl: string;
    /**
     * OTP password
     */
    password: string;
    /**
     * OTP username
     */
    username: string;
}

export interface GetScepProfileListDataScepChallengeNone {
}

export interface GetScepProfileScepChallenge {
    /**
     * Dynamic
     */
    dynamic: outputs.GetScepProfileScepChallengeDynamic;
    /**
     * Challenge to use for SCEP server on mobile clients
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    fixed: string;
    /**
     * No OTP
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    none: outputs.GetScepProfileScepChallengeNone;
}

export interface GetScepProfileScepChallengeDynamic {
    /**
     * OTP server URL
     */
    otpServerUrl: string;
    /**
     * OTP password
     */
    password: string;
    /**
     * OTP username
     */
    username: string;
}

export interface GetScepProfileScepChallengeNone {
}

export interface GetScheduleListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the schedule
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Schedule type
     */
    scheduleType: outputs.GetScheduleListDataScheduleType;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetScheduleListDataScheduleType {
    /**
     * Non recurring
     */
    nonRecurrings: string[];
    /**
     * Recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `nonRecurring` and `recurring`.
     */
    recurring: outputs.GetScheduleListDataScheduleTypeRecurring;
}

export interface GetScheduleListDataScheduleTypeRecurring {
    /**
     * Daily
     */
    dailies: string[];
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily` and `weekly`.
     */
    weekly: outputs.GetScheduleListDataScheduleTypeRecurringWeekly;
}

export interface GetScheduleListDataScheduleTypeRecurringWeekly {
    /**
     * Friday
     */
    fridays: string[];
    /**
     * Monday
     */
    mondays: string[];
    /**
     * Saturday
     */
    saturdays: string[];
    /**
     * Sunday
     */
    sundays: string[];
    /**
     * Thursday
     */
    thursdays: string[];
    /**
     * Tuesday
     */
    tuesdays: string[];
    /**
     * Wednesday
     */
    wednesdays: string[];
}

export interface GetScheduleScheduleType {
    /**
     * Non recurring
     */
    nonRecurrings: string[];
    /**
     * Recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `nonRecurring` and `recurring`.
     */
    recurring: outputs.GetScheduleScheduleTypeRecurring;
}

export interface GetScheduleScheduleTypeRecurring {
    /**
     * Daily
     */
    dailies: string[];
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily` and `weekly`.
     */
    weekly: outputs.GetScheduleScheduleTypeRecurringWeekly;
}

export interface GetScheduleScheduleTypeRecurringWeekly {
    /**
     * Friday
     */
    fridays: string[];
    /**
     * Monday
     */
    mondays: string[];
    /**
     * Saturday
     */
    saturdays: string[];
    /**
     * Sunday
     */
    sundays: string[];
    /**
     * Thursday
     */
    thursdays: string[];
    /**
     * Tuesday
     */
    tuesdays: string[];
    /**
     * Wednesday
     */
    wednesdays: string[];
}

export interface GetSdwanErrorCorrectionProfileListData {
    /**
     * Activation threshold
     */
    activationThreshold: number;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Mode
     */
    mode: outputs.GetSdwanErrorCorrectionProfileListDataMode;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSdwanErrorCorrectionProfileListDataMode {
    /**
     * Forward error correction
     */
    forwardErrorCorrection: outputs.GetSdwanErrorCorrectionProfileListDataModeForwardErrorCorrection;
    /**
     * Packet duplication
     *
     * > ℹ️ **Note:** You must specify exactly one of `forwardErrorCorrection` and `packetDuplication`.
     */
    packetDuplication: outputs.GetSdwanErrorCorrectionProfileListDataModePacketDuplication;
}

export interface GetSdwanErrorCorrectionProfileListDataModeForwardErrorCorrection {
    /**
     * Ratio
     */
    ratio: string;
    /**
     * Recovery duration
     */
    recoveryDuration: number;
}

export interface GetSdwanErrorCorrectionProfileListDataModePacketDuplication {
    /**
     * Recovery duration pd
     */
    recoveryDurationPd: number;
}

export interface GetSdwanErrorCorrectionProfileMode {
    /**
     * Forward error correction
     */
    forwardErrorCorrection: outputs.GetSdwanErrorCorrectionProfileModeForwardErrorCorrection;
    /**
     * Packet duplication
     *
     * > ℹ️ **Note:** You must specify exactly one of `forwardErrorCorrection` and `packetDuplication`.
     */
    packetDuplication: outputs.GetSdwanErrorCorrectionProfileModePacketDuplication;
}

export interface GetSdwanErrorCorrectionProfileModeForwardErrorCorrection {
    /**
     * Ratio
     */
    ratio: string;
    /**
     * Recovery duration
     */
    recoveryDuration: number;
}

export interface GetSdwanErrorCorrectionProfileModePacketDuplication {
    /**
     * Recovery duration pd
     */
    recoveryDurationPd: number;
}

export interface GetSdwanPathQualityProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Metric
     */
    metric: outputs.GetSdwanPathQualityProfileListDataMetric;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSdwanPathQualityProfileListDataMetric {
    /**
     * Jitter
     */
    jitter: outputs.GetSdwanPathQualityProfileListDataMetricJitter;
    /**
     * Latency
     */
    latency: outputs.GetSdwanPathQualityProfileListDataMetricLatency;
    /**
     * Pkt loss
     */
    pktLoss: outputs.GetSdwanPathQualityProfileListDataMetricPktLoss;
}

export interface GetSdwanPathQualityProfileListDataMetricJitter {
    /**
     * Jitter sensitivity
     */
    sensitivity: string;
    /**
     * Jitter threshold (ms)
     */
    threshold: number;
}

export interface GetSdwanPathQualityProfileListDataMetricLatency {
    /**
     * Latency sensitivity
     */
    sensitivity: string;
    /**
     * Latency threshold (ms)
     */
    threshold: number;
}

export interface GetSdwanPathQualityProfileListDataMetricPktLoss {
    /**
     * Packet loss sensitivity
     */
    sensitivity: string;
    /**
     * Packet loss threshold (percentage)
     */
    threshold: number;
}

export interface GetSdwanPathQualityProfileMetric {
    /**
     * Jitter
     */
    jitter: outputs.GetSdwanPathQualityProfileMetricJitter;
    /**
     * Latency
     */
    latency: outputs.GetSdwanPathQualityProfileMetricLatency;
    /**
     * Pkt loss
     */
    pktLoss: outputs.GetSdwanPathQualityProfileMetricPktLoss;
}

export interface GetSdwanPathQualityProfileMetricJitter {
    /**
     * Jitter sensitivity
     */
    sensitivity: string;
    /**
     * Jitter threshold (ms)
     */
    threshold: number;
}

export interface GetSdwanPathQualityProfileMetricLatency {
    /**
     * Latency sensitivity
     */
    sensitivity: string;
    /**
     * Latency threshold (ms)
     */
    threshold: number;
}

export interface GetSdwanPathQualityProfileMetricPktLoss {
    /**
     * Packet loss sensitivity
     */
    sensitivity: string;
    /**
     * Packet loss threshold (percentage)
     */
    threshold: number;
}

export interface GetSdwanRuleAction {
    /**
     * Traffic dstribution profile
     */
    trafficDistributionProfile: string;
}

export interface GetSdwanRuleListData {
    /**
     * Action
     */
    action: outputs.GetSdwanRuleListDataAction;
    /**
     * List of applications
     */
    applications: string[];
    /**
     * Rule description
     */
    description: string;
    /**
     * List of destination addresses
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Disable rule?
     */
    disabled: boolean;
    /**
     * Error correction profile
     */
    errorCorrectionProfile: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * List of source zones
     */
    froms: string[];
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Negate destination address(es)?
     */
    negateDestination: boolean;
    /**
     * Negate source address(es)?
     */
    negateSource: boolean;
    /**
     * Path quality profile
     */
    pathQualityProfile: string;
    /**
     * Rule postion relative to device rules
     */
    position: string;
    /**
     * SaaS quality profile
     */
    saasQualityProfile: string;
    /**
     * List of services
     */
    services: string[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * List of source users
     */
    sourceUsers: string[];
    /**
     * List of source addresses
     */
    sources: string[];
    /**
     * List of tags
     */
    tags: string[];
    tfid: string;
    /**
     * List of destination zones
     */
    tos: string[];
}

export interface GetSdwanRuleListDataAction {
    /**
     * Traffic dstribution profile
     */
    trafficDistributionProfile: string;
}

export interface GetSdwanSaasQualityProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Monitor mode
     */
    monitorMode: outputs.GetSdwanSaasQualityProfileListDataMonitorMode;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSdwanSaasQualityProfileListDataMonitorMode {
    /**
     * Adaptive
     */
    adaptive: outputs.GetSdwanSaasQualityProfileListDataMonitorModeAdaptive;
    /**
     * Http https
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    httpHttps: outputs.GetSdwanSaasQualityProfileListDataMonitorModeHttpHttps;
    /**
     * Static ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    staticIp: outputs.GetSdwanSaasQualityProfileListDataMonitorModeStaticIp;
}

export interface GetSdwanSaasQualityProfileListDataMonitorModeAdaptive {
}

export interface GetSdwanSaasQualityProfileListDataMonitorModeHttpHttps {
    /**
     * Monitored URL
     */
    monitoredUrl: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanSaasQualityProfileListDataMonitorModeStaticIp {
    /**
     * Fqdn
     */
    fqdn: outputs.GetSdwanSaasQualityProfileListDataMonitorModeStaticIpFqdn;
    /**
     * List of IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddresses: outputs.GetSdwanSaasQualityProfileListDataMonitorModeStaticIpIpAddress[];
}

export interface GetSdwanSaasQualityProfileListDataMonitorModeStaticIpFqdn {
    /**
     * FQDN
     */
    fqdnName: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanSaasQualityProfileListDataMonitorModeStaticIpIpAddress {
    /**
     * IP address
     */
    name: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanSaasQualityProfileMonitorMode {
    /**
     * Adaptive
     */
    adaptive: outputs.GetSdwanSaasQualityProfileMonitorModeAdaptive;
    /**
     * Http https
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    httpHttps: outputs.GetSdwanSaasQualityProfileMonitorModeHttpHttps;
    /**
     * Static ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    staticIp: outputs.GetSdwanSaasQualityProfileMonitorModeStaticIp;
}

export interface GetSdwanSaasQualityProfileMonitorModeAdaptive {
}

export interface GetSdwanSaasQualityProfileMonitorModeHttpHttps {
    /**
     * Monitored URL
     */
    monitoredUrl: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanSaasQualityProfileMonitorModeStaticIp {
    /**
     * Fqdn
     */
    fqdn: outputs.GetSdwanSaasQualityProfileMonitorModeStaticIpFqdn;
    /**
     * List of IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddresses: outputs.GetSdwanSaasQualityProfileMonitorModeStaticIpIpAddress[];
}

export interface GetSdwanSaasQualityProfileMonitorModeStaticIpFqdn {
    /**
     * FQDN
     */
    fqdnName: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanSaasQualityProfileMonitorModeStaticIpIpAddress {
    /**
     * IP address
     */
    name: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface GetSdwanTrafficDistributionProfileLinkTag {
    /**
     * Link-Tag used for identifying a set of interfaces
     */
    name: string;
    /**
     * Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
     */
    weight: number;
}

export interface GetSdwanTrafficDistributionProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Link-Tags for interfaces identified by defined tags
     */
    linkTags: outputs.GetSdwanTrafficDistributionProfileListDataLinkTag[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Traffic distribution
     */
    trafficDistribution: string;
}

export interface GetSdwanTrafficDistributionProfileListDataLinkTag {
    /**
     * Link-Tag used for identifying a set of interfaces
     */
    name: string;
    /**
     * Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
     */
    weight: number;
}

export interface GetSecurityRuleAllowUrlCategory {
    /**
     * Additional action
     */
    additionalAction: string;
    /**
     * Credential enforcement
     */
    credentialEnforcement: string;
    /**
     * Decryption
     */
    decryption: string;
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleAllowUrlCategoryFileControl;
    /**
     * Isolation profiles
     */
    isolationProfiles: string;
    /**
     * Name
     */
    name: string;
}

export interface GetSecurityRuleAllowUrlCategoryFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleAllowWebApplication {
    /**
     * Application function
     */
    applicationFunctions: string[];
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleAllowWebApplicationFileControl;
    /**
     * Name
     */
    name: string;
    /**
     * Saas enterprise control
     */
    saasEnterpriseControl: outputs.GetSecurityRuleAllowWebApplicationSaasEnterpriseControl;
    /**
     * Saas tenant list
     */
    saasTenantLists: string[];
    /**
     * Saas user list
     */
    saasUserLists: string[];
    /**
     * Tenant control
     */
    tenantControl: outputs.GetSecurityRuleAllowWebApplicationTenantControl;
    /**
     * Type
     */
    type: string;
}

export interface GetSecurityRuleAllowWebApplicationFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleAllowWebApplicationSaasEnterpriseControl {
    /**
     * Consumer access
     */
    consumerAccess: outputs.GetSecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccess;
    /**
     * Enterprise access
     */
    enterpriseAccess: outputs.GetSecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccess;
}

export interface GetSecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccess {
    /**
     * Enable
     */
    enable: string;
}

export interface GetSecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccess {
    /**
     * Enable
     */
    enable: string;
    /**
     * Tenant restrictions
     */
    tenantRestrictions: string[];
}

export interface GetSecurityRuleAllowWebApplicationTenantControl {
    /**
     * Allowed activities
     */
    allowedActivities: string[];
    /**
     * Blocked activities
     */
    blockedActivities: string[];
    /**
     * Parent application
     */
    parentApplication: string;
    /**
     * Tenants
     */
    tenants: string[];
}

export interface GetSecurityRuleDefaultProfileSettings {
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleDefaultProfileSettingsFileControl;
}

export interface GetSecurityRuleDefaultProfileSettingsFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleListData {
    /**
     * The action to be taken when the rule is matched
     */
    action: string;
    /**
     * Allow url category
     */
    allowUrlCategories: outputs.GetSecurityRuleListDataAllowUrlCategory[];
    /**
     * Allow web application
     */
    allowWebApplications: outputs.GetSecurityRuleListDataAllowWebApplication[];
    /**
     * The application(s) being accessed
     */
    applications: string[];
    /**
     * Block url category
     */
    blockUrlCategories: string[];
    /**
     * Block web application
     */
    blockWebApplications: string[];
    /**
     * The URL categories being accessed
     */
    categories: string[];
    /**
     * Default profile settings
     */
    defaultProfileSettings: outputs.GetSecurityRuleListDataDefaultProfileSettings;
    /**
     * The description of the security rule
     */
    description: string;
    /**
     * The destination Host Integrity Profile(s)
     */
    destinationHips: string[];
    /**
     * The destination address(es)
     */
    destinations: string[];
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Devices
     */
    devices: string[];
    /**
     * Is the security rule disabled?
     */
    disabled: boolean;
    /**
     * The folder in which the resource is defined
     */
    folder: string;
    /**
     * The source security zone(s)
     */
    froms: string[];
    /**
     * The UUID of the security rule
     */
    id: string;
    /**
     * Log at session end?
     */
    logEnd: boolean;
    /**
     * The external log forwarding profile
     */
    logSetting: string;
    /**
     * Log settings
     */
    logSettings: outputs.GetSecurityRuleListDataLogSettings;
    /**
     * Log at session start?
     */
    logStart: boolean;
    /**
     * The name of the security rule
     */
    name: string;
    /**
     * Negate the destination addresses(es)?
     */
    negateDestination: boolean;
    /**
     * Negate the source address(es)?
     */
    negateSource: boolean;
    /**
     * Negate user
     */
    negateUser: boolean;
    /**
     * Policy type
     */
    policyType: string;
    /**
     * The position of a security rule
     */
    position: string;
    /**
     * The security profile object
     */
    profileSetting: outputs.GetSecurityRuleListDataProfileSetting;
    /**
     * Relative positioning rule. String must be one of these: `"before"`, `"after"`, `"top"`, `"bottom"`. If not specified, rule is created at the bottom of the ruleset.
     */
    relativePosition: string;
    /**
     * Schedule in which this rule will be applied
     */
    schedule: string;
    /**
     * Security settings
     */
    securitySettings: outputs.GetSecurityRuleListDataSecuritySettings;
    /**
     * The service(s) being accessed
     */
    services: string[];
    /**
     * The snippet in which the resource is defined
     */
    snippet: string;
    /**
     * The source Host Integrity Profile(s)
     */
    sourceHips: string[];
    /**
     * List of source users and/or groups.  Reserved words include `any`, `pre-login`, `known-user`, and `unknown`.
     */
    sourceUsers: string[];
    /**
     * The source addresses(es)
     */
    sources: string[];
    /**
     * The tags associated with the security rule
     */
    tags: string[];
    /**
     * The name or UUID of the rule to position this rule relative to. Required when `relativePosition` is `"before"` or `"after"`.
     */
    targetRule: string;
    /**
     * Tenant restrictions
     */
    tenantRestrictions: string[];
    tfid: string;
    /**
     * The destination security zone(s)
     */
    tos: string[];
}

export interface GetSecurityRuleListDataAllowUrlCategory {
    /**
     * Additional action
     */
    additionalAction: string;
    /**
     * Credential enforcement
     */
    credentialEnforcement: string;
    /**
     * Decryption
     */
    decryption: string;
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleListDataAllowUrlCategoryFileControl;
    /**
     * Isolation profiles
     */
    isolationProfiles: string;
    /**
     * Name
     */
    name: string;
}

export interface GetSecurityRuleListDataAllowUrlCategoryFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleListDataAllowWebApplication {
    /**
     * Application function
     */
    applicationFunctions: string[];
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleListDataAllowWebApplicationFileControl;
    /**
     * Name
     */
    name: string;
    /**
     * Saas enterprise control
     */
    saasEnterpriseControl: outputs.GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControl;
    /**
     * Saas tenant list
     */
    saasTenantLists: string[];
    /**
     * Saas user list
     */
    saasUserLists: string[];
    /**
     * Tenant control
     */
    tenantControl: outputs.GetSecurityRuleListDataAllowWebApplicationTenantControl;
    /**
     * Type
     */
    type: string;
}

export interface GetSecurityRuleListDataAllowWebApplicationFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControl {
    /**
     * Consumer access
     */
    consumerAccess: outputs.GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControlConsumerAccess;
    /**
     * Enterprise access
     */
    enterpriseAccess: outputs.GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControlEnterpriseAccess;
}

export interface GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControlConsumerAccess {
    /**
     * Enable
     */
    enable: string;
}

export interface GetSecurityRuleListDataAllowWebApplicationSaasEnterpriseControlEnterpriseAccess {
    /**
     * Enable
     */
    enable: string;
    /**
     * Tenant restrictions
     */
    tenantRestrictions: string[];
}

export interface GetSecurityRuleListDataAllowWebApplicationTenantControl {
    /**
     * Allowed activities
     */
    allowedActivities: string[];
    /**
     * Blocked activities
     */
    blockedActivities: string[];
    /**
     * Parent application
     */
    parentApplication: string;
    /**
     * Tenants
     */
    tenants: string[];
}

export interface GetSecurityRuleListDataDefaultProfileSettings {
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.GetSecurityRuleListDataDefaultProfileSettingsFileControl;
}

export interface GetSecurityRuleListDataDefaultProfileSettingsFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface GetSecurityRuleListDataLogSettings {
    /**
     * Log sessions
     */
    logSessions: boolean;
}

export interface GetSecurityRuleListDataProfileSetting {
    /**
     * The security profile group
     */
    groups: string[];
}

export interface GetSecurityRuleListDataSecuritySettings {
    /**
     * Anti spyware
     */
    antiSpyware: string;
    /**
     * Virus and wildfire analysis
     */
    virusAndWildfireAnalysis: string;
    /**
     * Vulnerability
     */
    vulnerability: string;
}

export interface GetSecurityRuleLogSettings {
    /**
     * Log sessions
     */
    logSessions: boolean;
}

export interface GetSecurityRuleProfileSetting {
    /**
     * The security profile group
     */
    groups: string[];
}

export interface GetSecurityRuleSecuritySettings {
    /**
     * Anti spyware
     */
    antiSpyware: string;
    /**
     * Virus and wildfire analysis
     */
    virusAndWildfireAnalysis: string;
    /**
     * Vulnerability
     */
    vulnerability: string;
}

export interface GetServiceConnectionBgpPeer {
    /**
     * Local ip address
     */
    localIpAddress: string;
    /**
     * Local ipv6 address
     */
    localIpv6Address: string;
    /**
     * Peer ip address
     */
    peerIpAddress: string;
    /**
     * Peer ipv6 address
     */
    peerIpv6Address: string;
    /**
     * Secret
     */
    secret: string;
}

export interface GetServiceConnectionGroupListData {
    /**
     * Disable snat
     */
    disableSnat: boolean;
    /**
     * The folder in which the resource is defined
     */
    folder: string;
    /**
     * The UUID of the service connection group
     */
    id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Pbf only
     */
    pbfOnly: boolean;
    /**
     * Target
     */
    targets: string[];
    tfid: string;
}

export interface GetServiceConnectionListData {
    /**
     * Backup s c
     */
    backupSc: string;
    /**
     * Bgp peer
     */
    bgpPeer: outputs.GetServiceConnectionListDataBgpPeer;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder in which the resource is defined
     */
    folder: string;
    /**
     * The UUID of the service connection
     */
    id: string;
    /**
     * Ipsec tunnel
     */
    ipsecTunnel: string;
    /**
     * The name of the service connection
     */
    name: string;
    /**
     * Nat pool
     */
    natPool: string;
    /**
     * No export community
     */
    noExportCommunity: string;
    /**
     * Onboarding type
     */
    onboardingType: string;
    /**
     * Protocol
     */
    protocol: outputs.GetServiceConnectionListDataProtocol;
    /**
     * Qos
     */
    qos: outputs.GetServiceConnectionListDataQos;
    /**
     * Region
     */
    region: string;
    /**
     * Secondary ipsec tunnel
     */
    secondaryIpsecTunnel: string;
    /**
     * Source nat
     */
    sourceNat: boolean;
    /**
     * Subnets
     */
    subnets: string[];
    tfid: string;
}

export interface GetServiceConnectionListDataBgpPeer {
    /**
     * Local ip address
     */
    localIpAddress: string;
    /**
     * Local ipv6 address
     */
    localIpv6Address: string;
    /**
     * Peer ip address
     */
    peerIpAddress: string;
    /**
     * Peer ipv6 address
     */
    peerIpv6Address: string;
    /**
     * Secret
     */
    secret: string;
}

export interface GetServiceConnectionListDataProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetServiceConnectionListDataProtocolBgp;
}

export interface GetServiceConnectionListDataProtocolBgp {
    /**
     * Do not export routes
     */
    doNotExportRoutes: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Local ip address
     */
    localIpAddress: string;
    /**
     * Originate default route
     */
    originateDefaultRoute: boolean;
    /**
     * Peer as
     */
    peerAs: string;
    /**
     * Peer ip address
     */
    peerIpAddress: string;
    /**
     * Secret
     */
    secret: string;
    /**
     * Summarize mobile user routes
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetServiceConnectionListDataQos {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Qos profile
     */
    qosProfile: string;
}

export interface GetServiceConnectionProtocol {
    /**
     * Bgp
     */
    bgp: outputs.GetServiceConnectionProtocolBgp;
}

export interface GetServiceConnectionProtocolBgp {
    /**
     * Do not export routes
     */
    doNotExportRoutes: boolean;
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Fast failover
     */
    fastFailover: boolean;
    /**
     * Local ip address
     */
    localIpAddress: string;
    /**
     * Originate default route
     */
    originateDefaultRoute: boolean;
    /**
     * Peer as
     */
    peerAs: string;
    /**
     * Peer ip address
     */
    peerIpAddress: string;
    /**
     * Secret
     */
    secret: string;
    /**
     * Summarize mobile user routes
     */
    summarizeMobileUserRoutes: boolean;
}

export interface GetServiceConnectionQos {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Qos profile
     */
    qosProfile: string;
}

export interface GetServiceGroupListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the service group
     */
    id: string;
    /**
     * Members
     */
    members: string[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tags associated with the service group
     */
    tags: string[];
    tfid: string;
}

export interface GetServiceListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the service
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Protocol
     */
    protocol: outputs.GetServiceListDataProtocol;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tags for service object
     */
    tags: string[];
    tfid: string;
}

export interface GetServiceListDataProtocol {
    /**
     * Tcp
     */
    tcp: outputs.GetServiceListDataProtocolTcp;
    /**
     * Udp
     *
     * > ℹ️ **Note:** You must specify exactly one of `tcp` and `udp`.
     */
    udp: outputs.GetServiceListDataProtocolUdp;
}

export interface GetServiceListDataProtocolTcp {
    /**
     * Override
     */
    override: outputs.GetServiceListDataProtocolTcpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort: string;
}

export interface GetServiceListDataProtocolTcpOverride {
    /**
     * tcp session half-close timeout value (in second)
     */
    halfcloseTimeout: number;
    /**
     * tcp session timeout value (in second)
     */
    timeout: number;
    /**
     * tcp session time-wait timeout value (in second)
     */
    timewaitTimeout: number;
}

export interface GetServiceListDataProtocolUdp {
    /**
     * Override
     */
    override: outputs.GetServiceListDataProtocolUdpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort: string;
}

export interface GetServiceListDataProtocolUdpOverride {
    /**
     * udp session timeout value (in second)
     */
    timeout: number;
}

export interface GetServiceProtocol {
    /**
     * Tcp
     */
    tcp: outputs.GetServiceProtocolTcp;
    /**
     * Udp
     *
     * > ℹ️ **Note:** You must specify exactly one of `tcp` and `udp`.
     */
    udp: outputs.GetServiceProtocolUdp;
}

export interface GetServiceProtocolTcp {
    /**
     * Override
     */
    override: outputs.GetServiceProtocolTcpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort: string;
}

export interface GetServiceProtocolTcpOverride {
    /**
     * tcp session half-close timeout value (in second)
     */
    halfcloseTimeout: number;
    /**
     * tcp session timeout value (in second)
     */
    timeout: number;
    /**
     * tcp session time-wait timeout value (in second)
     */
    timewaitTimeout: number;
}

export interface GetServiceProtocolUdp {
    /**
     * Override
     */
    override: outputs.GetServiceProtocolUdpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort: string;
}

export interface GetServiceProtocolUdpOverride {
    /**
     * udp session timeout value (in second)
     */
    timeout: number;
}

export interface GetServiceRouteListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Route
     */
    route: outputs.GetServiceRouteListDataRoute;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetServiceRouteListDataRoute {
    /**
     * Destination
     */
    destinations: outputs.GetServiceRouteListDataRouteDestination[];
    /**
     * Service
     */
    services: outputs.GetServiceRouteListDataRouteService[];
}

export interface GetServiceRouteListDataRouteDestination {
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: outputs.GetServiceRouteListDataRouteDestinationSource;
}

export interface GetServiceRouteListDataRouteDestinationSource {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceRouteListDataRouteService {
    /**
     * The follow list details the accepted `name` values and their corresponding service description.
     */
    name: string;
    /**
     * Source
     */
    source: outputs.GetServiceRouteListDataRouteServiceSource;
    /**
     * Source v6
     */
    sourceV6: outputs.GetServiceRouteListDataRouteServiceSourceV6;
}

export interface GetServiceRouteListDataRouteServiceSource {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceRouteListDataRouteServiceSourceV6 {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceRouteRoute {
    /**
     * Destination
     */
    destinations: outputs.GetServiceRouteRouteDestination[];
    /**
     * Service
     */
    services: outputs.GetServiceRouteRouteService[];
}

export interface GetServiceRouteRouteDestination {
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source: outputs.GetServiceRouteRouteDestinationSource;
}

export interface GetServiceRouteRouteDestinationSource {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceRouteRouteService {
    /**
     * The follow list details the accepted `name` values and their corresponding service description.
     */
    name: string;
    /**
     * Source
     */
    source: outputs.GetServiceRouteRouteServiceSource;
    /**
     * Source v6
     */
    sourceV6: outputs.GetServiceRouteRouteServiceSourceV6;
}

export interface GetServiceRouteRouteServiceSource {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceRouteRouteServiceSourceV6 {
    /**
     * Address
     */
    address: string;
    /**
     * Interface
     */
    interface: string;
}

export interface GetServiceSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Services
     */
    services: outputs.GetServiceSettingListDataServices;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetServiceSettingListDataServices {
    /**
     * Dns setting
     */
    dnsSetting: outputs.GetServiceSettingListDataServicesDnsSetting;
    /**
     * Fqdn refresh time
     */
    fqdnRefreshTime: number;
    /**
     * Fqdn stale entry timeout
     */
    fqdnStaleEntryTimeout: number;
    /**
     * Inline cloud proxy
     */
    inlineCloudProxy: boolean;
    /**
     * Lcaas use proxy
     */
    lcaasUseProxy: boolean;
    /**
     * Ntp servers
     */
    ntpServers: outputs.GetServiceSettingListDataServicesNtpServers;
    /**
     * Secure proxy password
     */
    secureProxyPassword: string;
    /**
     * Secure proxy port
     */
    secureProxyPort: number;
    /**
     * Secure proxy server
     */
    secureProxyServer: string;
    /**
     * Secure proxy user
     */
    secureProxyUser: string;
    /**
     * Server verification
     */
    serverVerification: boolean;
    /**
     * Update server
     */
    updateServer: string;
}

export interface GetServiceSettingListDataServicesDnsSetting {
    /**
     * Dns proxy object
     */
    dnsProxyObject: string;
    /**
     * Servers
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsProxyObject` and `servers`.
     */
    servers: outputs.GetServiceSettingListDataServicesDnsSettingServers;
}

export interface GetServiceSettingListDataServicesDnsSettingServers {
    /**
     * Primary
     */
    primary: string;
    /**
     * Secondary
     */
    secondary: string;
}

export interface GetServiceSettingListDataServicesNtpServers {
    /**
     * Primary ntp server
     */
    primaryNtpServer: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServer;
    /**
     * Secondary ntp server
     */
    secondaryNtpServer: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServer;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress: string;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey {
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeNone {
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId: number;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1: outputs.GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingListDataServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress: string;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey {
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeNone {
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId: number;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1: outputs.GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingListDataServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingServices {
    /**
     * Dns setting
     */
    dnsSetting: outputs.GetServiceSettingServicesDnsSetting;
    /**
     * Fqdn refresh time
     */
    fqdnRefreshTime: number;
    /**
     * Fqdn stale entry timeout
     */
    fqdnStaleEntryTimeout: number;
    /**
     * Inline cloud proxy
     */
    inlineCloudProxy: boolean;
    /**
     * Lcaas use proxy
     */
    lcaasUseProxy: boolean;
    /**
     * Ntp servers
     */
    ntpServers: outputs.GetServiceSettingServicesNtpServers;
    /**
     * Secure proxy password
     */
    secureProxyPassword: string;
    /**
     * Secure proxy port
     */
    secureProxyPort: number;
    /**
     * Secure proxy server
     */
    secureProxyServer: string;
    /**
     * Secure proxy user
     */
    secureProxyUser: string;
    /**
     * Server verification
     */
    serverVerification: boolean;
    /**
     * Update server
     */
    updateServer: string;
}

export interface GetServiceSettingServicesDnsSetting {
    /**
     * Dns proxy object
     */
    dnsProxyObject: string;
    /**
     * Servers
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsProxyObject` and `servers`.
     */
    servers: outputs.GetServiceSettingServicesDnsSettingServers;
}

export interface GetServiceSettingServicesDnsSettingServers {
    /**
     * Primary
     */
    primary: string;
    /**
     * Secondary
     */
    secondary: string;
}

export interface GetServiceSettingServicesNtpServers {
    /**
     * Primary ntp server
     */
    primaryNtpServer: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServer;
    /**
     * Secondary ntp server
     */
    secondaryNtpServer: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServer;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress: string;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey {
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNone {
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId: number;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1: outputs.GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress: string;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey {
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNone {
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId: number;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1: outputs.GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey: string;
}

export interface GetSessionSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Session settings
     */
    sessionSettings: outputs.GetSessionSettingListDataSessionSettings;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSessionSettingListDataSessionSettings {
    /**
     * Enable accelerated aging
     */
    acceleratedAgingEnable: boolean;
    /**
     * Accelerated aging scaling factor
     */
    acceleratedAgingScalingFactor: number;
    /**
     * Accelerated aging threshold
     */
    acceleratedAgingThreshold: number;
    /**
     * Config
     */
    config: outputs.GetSessionSettingListDataSessionSettingsConfig;
    /**
     * Enable DHCP broadcast session
     */
    dhcpBcastSessionOn: boolean;
    /**
     * Enable ERSPAN support
     */
    erspan: boolean;
    /**
     * ICMP unreachable packet rate (per second)
     */
    icmpUnreachableRate: number;
    /**
     * ICMPv6 rate limiting
     */
    icmpv6RateLimit: outputs.GetSessionSettingListDataSessionSettingsIcmpv6RateLimit;
    /**
     * Enable IPv6 firewalling
     */
    ipv6Firewalling: boolean;
    /**
     * Enable jumbo frame support
     */
    jumboFrame: outputs.GetSessionSettingListDataSessionSettingsJumboFrame;
    /**
     * Multicast route setup buffer size
     */
    maxPendingMcastPktsPerSession: number;
    /**
     * Multicast route setup buffering
     */
    multicastRouteSetupBuffering: boolean;
    /**
     * Nat
     */
    nat: outputs.GetSessionSettingListDataSessionSettingsNat;
    /**
     * Nat64
     */
    nat64: outputs.GetSessionSettingListDataSessionSettingsNat64;
    /**
     * Activate (%)
     */
    packetBufferProtectionActivate: number;
    /**
     * Alert (%)
     */
    packetBufferProtectionAlert: number;
    /**
     * Block countdown threshold (%)
     */
    packetBufferProtectionBlockCountdown: number;
    /**
     * Block duration (seconds)
     */
    packetBufferProtectionBlockDurationTime: number;
    /**
     * Block hold time (seconds)
     */
    packetBufferProtectionBlockHoldTime: number;
    /**
     * Enable packet buffer protection
     */
    packetBufferProtectionEnable: boolean;
    /**
     * Latency activate (milliseconds)
     */
    packetBufferProtectionLatencyActivate: number;
    /**
     * Latency alert (milliseconds)
     */
    packetBufferProtectionLatencyAlert: number;
    /**
     * Block countdown threshold (milliseconds)
     */
    packetBufferProtectionLatencyBlockCountdown: number;
    /**
     * Latency max tolerate (milliseconds)
     */
    packetBufferProtectionLatencyMaxTolerate: number;
    /**
     * Packet buffer protection monitor only
     */
    packetBufferProtectionMonitorOnly: boolean;
    /**
     * Enabled latency-based activation
     */
    packetBufferProtectionUseLatency: boolean;
}

export interface GetSessionSettingListDataSessionSettingsConfig {
    /**
     * Rematch all sessions on config policy change
     */
    rematch: boolean;
}

export interface GetSessionSettingListDataSessionSettingsIcmpv6RateLimit {
    /**
     * ICMPv6 token bucket size
     */
    bucketSize: number;
    /**
     * ICMPv6 error packet pate (per second)
     */
    packetRate: number;
}

export interface GetSessionSettingListDataSessionSettingsJumboFrame {
    /**
     * Global MTU
     */
    mtu: number;
}

export interface GetSessionSettingListDataSessionSettingsNat {
    /**
     * NAT oversubscription rate
     */
    dippOversub: string;
}

export interface GetSessionSettingListDataSessionSettingsNat64 {
    /**
     * NAT64 IPv6 minimum network MTU
     */
    ipv6MinNetworkMtu: number;
}

export interface GetSessionSettingSessionSettings {
    /**
     * Enable accelerated aging
     */
    acceleratedAgingEnable: boolean;
    /**
     * Accelerated aging scaling factor
     */
    acceleratedAgingScalingFactor: number;
    /**
     * Accelerated aging threshold
     */
    acceleratedAgingThreshold: number;
    /**
     * Config
     */
    config: outputs.GetSessionSettingSessionSettingsConfig;
    /**
     * Enable DHCP broadcast session
     */
    dhcpBcastSessionOn: boolean;
    /**
     * Enable ERSPAN support
     */
    erspan: boolean;
    /**
     * ICMP unreachable packet rate (per second)
     */
    icmpUnreachableRate: number;
    /**
     * ICMPv6 rate limiting
     */
    icmpv6RateLimit: outputs.GetSessionSettingSessionSettingsIcmpv6RateLimit;
    /**
     * Enable IPv6 firewalling
     */
    ipv6Firewalling: boolean;
    /**
     * Enable jumbo frame support
     */
    jumboFrame: outputs.GetSessionSettingSessionSettingsJumboFrame;
    /**
     * Multicast route setup buffer size
     */
    maxPendingMcastPktsPerSession: number;
    /**
     * Multicast route setup buffering
     */
    multicastRouteSetupBuffering: boolean;
    /**
     * Nat
     */
    nat: outputs.GetSessionSettingSessionSettingsNat;
    /**
     * Nat64
     */
    nat64: outputs.GetSessionSettingSessionSettingsNat64;
    /**
     * Activate (%)
     */
    packetBufferProtectionActivate: number;
    /**
     * Alert (%)
     */
    packetBufferProtectionAlert: number;
    /**
     * Block countdown threshold (%)
     */
    packetBufferProtectionBlockCountdown: number;
    /**
     * Block duration (seconds)
     */
    packetBufferProtectionBlockDurationTime: number;
    /**
     * Block hold time (seconds)
     */
    packetBufferProtectionBlockHoldTime: number;
    /**
     * Enable packet buffer protection
     */
    packetBufferProtectionEnable: boolean;
    /**
     * Latency activate (milliseconds)
     */
    packetBufferProtectionLatencyActivate: number;
    /**
     * Latency alert (milliseconds)
     */
    packetBufferProtectionLatencyAlert: number;
    /**
     * Block countdown threshold (milliseconds)
     */
    packetBufferProtectionLatencyBlockCountdown: number;
    /**
     * Latency max tolerate (milliseconds)
     */
    packetBufferProtectionLatencyMaxTolerate: number;
    /**
     * Packet buffer protection monitor only
     */
    packetBufferProtectionMonitorOnly: boolean;
    /**
     * Enabled latency-based activation
     */
    packetBufferProtectionUseLatency: boolean;
}

export interface GetSessionSettingSessionSettingsConfig {
    /**
     * Rematch all sessions on config policy change
     */
    rematch: boolean;
}

export interface GetSessionSettingSessionSettingsIcmpv6RateLimit {
    /**
     * ICMPv6 token bucket size
     */
    bucketSize: number;
    /**
     * ICMPv6 error packet pate (per second)
     */
    packetRate: number;
}

export interface GetSessionSettingSessionSettingsJumboFrame {
    /**
     * Global MTU
     */
    mtu: number;
}

export interface GetSessionSettingSessionSettingsNat {
    /**
     * NAT oversubscription rate
     */
    dippOversub: string;
}

export interface GetSessionSettingSessionSettingsNat64 {
    /**
     * NAT64 IPv6 minimum network MTU
     */
    ipv6MinNetworkMtu: number;
}

export interface GetSessionTimeoutListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Session timeouts
     */
    sessionTimeouts: outputs.GetSessionTimeoutListDataSessionTimeouts;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSessionTimeoutListDataSessionTimeouts {
    /**
     * Captive Portal (seconds)
     */
    timeoutCaptivePortal: number;
    /**
     * Default timeout (seconds)
     */
    timeoutDefault: number;
    /**
     * Discard default (seconds)
     */
    timeoutDiscardDefault: number;
    /**
     * Discard TCP (seconds)
     */
    timeoutDiscardTcp: number;
    /**
     * Discard UDP (seconds)
     */
    timeoutDiscardUdp: number;
    /**
     * ICMP (seconds)
     */
    timeoutIcmp: number;
    /**
     * Scan (seconds)
     */
    timeoutScan: number;
    /**
     * TCP (seconds)
     */
    timeoutTcp: number;
    /**
     * TCP Half Closed (seconds)
     */
    timeoutTcpHalfClosed: number;
    /**
     * TCP Time Wait (seconds)
     */
    timeoutTcpTimeWait: number;
    /**
     * Unverified RST (seconds)
     */
    timeoutTcpUnverifiedRst: number;
    /**
     * TCP handshake (seconds)
     */
    timeoutTcphandshake: number;
    /**
     * TCP init (seconds)
     */
    timeoutTcpinit: number;
    /**
     * UDP (seconds)
     */
    timeoutUdp: number;
}

export interface GetSessionTimeoutSessionTimeouts {
    /**
     * Captive Portal (seconds)
     */
    timeoutCaptivePortal: number;
    /**
     * Default timeout (seconds)
     */
    timeoutDefault: number;
    /**
     * Discard default (seconds)
     */
    timeoutDiscardDefault: number;
    /**
     * Discard TCP (seconds)
     */
    timeoutDiscardTcp: number;
    /**
     * Discard UDP (seconds)
     */
    timeoutDiscardUdp: number;
    /**
     * ICMP (seconds)
     */
    timeoutIcmp: number;
    /**
     * Scan (seconds)
     */
    timeoutScan: number;
    /**
     * TCP (seconds)
     */
    timeoutTcp: number;
    /**
     * TCP Half Closed (seconds)
     */
    timeoutTcpHalfClosed: number;
    /**
     * TCP Time Wait (seconds)
     */
    timeoutTcpTimeWait: number;
    /**
     * Unverified RST (seconds)
     */
    timeoutTcpUnverifiedRst: number;
    /**
     * TCP handshake (seconds)
     */
    timeoutTcphandshake: number;
    /**
     * TCP init (seconds)
     */
    timeoutTcpinit: number;
    /**
     * UDP (seconds)
     */
    timeoutUdp: number;
}

export interface GetSiteListData {
    /**
     * The address in which the site exists
     */
    addressLine1: string;
    /**
     * The address in which the site exists (continued)
     */
    addressLine2: string;
    /**
     * The city in which the site exists
     */
    city: string;
    /**
     * The country in which the site exists
     */
    country: string;
    /**
     * The folder in which the resource is defined
     */
    folder: string;
    /**
     * The UUID of the site
     */
    id: string;
    /**
     * The latitude coordinate for the site
     */
    latitude: string;
    /**
     * The license type of the site
     */
    licenseType: string;
    /**
     * The longitude coordinate for the site
     */
    longitude: string;
    /**
     * Members
     */
    members: outputs.GetSiteListDataMember[];
    /**
     * The name of the site
     */
    name: string;
    /**
     * Qos
     */
    qos: outputs.GetSiteListDataQos;
    /**
     * The state in which the site exists
     */
    state: string;
    tfid: string;
    /**
     * The site type
     */
    type: string;
    /**
     * The postal code in which the site exists
     */
    zipCode: string;
}

export interface GetSiteListDataMember {
    /**
     * UUID of the remote network
     */
    id: string;
    /**
     * The mode of the remote network
     */
    mode: string;
    /**
     * The member name
     */
    name: string;
    /**
     * The remote network name
     */
    remoteNetwork: string;
}

export interface GetSiteListDataQos {
    /**
     * The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    backupCir: number;
    /**
     * The CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    cir: number;
    /**
     * The name of the site QoS profile
     */
    profile: string;
}

export interface GetSiteMember {
    /**
     * UUID of the remote network
     */
    id: string;
    /**
     * The mode of the remote network
     */
    mode: string;
    /**
     * The member name
     */
    name: string;
    /**
     * The remote network name
     */
    remoteNetwork: string;
}

export interface GetSiteQos {
    /**
     * The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    backupCir: number;
    /**
     * The CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    cir: number;
    /**
     * The name of the site QoS profile
     */
    profile: string;
}

export interface GetSnippetListData {
    /**
     * The description of the snippet
     */
    description: string;
    /**
     * The UUID of the snippet
     */
    id: string;
    /**
     * Labels applied to the snippet
     */
    labels: string[];
    /**
     * The name of the snippet
     */
    name: string;
    tfid: string;
    /**
     * The snippet type
     */
    type: string;
}

export interface GetSyslogServerProfileFormat {
    /**
     * Auth
     */
    auth: string;
    /**
     * Config
     */
    config: string;
    /**
     * Correlation
     */
    correlation: string;
    /**
     * Data
     */
    data: string;
    /**
     * Decryption
     */
    decryption: string;
    /**
     * Escaping
     */
    escaping: outputs.GetSyslogServerProfileFormatEscaping;
    /**
     * Globalprotect
     */
    globalprotect: string;
    /**
     * Gtp
     */
    gtp: string;
    /**
     * Hip match
     */
    hipMatch: string;
    /**
     * Iptag
     */
    iptag: string;
    /**
     * Sctp
     */
    sctp: string;
    /**
     * System
     */
    system: string;
    /**
     * Threat
     */
    threat: string;
    /**
     * Traffic
     */
    traffic: string;
    /**
     * Tunnel
     */
    tunnel: string;
    /**
     * Url
     */
    url: string;
    /**
     * Userid
     */
    userid: string;
    /**
     * Wildfire
     */
    wildfire: string;
}

export interface GetSyslogServerProfileFormatEscaping {
    /**
     * Escape sequence delimiter
     */
    escapeCharacter: string;
    /**
     * A list of all the characters to be escaped (without spaces).
     */
    escapedCharacters: string;
}

export interface GetSyslogServerProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * Format
     */
    format: outputs.GetSyslogServerProfileListDataFormat;
    /**
     * The UUID of the syslog server profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * A list of syslog server configurations. At least one server is required.
     */
    servers: outputs.GetSyslogServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetSyslogServerProfileListDataFormat {
    /**
     * Auth
     */
    auth: string;
    /**
     * Config
     */
    config: string;
    /**
     * Correlation
     */
    correlation: string;
    /**
     * Data
     */
    data: string;
    /**
     * Decryption
     */
    decryption: string;
    /**
     * Escaping
     */
    escaping: outputs.GetSyslogServerProfileListDataFormatEscaping;
    /**
     * Globalprotect
     */
    globalprotect: string;
    /**
     * Gtp
     */
    gtp: string;
    /**
     * Hip match
     */
    hipMatch: string;
    /**
     * Iptag
     */
    iptag: string;
    /**
     * Sctp
     */
    sctp: string;
    /**
     * System
     */
    system: string;
    /**
     * Threat
     */
    threat: string;
    /**
     * Traffic
     */
    traffic: string;
    /**
     * Tunnel
     */
    tunnel: string;
    /**
     * Url
     */
    url: string;
    /**
     * Userid
     */
    userid: string;
    /**
     * Wildfire
     */
    wildfire: string;
}

export interface GetSyslogServerProfileListDataFormatEscaping {
    /**
     * Escape sequence delimiter
     */
    escapeCharacter: string;
    /**
     * A list of all the characters to be escaped (without spaces).
     */
    escapedCharacters: string;
}

export interface GetSyslogServerProfileListDataServer {
    /**
     * Syslog facility
     */
    facility: string;
    /**
     * Syslog format
     */
    format: string;
    /**
     * Syslog server name
     */
    name: string;
    /**
     * Syslog server port
     */
    port: number;
    /**
     * Syslog server address
     */
    server: string;
    /**
     * Transport protocol
     */
    transport: string;
}

export interface GetSyslogServerProfileServer {
    /**
     * Syslog facility
     */
    facility: string;
    /**
     * Syslog format
     */
    format: string;
    /**
     * Syslog server name
     */
    name: string;
    /**
     * Syslog server port
     */
    port: number;
    /**
     * Syslog server address
     */
    server: string;
    /**
     * Transport protocol
     */
    transport: string;
}

export interface GetTacacsServerProfileListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Map of sensitive values returned from the API.
     */
    encryptedValues: {[key: string]: string};
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the TACACS+ server profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The TACACS+ authentication protocol
     */
    protocol: string;
    /**
     * The TACACS+ server configuration
     */
    servers: outputs.GetTacacsServerProfileListDataServer[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * The TACACS+ timeout (seconds)
     */
    timeout: number;
    /**
     * Use a single TACACS+ connection?
     */
    useSingleConnection: boolean;
}

export interface GetTacacsServerProfileListDataServer {
    /**
     * The IP address of the TACACS+ server
     */
    address: string;
    /**
     * The name of the TACACS+ server
     */
    name: string;
    /**
     * The TACACS+ server port
     */
    port: number;
    /**
     * The TACACS+ secret
     */
    secret: string;
}

export interface GetTacacsServerProfileServer {
    /**
     * The IP address of the TACACS+ server
     */
    address: string;
    /**
     * The name of the TACACS+ server
     */
    name: string;
    /**
     * The TACACS+ server port
     */
    port: number;
    /**
     * The TACACS+ secret
     */
    secret: string;
}

export interface GetTagListData {
    /**
     * The color of the tag
     */
    color: string;
    /**
     * The description of the tag
     */
    comments: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the tag
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetTcpSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    /**
     * Tcp
     */
    tcp: outputs.GetTcpSettingListDataTcp;
    tfid: string;
}

export interface GetTcpSettingListDataTcp {
    /**
     * Allow arbitrary ACK in response to SYN?
     */
    allowChallengeAck: boolean;
    /**
     * Asymmetric path action
     */
    asymmetricPath: string;
    /**
     * Forward segments exceeding TCP out-of-order queue?
     */
    bypassExceedOoQueue: boolean;
    /**
     * Drop segments with null timestamp option?
     */
    checkTimestampOption: boolean;
    /**
     * Drop segments without flag?
     */
    dropZeroFlag: boolean;
    /**
     * SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
     */
    siptcpCleartextProxy: string;
    /**
     * Strip MPTCP option?
     */
    stripMptcpOption: boolean;
    /**
     * TCP retransmit scan?
     */
    tcpRetransmitScan: boolean;
    /**
     * Urgent data flag action
     */
    urgentData: string;
}

export interface GetTcpSettingTcp {
    /**
     * Allow arbitrary ACK in response to SYN?
     */
    allowChallengeAck: boolean;
    /**
     * Asymmetric path action
     */
    asymmetricPath: string;
    /**
     * Forward segments exceeding TCP out-of-order queue?
     */
    bypassExceedOoQueue: boolean;
    /**
     * Drop segments with null timestamp option?
     */
    checkTimestampOption: boolean;
    /**
     * Drop segments without flag?
     */
    dropZeroFlag: boolean;
    /**
     * SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
     */
    siptcpCleartextProxy: string;
    /**
     * Strip MPTCP option?
     */
    stripMptcpOption: boolean;
    /**
     * TCP retransmit scan?
     */
    tcpRetransmitScan: boolean;
    /**
     * Urgent data flag action
     */
    urgentData: string;
}

export interface GetTlsServiceProfileListData {
    /**
     * Certificate name
     */
    certificate: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * The UUID of the TLS service profile
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Protocol settings
     */
    protocolSettings: outputs.GetTlsServiceProfileListDataProtocolSettings;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetTlsServiceProfileListDataProtocolSettings {
    /**
     * Allow SHA1 authentication?
     */
    authAlgoSha1: boolean;
    /**
     * Allow SHA256 authentication?
     */
    authAlgoSha256: boolean;
    /**
     * Allow SHA384 authentication?
     */
    authAlgoSha384: boolean;
    /**
     * Allow AES-128-CBC algorithm?
     */
    encAlgoAes128Cbc: boolean;
    /**
     * Allow AES-128-GCM algorithm?
     */
    encAlgoAes128Gcm: boolean;
    /**
     * Allow AES-256-CBC algorithm?
     */
    encAlgoAes256Cbc: boolean;
    /**
     * Allow algorithm AES-256-GCM
     */
    encAlgoAes256Gcm: boolean;
    /**
     * Allow DHE algorithm?
     */
    keyxchgAlgoDhe: boolean;
    /**
     * Allow ECDHE algorithm?
     */
    keyxchgAlgoEcdhe: boolean;
    /**
     * Allow RSA algorithm?
     */
    keyxchgAlgoRsa: boolean;
    /**
     * Maximum TLS version
     */
    maxVersion: string;
    /**
     * Minimum TLS version
     */
    minVersion: string;
}

export interface GetTlsServiceProfileProtocolSettings {
    /**
     * Allow SHA1 authentication?
     */
    authAlgoSha1: boolean;
    /**
     * Allow SHA256 authentication?
     */
    authAlgoSha256: boolean;
    /**
     * Allow SHA384 authentication?
     */
    authAlgoSha384: boolean;
    /**
     * Allow AES-128-CBC algorithm?
     */
    encAlgoAes128Cbc: boolean;
    /**
     * Allow AES-128-GCM algorithm?
     */
    encAlgoAes128Gcm: boolean;
    /**
     * Allow AES-256-CBC algorithm?
     */
    encAlgoAes256Cbc: boolean;
    /**
     * Allow algorithm AES-256-GCM
     */
    encAlgoAes256Gcm: boolean;
    /**
     * Allow DHE algorithm?
     */
    keyxchgAlgoDhe: boolean;
    /**
     * Allow ECDHE algorithm?
     */
    keyxchgAlgoEcdhe: boolean;
    /**
     * Allow RSA algorithm?
     */
    keyxchgAlgoRsa: boolean;
    /**
     * Maximum TLS version
     */
    maxVersion: string;
    /**
     * Minimum TLS version
     */
    minVersion: string;
}

export interface GetTrafficSteeringRuleAction {
    /**
     * Forward
     */
    forward: outputs.GetTrafficSteeringRuleActionForward;
}

export interface GetTrafficSteeringRuleActionForward {
    /**
     * Forward
     */
    forward: outputs.GetTrafficSteeringRuleActionForwardForward;
    /**
     * No pbf
     */
    noPbf: outputs.GetTrafficSteeringRuleActionForwardNoPbf;
}

export interface GetTrafficSteeringRuleActionForwardForward {
    /**
     * Target
     */
    target: string;
}

export interface GetTrafficSteeringRuleActionForwardNoPbf {
}

export interface GetTrafficSteeringRuleListData {
    /**
     * Action
     */
    action: outputs.GetTrafficSteeringRuleListDataAction;
    /**
     * Category
     */
    categories: string[];
    /**
     * Destination
     */
    destinations: string[];
    /**
     * The folder containing the traffic steering rule
     */
    folder: string;
    /**
     * The UUID of the traffic steering rule
     */
    id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Service
     */
    services: string[];
    /**
     * Source user
     */
    sourceUsers: string[];
    /**
     * Source
     */
    sources: string[];
    tfid: string;
}

export interface GetTrafficSteeringRuleListDataAction {
    /**
     * Forward
     */
    forward: outputs.GetTrafficSteeringRuleListDataActionForward;
}

export interface GetTrafficSteeringRuleListDataActionForward {
    /**
     * Forward
     */
    forward: outputs.GetTrafficSteeringRuleListDataActionForwardForward;
    /**
     * No pbf
     */
    noPbf: outputs.GetTrafficSteeringRuleListDataActionForwardNoPbf;
}

export interface GetTrafficSteeringRuleListDataActionForwardForward {
    /**
     * Target
     */
    target: string;
}

export interface GetTrafficSteeringRuleListDataActionForwardNoPbf {
}

export interface GetTunnelInterfaceIp {
    /**
     * Tunnel Interface IP address(es)
     */
    name: string;
}

export interface GetTunnelInterfaceIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses: outputs.GetTunnelInterfaceIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface GetTunnelInterfaceIpv6Address {
    /**
     * Anycast
     */
    anycast: outputs.GetTunnelInterfaceIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name: string;
    /**
     * Use interface ID as host portion
     */
    prefix: outputs.GetTunnelInterfaceIpv6AddressPrefix;
}

export interface GetTunnelInterfaceIpv6AddressAnycast {
}

export interface GetTunnelInterfaceIpv6AddressPrefix {
}

export interface GetTunnelInterfaceListData {
    /**
     * Description
     */
    comment: string;
    /**
     * Default interface assignment
     */
    defaultValue: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * Tunnel Interface IP Parent
     */
    ips: outputs.GetTunnelInterfaceListDataIp[];
    /**
     * Tunnel Interface IPv6 Configuration
     */
    ipv6: outputs.GetTunnelInterfaceListDataIpv6;
    /**
     * MTU
     */
    mtu: number;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetTunnelInterfaceListDataIp {
    /**
     * Tunnel Interface IP address(es)
     */
    name: string;
}

export interface GetTunnelInterfaceListDataIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses: outputs.GetTunnelInterfaceListDataIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface GetTunnelInterfaceListDataIpv6Address {
    /**
     * Anycast
     */
    anycast: outputs.GetTunnelInterfaceListDataIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name: string;
    /**
     * Use interface ID as host portion
     */
    prefix: outputs.GetTunnelInterfaceListDataIpv6AddressPrefix;
}

export interface GetTunnelInterfaceListDataIpv6AddressAnycast {
}

export interface GetTunnelInterfaceListDataIpv6AddressPrefix {
}

export interface GetUpdateScheduleListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Update schedule
     */
    updateSchedule: outputs.GetUpdateScheduleListDataUpdateSchedule;
}

export interface GetUpdateScheduleListDataUpdateSchedule {
    /**
     * Anti virus
     */
    antiVirus: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirus;
    /**
     * Threats
     */
    threats: outputs.GetUpdateScheduleListDataUpdateScheduleThreats;
    /**
     * Wildfire
     */
    wildfire: outputs.GetUpdateScheduleListDataUpdateScheduleWildfire;
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirus {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurring;
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurring {
    /**
     * Daily
     */
    daily: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringDaily;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    hourly: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringHourly;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    none: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    weekly: outputs.GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringWeekly;
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringDaily {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringHourly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringNone {
}

export interface GetUpdateScheduleListDataUpdateScheduleAntiVirusRecurringWeekly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreats {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurring;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurring {
    /**
     * Daily
     */
    daily: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurringDaily;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    every30Mins: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurringEvery30Mins;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    hourly: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurringHourly;
    /**
     * New app threshold
     */
    newAppThreshold: number;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    none: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    weekly: outputs.GetUpdateScheduleListDataUpdateScheduleThreatsRecurringWeekly;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurringDaily {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurringEvery30Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurringHourly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurringNone {
}

export interface GetUpdateScheduleListDataUpdateScheduleThreatsRecurringWeekly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfire {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurring;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurring {
    /**
     * Every15 mins
     */
    every15Mins: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEvery15Mins;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    every30Mins: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEvery30Mins;
    /**
     * Every hour
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyHour: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEveryHour;
    /**
     * Every min
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyMin: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEveryMin;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    none: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringNone;
    /**
     * Real time
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    realTime: outputs.GetUpdateScheduleListDataUpdateScheduleWildfireRecurringRealTime;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEvery15Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEvery30Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEveryHour {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringEveryMin {
    /**
     * Action
     */
    action: string;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringNone {
}

export interface GetUpdateScheduleListDataUpdateScheduleWildfireRecurringRealTime {
}

export interface GetUpdateScheduleUpdateSchedule {
    /**
     * Anti virus
     */
    antiVirus: outputs.GetUpdateScheduleUpdateScheduleAntiVirus;
    /**
     * Threats
     */
    threats: outputs.GetUpdateScheduleUpdateScheduleThreats;
    /**
     * Wildfire
     */
    wildfire: outputs.GetUpdateScheduleUpdateScheduleWildfire;
}

export interface GetUpdateScheduleUpdateScheduleAntiVirus {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleUpdateScheduleAntiVirusRecurring;
}

export interface GetUpdateScheduleUpdateScheduleAntiVirusRecurring {
    /**
     * Daily
     */
    daily: outputs.GetUpdateScheduleUpdateScheduleAntiVirusRecurringDaily;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    hourly: outputs.GetUpdateScheduleUpdateScheduleAntiVirusRecurringHourly;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    none: outputs.GetUpdateScheduleUpdateScheduleAntiVirusRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    weekly: outputs.GetUpdateScheduleUpdateScheduleAntiVirusRecurringWeekly;
}

export interface GetUpdateScheduleUpdateScheduleAntiVirusRecurringDaily {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
}

export interface GetUpdateScheduleUpdateScheduleAntiVirusRecurringHourly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
}

export interface GetUpdateScheduleUpdateScheduleAntiVirusRecurringNone {
}

export interface GetUpdateScheduleUpdateScheduleAntiVirusRecurringWeekly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
}

export interface GetUpdateScheduleUpdateScheduleThreats {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurring;
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurring {
    /**
     * Daily
     */
    daily: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurringDaily;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    every30Mins: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurringEvery30Mins;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    hourly: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurringHourly;
    /**
     * New app threshold
     */
    newAppThreshold: number;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    none: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    weekly: outputs.GetUpdateScheduleUpdateScheduleThreatsRecurringWeekly;
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurringDaily {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurringEvery30Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurringHourly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurringNone {
}

export interface GetUpdateScheduleUpdateScheduleThreatsRecurringWeekly {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface GetUpdateScheduleUpdateScheduleWildfire {
    /**
     * Recurring
     */
    recurring: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurring;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurring {
    /**
     * Every15 mins
     */
    every15Mins: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringEvery15Mins;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    every30Mins: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringEvery30Mins;
    /**
     * Every hour
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyHour: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringEveryHour;
    /**
     * Every min
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyMin: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringEveryMin;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    none: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringNone;
    /**
     * Real time
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    realTime: outputs.GetUpdateScheduleUpdateScheduleWildfireRecurringRealTime;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringEvery15Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringEvery30Mins {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringEveryHour {
    /**
     * Action
     */
    action: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringEveryMin {
    /**
     * Action
     */
    action: string;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringNone {
}

export interface GetUpdateScheduleUpdateScheduleWildfireRecurringRealTime {
}

export interface GetUrlAccessProfileCredentialEnforcement {
    /**
     * Alert
     */
    alerts: string[];
    /**
     * Allow
     */
    allows: string[];
    /**
     * Block
     */
    blocks: string[];
    /**
     * Continue
     */
    continues: string[];
    /**
     * Log severity
     */
    logSeverity: string;
    /**
     * Mode
     */
    mode: outputs.GetUrlAccessProfileCredentialEnforcementMode;
}

export interface GetUrlAccessProfileCredentialEnforcementMode {
    /**
     * Disabled
     */
    disabled: outputs.GetUrlAccessProfileCredentialEnforcementModeDisabled;
    /**
     * Domain credentials
     */
    domainCredentials: outputs.GetUrlAccessProfileCredentialEnforcementModeDomainCredentials;
    /**
     * Group mapping
     */
    groupMapping: string;
    /**
     * Ip user
     */
    ipUser: outputs.GetUrlAccessProfileCredentialEnforcementModeIpUser;
}

export interface GetUrlAccessProfileCredentialEnforcementModeDisabled {
}

export interface GetUrlAccessProfileCredentialEnforcementModeDomainCredentials {
}

export interface GetUrlAccessProfileCredentialEnforcementModeIpUser {
}

export interface GetUrlAccessProfileListData {
    /**
     * Alert
     */
    alerts: string[];
    /**
     * Allow
     */
    allows: string[];
    /**
     * Block
     */
    blocks: string[];
    /**
     * Cloud inline cat
     */
    cloudInlineCat: boolean;
    /**
     * Continue
     */
    continues: string[];
    /**
     * Credential enforcement
     */
    credentialEnforcement: outputs.GetUrlAccessProfileListDataCredentialEnforcement;
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Local inline cat
     */
    localInlineCat: boolean;
    /**
     * Log container page only
     */
    logContainerPageOnly: boolean;
    /**
     * Log http hdr referer
     */
    logHttpHdrReferer: boolean;
    /**
     * Log http hdr user agent
     */
    logHttpHdrUserAgent: boolean;
    /**
     * Log http hdr xff
     */
    logHttpHdrXff: boolean;
    /**
     * Mlav category exception
     */
    mlavCategoryExceptions: string[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Redirect
     */
    redirects: string[];
    /**
     * Safe search enforcement
     */
    safeSearchEnforcement: boolean;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
}

export interface GetUrlAccessProfileListDataCredentialEnforcement {
    /**
     * Alert
     */
    alerts: string[];
    /**
     * Allow
     */
    allows: string[];
    /**
     * Block
     */
    blocks: string[];
    /**
     * Continue
     */
    continues: string[];
    /**
     * Log severity
     */
    logSeverity: string;
    /**
     * Mode
     */
    mode: outputs.GetUrlAccessProfileListDataCredentialEnforcementMode;
}

export interface GetUrlAccessProfileListDataCredentialEnforcementMode {
    /**
     * Disabled
     */
    disabled: outputs.GetUrlAccessProfileListDataCredentialEnforcementModeDisabled;
    /**
     * Domain credentials
     */
    domainCredentials: outputs.GetUrlAccessProfileListDataCredentialEnforcementModeDomainCredentials;
    /**
     * Group mapping
     */
    groupMapping: string;
    /**
     * Ip user
     */
    ipUser: outputs.GetUrlAccessProfileListDataCredentialEnforcementModeIpUser;
}

export interface GetUrlAccessProfileListDataCredentialEnforcementModeDisabled {
}

export interface GetUrlAccessProfileListDataCredentialEnforcementModeDomainCredentials {
}

export interface GetUrlAccessProfileListDataCredentialEnforcementModeIpUser {
}

export interface GetUrlCategoryListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * List
     */
    lists: string[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Type
     */
    type: string;
}

export interface GetVariableListData {
    /**
     * The description of the variable
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the variable
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Is the variable overridden?
     */
    overridden: boolean;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * The variable type
     */
    type: string;
    /**
     * The value of the variable
     */
    value: string;
}

export interface GetVlanInterfaceArp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * ARP interface
     */
    interface: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetVlanInterfaceDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetVlanInterfaceDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Send hostname
     */
    sendHostname: outputs.GetVlanInterfaceDhcpClientSendHostname;
}

export interface GetVlanInterfaceDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetVlanInterfaceIp {
    /**
     * VLAN Interface IP address(es)
     */
    name: string;
}

export interface GetVlanInterfaceListData {
    /**
     * ARP configuration
     */
    arps: outputs.GetVlanInterfaceListDataArp[];
    /**
     * Description
     */
    comment: string;
    /**
     * Dynamic DNS configuration specific to the Vlan Interfaces.
     */
    ddnsConfig: outputs.GetVlanInterfaceListDataDdnsConfig;
    /**
     * Default interface assignment
     */
    defaultValue: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Vlan interfaces DHCP Client Object
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    dhcpClient: outputs.GetVlanInterfaceListDataDhcpClient;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Interface management profile
     */
    interfaceManagementProfile: string;
    /**
     * VLAN Interface IP Parent
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `ip`.
     */
    ips: outputs.GetVlanInterfaceListDataIp[];
    /**
     * MTU
     */
    mtu: number;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * VLAN tag
     */
    vlanTag: string;
}

export interface GetVlanInterfaceListDataArp {
    /**
     * MAC address
     */
    hwAddress: string;
    /**
     * ARP interface
     */
    interface: string;
    /**
     * IP address
     */
    name: string;
}

export interface GetVlanInterfaceListDataDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface GetVlanInterfaceListDataDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Send hostname
     */
    sendHostname: outputs.GetVlanInterfaceListDataDhcpClientSendHostname;
}

export interface GetVlanInterfaceListDataDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface GetVlanInterfaceListDataIp {
    /**
     * VLAN Interface IP address(es)
     */
    name: string;
}

export interface GetVpnSettingListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Vpn
     */
    vpn: outputs.GetVpnSettingListDataVpn;
}

export interface GetVpnSettingListDataVpn {
    /**
     * Ikev2
     */
    ikev2: outputs.GetVpnSettingListDataVpnIkev2;
}

export interface GetVpnSettingListDataVpnIkev2 {
    /**
     * Maximum cached certificates
     */
    certificateCacheSize: number;
    /**
     * Cookie activation threshold
     */
    cookieThreshold: number;
    /**
     * Maximum half-opened SA
     */
    maxHalfOpenedSa: number;
}

export interface GetVpnSettingVpn {
    /**
     * Ikev2
     */
    ikev2: outputs.GetVpnSettingVpnIkev2;
}

export interface GetVpnSettingVpnIkev2 {
    /**
     * Maximum cached certificates
     */
    certificateCacheSize: number;
    /**
     * Cookie activation threshold
     */
    cookieThreshold: number;
    /**
     * Maximum half-opened SA
     */
    maxHalfOpenedSa: number;
}

export interface GetVulnerabilityProtectionProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Rules
     */
    rules: outputs.GetVulnerabilityProtectionProfileListDataRule[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Threat exception
     */
    threatExceptions: outputs.GetVulnerabilityProtectionProfileListDataThreatException[];
}

export interface GetVulnerabilityProtectionProfileListDataRule {
    /**
     * vulnerability profiles threat exception default action
     */
    action: outputs.GetVulnerabilityProtectionProfileListDataRuleAction;
    /**
     * Category
     */
    category: string;
    /**
     * Cve
     */
    cves: string[];
    /**
     * Host
     */
    host: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * Severity
     */
    severities: string[];
    /**
     * Threat name
     */
    threatName: string;
    /**
     * Vendor id
     */
    vendorIds: string[];
}

export interface GetVulnerabilityProtectionProfileListDataRuleAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionProfileListDataRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionProfileListDataRuleActionAllow;
    /**
     * vulnerability protection block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionProfileListDataRuleActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetVulnerabilityProtectionProfileListDataRuleActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionProfileListDataRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionProfileListDataRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionProfileListDataRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionProfileListDataRuleActionResetServer;
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionAlert {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionAllow {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionDefault {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionDrop {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionResetBoth {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionResetClient {
}

export interface GetVulnerabilityProtectionProfileListDataRuleActionResetServer {
}

export interface GetVulnerabilityProtectionProfileListDataThreatException {
    /**
     * vulnerability threat exception default action
     */
    action: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionExemptIp[];
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * vulnerability time attribute
     */
    timeAttribute: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionTimeAttribute;
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionAllow;
    /**
     * vulnerability protection threat exception block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetServer;
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionAlert {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionAllow {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionDefault {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionDrop {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetBoth {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetClient {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionActionResetServer {
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface GetVulnerabilityProtectionProfileListDataThreatExceptionTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionProfileRule {
    /**
     * vulnerability profiles threat exception default action
     */
    action: outputs.GetVulnerabilityProtectionProfileRuleAction;
    /**
     * Category
     */
    category: string;
    /**
     * Cve
     */
    cves: string[];
    /**
     * Host
     */
    host: string;
    /**
     * Name
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * Severity
     */
    severities: string[];
    /**
     * Threat name
     */
    threatName: string;
    /**
     * Vendor id
     */
    vendorIds: string[];
}

export interface GetVulnerabilityProtectionProfileRuleAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionProfileRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionProfileRuleActionAllow;
    /**
     * vulnerability protection block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionProfileRuleActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetVulnerabilityProtectionProfileRuleActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionProfileRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionProfileRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionProfileRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionProfileRuleActionResetServer;
}

export interface GetVulnerabilityProtectionProfileRuleActionAlert {
}

export interface GetVulnerabilityProtectionProfileRuleActionAllow {
}

export interface GetVulnerabilityProtectionProfileRuleActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionProfileRuleActionDefault {
}

export interface GetVulnerabilityProtectionProfileRuleActionDrop {
}

export interface GetVulnerabilityProtectionProfileRuleActionResetBoth {
}

export interface GetVulnerabilityProtectionProfileRuleActionResetClient {
}

export interface GetVulnerabilityProtectionProfileRuleActionResetServer {
}

export interface GetVulnerabilityProtectionProfileThreatException {
    /**
     * vulnerability threat exception default action
     */
    action: outputs.GetVulnerabilityProtectionProfileThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps: outputs.GetVulnerabilityProtectionProfileThreatExceptionExemptIp[];
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
    /**
     * Packet capture
     */
    packetCapture: string;
    /**
     * vulnerability time attribute
     */
    timeAttribute: outputs.GetVulnerabilityProtectionProfileThreatExceptionTimeAttribute;
}

export interface GetVulnerabilityProtectionProfileThreatExceptionAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionAllow;
    /**
     * vulnerability protection threat exception block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionProfileThreatExceptionActionResetServer;
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionAlert {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionAllow {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionDefault {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionDrop {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionResetBoth {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionResetClient {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionActionResetServer {
}

export interface GetVulnerabilityProtectionProfileThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface GetVulnerabilityProtectionProfileThreatExceptionTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionSignatureAffectedHost {
    /**
     * Client
     */
    client: boolean;
    /**
     * Server
     *
     * > ℹ️ **Note:** You must specify exactly one of `client` and `server`.
     */
    server: boolean;
}

export interface GetVulnerabilityProtectionSignatureDefaultAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionSignatureDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionSignatureDefaultActionAllow;
    /**
     * vulnerability protection bugtraq block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionSignatureDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionSignatureDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionSignatureDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionSignatureDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionSignatureDefaultActionResetServer;
}

export interface GetVulnerabilityProtectionSignatureDefaultActionAlert {
}

export interface GetVulnerabilityProtectionSignatureDefaultActionAllow {
}

export interface GetVulnerabilityProtectionSignatureDefaultActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionSignatureDefaultActionDrop {
}

export interface GetVulnerabilityProtectionSignatureDefaultActionResetBoth {
}

export interface GetVulnerabilityProtectionSignatureDefaultActionResetClient {
}

export interface GetVulnerabilityProtectionSignatureDefaultActionResetServer {
}

export interface GetVulnerabilityProtectionSignatureListData {
    /**
     * Affected host
     */
    affectedHost: outputs.GetVulnerabilityProtectionSignatureListDataAffectedHost;
    /**
     * Bugtraq
     */
    bugtraqs: string[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Cve
     */
    cves: string[];
    /**
     * Default action
     */
    defaultAction: outputs.GetVulnerabilityProtectionSignatureListDataDefaultAction;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Direction
     */
    direction: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Reference
     */
    references: string[];
    /**
     * Severity
     */
    severity: string;
    /**
     * vulnerability protection signature
     */
    signature: outputs.GetVulnerabilityProtectionSignatureListDataSignature;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * threat id range <41000-45000> and <6800001-6900000>
     */
    threatId: string;
    /**
     * Threatname
     */
    threatname: string;
    /**
     * Vendor
     */
    vendors: string[];
}

export interface GetVulnerabilityProtectionSignatureListDataAffectedHost {
    /**
     * Client
     */
    client: boolean;
    /**
     * Server
     *
     * > ℹ️ **Note:** You must specify exactly one of `client` and `server`.
     */
    server: boolean;
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultAction {
    /**
     * Alert
     */
    alert: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionAllow;
    /**
     * vulnerability protection bugtraq block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer: outputs.GetVulnerabilityProtectionSignatureListDataDefaultActionResetServer;
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionAlert {
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionAllow {
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionDrop {
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionResetBoth {
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionResetClient {
}

export interface GetVulnerabilityProtectionSignatureListDataDefaultActionResetServer {
}

export interface GetVulnerabilityProtectionSignatureListDataSignature {
    /**
     * vulnerability protection signature combination object
     */
    combination: outputs.GetVulnerabilityProtectionSignatureListDataSignatureCombination;
    /**
     * vulnerability protection signature standard array
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandard[];
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureCombination {
    /**
     * vulnerability protection signature combination object and condition
     */
    andConditions: outputs.GetVulnerabilityProtectionSignatureListDataSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Time attribute
     */
    timeAttribute: outputs.GetVulnerabilityProtectionSignatureListDataSignatureCombinationTimeAttribute;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureCombinationAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature combination object and condition object or condition
     */
    orConditions: outputs.GetVulnerabilityProtectionSignatureListDataSignatureCombinationAndConditionOrCondition[];
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Threat id
     */
    threatId: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandard {
    /**
     * vulnerability protection signature standard object and condition
     */
    andConditions: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature standard object and condition object or condition
     */
    orConditions: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrCondition[];
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators
     */
    operator: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperator;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperator {
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to
     */
    equalTo: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than
     */
    greaterThan: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than
     */
    lessThan: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match
     */
    patternMatch: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than array
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetVulnerabilityProtectionSignatureListDataSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureSignature {
    /**
     * vulnerability protection signature combination object
     */
    combination: outputs.GetVulnerabilityProtectionSignatureSignatureCombination;
    /**
     * vulnerability protection signature standard array
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards: outputs.GetVulnerabilityProtectionSignatureSignatureStandard[];
}

export interface GetVulnerabilityProtectionSignatureSignatureCombination {
    /**
     * vulnerability protection signature combination object and condition
     */
    andConditions: outputs.GetVulnerabilityProtectionSignatureSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Time attribute
     */
    timeAttribute: outputs.GetVulnerabilityProtectionSignatureSignatureCombinationTimeAttribute;
}

export interface GetVulnerabilityProtectionSignatureSignatureCombinationAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature combination object and condition object or condition
     */
    orConditions: outputs.GetVulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition[];
}

export interface GetVulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * Threat id
     */
    threatId: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval: number;
    /**
     * Threshold
     */
    threshold: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandard {
    /**
     * vulnerability protection signature standard object and condition
     */
    andConditions: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature standard object and condition object or condition
     */
    orConditions: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition[];
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators
     */
    operator: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator {
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to
     */
    equalTo: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than
     */
    greaterThan: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than
     */
    lessThan: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match
     */
    patternMatch: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than array
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value: number;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
     */
    qualifiers: outputs.GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface GetVulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name: string;
    /**
     * Value
     */
    value: string;
}

export interface GetWildfireAntiVirusProfileListData {
    /**
     * Description
     */
    description: string;
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Mlav exception
     */
    mlavExceptions: outputs.GetWildfireAntiVirusProfileListDataMlavException[];
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Packet capture
     */
    packetCapture: boolean;
    /**
     * Rules
     */
    rules: outputs.GetWildfireAntiVirusProfileListDataRule[];
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * Threat exception
     */
    threatExceptions: outputs.GetWildfireAntiVirusProfileListDataThreatException[];
}

export interface GetWildfireAntiVirusProfileListDataMlavException {
    /**
     * Description
     */
    description: string;
    /**
     * Filename
     */
    filename: string;
    /**
     * Name
     */
    name: string;
}

export interface GetWildfireAntiVirusProfileListDataRule {
    /**
     * Analysis
     */
    analysis: string;
    /**
     * Application
     */
    applications: string[];
    /**
     * Direction
     */
    direction: string;
    /**
     * File type
     */
    fileTypes: string[];
    /**
     * Name
     */
    name: string;
}

export interface GetWildfireAntiVirusProfileListDataThreatException {
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
}

export interface GetWildfireAntiVirusProfileMlavException {
    /**
     * Description
     */
    description: string;
    /**
     * Filename
     */
    filename: string;
    /**
     * Name
     */
    name: string;
}

export interface GetWildfireAntiVirusProfileRule {
    /**
     * Analysis
     */
    analysis: string;
    /**
     * Application
     */
    applications: string[];
    /**
     * Direction
     */
    direction: string;
    /**
     * File type
     */
    fileTypes: string[];
    /**
     * Name
     */
    name: string;
}

export interface GetWildfireAntiVirusProfileThreatException {
    /**
     * Name
     */
    name: string;
    /**
     * Notes
     */
    notes: string;
}

export interface GetZoneDeviceAcl {
    /**
     * Exclude list
     */
    excludeLists: string[];
    /**
     * Include list
     */
    includeLists: string[];
}

export interface GetZoneListData {
    /**
     * The device in which the resource is defined
     */
    device: string;
    /**
     * Device acl
     */
    deviceAcl: outputs.GetZoneListDataDeviceAcl;
    /**
     * Dos log setting
     */
    dosLogSetting: string;
    /**
     * Dos profile
     */
    dosProfile: string;
    /**
     * Enable device identification
     */
    enableDeviceIdentification: boolean;
    /**
     * Enable user identification
     */
    enableUserIdentification: boolean;
    /**
     * The folder of the item. Default: Shared.
     */
    folder: string;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * The name of the item.
     */
    name: string;
    /**
     * Network
     */
    network: outputs.GetZoneListDataNetwork;
    /**
     * The snippet of the item.
     */
    snippet: string;
    tfid: string;
    /**
     * User acl
     */
    userAcl: outputs.GetZoneListDataUserAcl;
}

export interface GetZoneListDataDeviceAcl {
    /**
     * Exclude list
     */
    excludeLists: string[];
    /**
     * Include list
     */
    includeLists: string[];
}

export interface GetZoneListDataNetwork {
    /**
     * Enable packet buffer protection
     */
    enablePacketBufferProtection: boolean;
    /**
     * External
     */
    externals: string[];
    /**
     * Layer2
     */
    layer2s: string[];
    /**
     * Layer3
     */
    layer3s: string[];
    /**
     * Log setting
     */
    logSetting: string;
    /**
     * Tap
     */
    taps: string[];
    /**
     * Tunnel
     */
    tunnel: outputs.GetZoneListDataNetworkTunnel;
    /**
     * Virtual wire
     */
    virtualWires: string[];
    /**
     * Zone protection profile
     */
    zoneProtectionProfile: string;
}

export interface GetZoneListDataNetworkTunnel {
}

export interface GetZoneListDataUserAcl {
    /**
     * Exclude list
     */
    excludeLists: string[];
    /**
     * Include list
     */
    includeLists: string[];
}

export interface GetZoneNetwork {
    /**
     * Enable packet buffer protection
     */
    enablePacketBufferProtection: boolean;
    /**
     * External
     */
    externals: string[];
    /**
     * Layer2
     */
    layer2s: string[];
    /**
     * Layer3
     */
    layer3s: string[];
    /**
     * Log setting
     */
    logSetting: string;
    /**
     * Tap
     */
    taps: string[];
    /**
     * Tunnel
     */
    tunnel: outputs.GetZoneNetworkTunnel;
    /**
     * Virtual wire
     */
    virtualWires: string[];
    /**
     * Zone protection profile
     */
    zoneProtectionProfile: string;
}

export interface GetZoneNetworkTunnel {
}

export interface GetZoneProtectionProfileFlood {
    /**
     * Icmp
     */
    icmp: outputs.GetZoneProtectionProfileFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6: outputs.GetZoneProtectionProfileFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp: outputs.GetZoneProtectionProfileFloodOtherIp;
    /**
     * Sctp init
     */
    sctpInit: outputs.GetZoneProtectionProfileFloodSctpInit;
    /**
     * Tcp syn
     */
    tcpSyn: outputs.GetZoneProtectionProfileFloodTcpSyn;
    /**
     * Udp
     */
    udp: outputs.GetZoneProtectionProfileFloodUdp;
}

export interface GetZoneProtectionProfileFloodIcmp {
    /**
     * Enable protection against ICMP floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodIcmpRed;
}

export interface GetZoneProtectionProfileFloodIcmpRed {
    /**
     * The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodIcmpv6 {
    /**
     * Enable protection against ICMPv6 floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodIcmpv6Red;
}

export interface GetZoneProtectionProfileFloodIcmpv6Red {
    /**
     * The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodOtherIp {
    /**
     * Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodOtherIpRed;
}

export interface GetZoneProtectionProfileFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodSctpInit {
    /**
     * Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodSctpInitRed;
}

export interface GetZoneProtectionProfileFloodSctpInitRed {
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
     */
    activateRate: number;
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodTcpSyn {
    /**
     * Enable protection against SYN floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies: outputs.GetZoneProtectionProfileFloodTcpSynSynCookies;
}

export interface GetZoneProtectionProfileFloodTcpSynRed {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodTcpSynSynCookies {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileFloodUdp {
    /**
     * Enable protection against UDP floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileFloodUdpRed;
}

export interface GetZoneProtectionProfileFloodUdpRed {
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
     */
    activateRate: number;
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileIpv6 {
    /**
     * Discard IPv6 packets that contain an anycast source address.
     */
    anycastSource: boolean;
    /**
     * Filter ext hdr
     */
    filterExtHdr: outputs.GetZoneProtectionProfileIpv6FilterExtHdr;
    /**
     * Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
     */
    icmpv6TooBigSmallMtuDiscard: boolean;
    /**
     * Ignore inv pkt
     */
    ignoreInvPkt: outputs.GetZoneProtectionProfileIpv6IgnoreInvPkt;
    /**
     * Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
     */
    ipv4CompatibleAddress: boolean;
    /**
     * Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
     */
    needlessFragmentHdr: boolean;
    /**
     * Discard IPv6 packets that contain invalid IPv6 options in an extension header.
     */
    optionsInvalidIpv6Discard: boolean;
    /**
     * Discard IPv6 packets that have a header with a reserved field not set to zero.
     */
    reservedFieldSetDiscard: boolean;
    /**
     * Drop packets with type 0 routing header.
     */
    routingHeader0: boolean;
    /**
     * Drop packets with type 1 routing header.
     */
    routingHeader1: boolean;
    /**
     * Drop packets with type 253 routing header.
     */
    routingHeader253: boolean;
    /**
     * Drop packets with type 254 routing header.
     */
    routingHeader254: boolean;
    /**
     * Drop packets with type 255 routing header.
     */
    routingHeader255: boolean;
    /**
     * Drop packets with type 3 routing header.
     */
    routingHeader3: boolean;
    /**
     * Drop packets with type 4 to type 252 routing header.
     */
    routingHeader4252: boolean;
}

export interface GetZoneProtectionProfileIpv6FilterExtHdr {
    /**
     * Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
     */
    destOptionHdr: boolean;
    /**
     * Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
     */
    hopByHopHdr: boolean;
    /**
     * Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
     */
    routingHdr: boolean;
}

export interface GetZoneProtectionProfileIpv6IgnoreInvPkt {
    /**
     * Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
     */
    destUnreach: boolean;
    /**
     * Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
     */
    paramProblem: boolean;
    /**
     * Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
     */
    pktTooBig: boolean;
    /**
     * Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
     */
    redirect: boolean;
    /**
     * Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
     */
    timeExceeded: boolean;
}

export interface GetZoneProtectionProfileL2SecGroupTagProtection {
    /**
     * Tags
     */
    tags: outputs.GetZoneProtectionProfileL2SecGroupTagProtectionTag[];
}

export interface GetZoneProtectionProfileL2SecGroupTagProtectionTag {
    /**
     * Enable this exclude list for Ethernet SGT protection.
     */
    enable: boolean;
    /**
     * Name for the list of Security Group Tags (SGTs).
     */
    name: string;
    /**
     * The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
     */
    tag: string;
}

export interface GetZoneProtectionProfileListData {
    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     */
    asymmetricPath: string;
    /**
     * The description of the profile
     */
    description: string;
    /**
     * The device in which the resource is defined
     *
     * > ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     */
    device: string;
    /**
     * Discard ICMP packets that are embedded with an error message.
     */
    discardIcmpEmbeddedError: boolean;
    /**
     * Flood
     */
    flood: outputs.GetZoneProtectionProfileListDataFlood;
    /**
     * The folder in which the resource is defined
     *
     * > ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     */
    folder: string;
    /**
     * Discard fragmented IP packets.
     */
    fragmentedTrafficDiscard: boolean;
    /**
     * Discard packets that consist of ICMP fragments.
     */
    icmpFragDiscard: boolean;
    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     */
    icmpLargePacketDiscard: boolean;
    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     */
    icmpPingZeroIdDiscard: boolean;
    /**
     * UUID of the resource
     */
    id: string;
    /**
     * Ipv6
     */
    ipv6: outputs.GetZoneProtectionProfileListDataIpv6;
    /**
     * L2 sec group tag protection
     */
    l2SecGroupTagProtection: outputs.GetZoneProtectionProfileListDataL2SecGroupTagProtection;
    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     */
    looseSourceRoutingDiscard: boolean;
    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     */
    malformedOptionDiscard: boolean;
    /**
     * Drop packets with mismatched overlapping TCP segments.
     */
    mismatchedOverlappingTcpSegmentDiscard: boolean;
    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     */
    mptcpOptionStrip: string;
    /**
     * The profile name
     */
    name: string;
    /**
     * Non ip protocol
     */
    nonIpProtocol: outputs.GetZoneProtectionProfileListDataNonIpProtocol;
    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     */
    recordRouteDiscard: boolean;
    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     */
    rejectNonSynTcp: string;
    /**
     * Scan white list
     */
    scanWhiteLists: outputs.GetZoneProtectionProfileListDataScanWhiteList[];
    /**
     * Scan
     */
    scans: outputs.GetZoneProtectionProfileListDataScan[];
    /**
     * Discard packets if the security option is defined.
     */
    securityDiscard: boolean;
    /**
     * The snippet in which the resource is defined
     *
     * > ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     */
    snippet: string;
    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     */
    spoofedIpDiscard: boolean;
    /**
     * Discard packets if the Stream ID option is defined.
     */
    streamIdDiscard: boolean;
    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     * If either condition is not true, discard the packet.
     */
    strictIpCheck: boolean;
    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     */
    strictSourceRoutingDiscard: boolean;
    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     */
    suppressIcmpNeedfrag: boolean;
    /**
     * Stop sending ICMP TTL expired messages.
     */
    suppressIcmpTimeexceeded: boolean;
    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     */
    tcpFastOpenAndDataStrip: boolean;
    /**
     * Drop packets with split handshakes.
     */
    tcpHandshakeDiscard: boolean;
    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     */
    tcpSynWithDataDiscard: boolean;
    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     */
    tcpSynackWithDataDiscard: boolean;
    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     */
    tcpTimestampStrip: boolean;
    tfid: string;
    /**
     * Discard packets with the Timestamp IP option set.
     */
    timestampDiscard: boolean;
    /**
     * Discard packets if the class and number are unknown.
     */
    unknownOptionDiscard: boolean;
}

export interface GetZoneProtectionProfileListDataFlood {
    /**
     * Icmp
     */
    icmp: outputs.GetZoneProtectionProfileListDataFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6: outputs.GetZoneProtectionProfileListDataFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp: outputs.GetZoneProtectionProfileListDataFloodOtherIp;
    /**
     * Sctp init
     */
    sctpInit: outputs.GetZoneProtectionProfileListDataFloodSctpInit;
    /**
     * Tcp syn
     */
    tcpSyn: outputs.GetZoneProtectionProfileListDataFloodTcpSyn;
    /**
     * Udp
     */
    udp: outputs.GetZoneProtectionProfileListDataFloodUdp;
}

export interface GetZoneProtectionProfileListDataFloodIcmp {
    /**
     * Enable protection against ICMP floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodIcmpRed;
}

export interface GetZoneProtectionProfileListDataFloodIcmpRed {
    /**
     * The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodIcmpv6 {
    /**
     * Enable protection against ICMPv6 floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodIcmpv6Red;
}

export interface GetZoneProtectionProfileListDataFloodIcmpv6Red {
    /**
     * The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodOtherIp {
    /**
     * Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodOtherIpRed;
}

export interface GetZoneProtectionProfileListDataFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodSctpInit {
    /**
     * Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodSctpInitRed;
}

export interface GetZoneProtectionProfileListDataFloodSctpInitRed {
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
     */
    activateRate: number;
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodTcpSyn {
    /**
     * Enable protection against SYN floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies: outputs.GetZoneProtectionProfileListDataFloodTcpSynSynCookies;
}

export interface GetZoneProtectionProfileListDataFloodTcpSynRed {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodTcpSynSynCookies {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataFloodUdp {
    /**
     * Enable protection against UDP floods?
     */
    enable: boolean;
    /**
     * Red
     */
    red: outputs.GetZoneProtectionProfileListDataFloodUdpRed;
}

export interface GetZoneProtectionProfileListDataFloodUdpRed {
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
     */
    activateRate: number;
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface GetZoneProtectionProfileListDataIpv6 {
    /**
     * Discard IPv6 packets that contain an anycast source address.
     */
    anycastSource: boolean;
    /**
     * Filter ext hdr
     */
    filterExtHdr: outputs.GetZoneProtectionProfileListDataIpv6FilterExtHdr;
    /**
     * Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
     */
    icmpv6TooBigSmallMtuDiscard: boolean;
    /**
     * Ignore inv pkt
     */
    ignoreInvPkt: outputs.GetZoneProtectionProfileListDataIpv6IgnoreInvPkt;
    /**
     * Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
     */
    ipv4CompatibleAddress: boolean;
    /**
     * Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
     */
    needlessFragmentHdr: boolean;
    /**
     * Discard IPv6 packets that contain invalid IPv6 options in an extension header.
     */
    optionsInvalidIpv6Discard: boolean;
    /**
     * Discard IPv6 packets that have a header with a reserved field not set to zero.
     */
    reservedFieldSetDiscard: boolean;
    /**
     * Drop packets with type 0 routing header.
     */
    routingHeader0: boolean;
    /**
     * Drop packets with type 1 routing header.
     */
    routingHeader1: boolean;
    /**
     * Drop packets with type 253 routing header.
     */
    routingHeader253: boolean;
    /**
     * Drop packets with type 254 routing header.
     */
    routingHeader254: boolean;
    /**
     * Drop packets with type 255 routing header.
     */
    routingHeader255: boolean;
    /**
     * Drop packets with type 3 routing header.
     */
    routingHeader3: boolean;
    /**
     * Drop packets with type 4 to type 252 routing header.
     */
    routingHeader4252: boolean;
}

export interface GetZoneProtectionProfileListDataIpv6FilterExtHdr {
    /**
     * Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
     */
    destOptionHdr: boolean;
    /**
     * Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
     */
    hopByHopHdr: boolean;
    /**
     * Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
     */
    routingHdr: boolean;
}

export interface GetZoneProtectionProfileListDataIpv6IgnoreInvPkt {
    /**
     * Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
     */
    destUnreach: boolean;
    /**
     * Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
     */
    paramProblem: boolean;
    /**
     * Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
     */
    pktTooBig: boolean;
    /**
     * Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
     */
    redirect: boolean;
    /**
     * Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
     */
    timeExceeded: boolean;
}

export interface GetZoneProtectionProfileListDataL2SecGroupTagProtection {
    /**
     * Tags
     */
    tags: outputs.GetZoneProtectionProfileListDataL2SecGroupTagProtectionTag[];
}

export interface GetZoneProtectionProfileListDataL2SecGroupTagProtectionTag {
    /**
     * Enable this exclude list for Ethernet SGT protection.
     */
    enable: boolean;
    /**
     * Name for the list of Security Group Tags (SGTs).
     */
    name: string;
    /**
     * The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
     */
    tag: string;
}

export interface GetZoneProtectionProfileListDataNonIpProtocol {
    /**
     * Specify the type of list you are creating for protocol protection:
     * * Include List—Only the protocols on the list are allowed—in addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
     * * Exclude List—Only the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
     */
    listType: string;
    /**
     * Protocol
     */
    protocols: outputs.GetZoneProtectionProfileListDataNonIpProtocolProtocol[];
}

export interface GetZoneProtectionProfileListDataNonIpProtocolProtocol {
    /**
     * Enable the Ethertype code on the list.
     */
    enable: boolean;
    /**
     * Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
     * * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
     * * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
     * * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
     */
    etherType: string;
    /**
     * Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
     */
    name: string;
}

export interface GetZoneProtectionProfileListDataScan {
    /**
     * Action
     */
    action: outputs.GetZoneProtectionProfileListDataScanAction;
    /**
     * Interval
     */
    interval: number;
    /**
     * The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
     * * "8001" - TCP Port Scan
     * * "8002" - Host Sweep
     * * "8003" - UDP Port Scan
     * * "8006" - Port Scan
     */
    name: string;
    /**
     * Threshold
     */
    threshold: number;
}

export interface GetZoneProtectionProfileListDataScanAction {
    /**
     * Alert
     */
    alert: outputs.GetZoneProtectionProfileListDataScanActionAlert;
    /**
     * Allow
     */
    allow: outputs.GetZoneProtectionProfileListDataScanActionAllow;
    /**
     * Block
     */
    block: outputs.GetZoneProtectionProfileListDataScanActionBlock;
    /**
     * Block ip
     */
    blockIp: outputs.GetZoneProtectionProfileListDataScanActionBlockIp;
}

export interface GetZoneProtectionProfileListDataScanActionAlert {
}

export interface GetZoneProtectionProfileListDataScanActionAllow {
}

export interface GetZoneProtectionProfileListDataScanActionBlock {
}

export interface GetZoneProtectionProfileListDataScanActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetZoneProtectionProfileListDataScanWhiteList {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
    /**
     * A descriptive name for the address to exclude.
     */
    name: string;
}

export interface GetZoneProtectionProfileNonIpProtocol {
    /**
     * Specify the type of list you are creating for protocol protection:
     * * Include List—Only the protocols on the list are allowed—in addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
     * * Exclude List—Only the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
     */
    listType: string;
    /**
     * Protocol
     */
    protocols: outputs.GetZoneProtectionProfileNonIpProtocolProtocol[];
}

export interface GetZoneProtectionProfileNonIpProtocolProtocol {
    /**
     * Enable the Ethertype code on the list.
     */
    enable: boolean;
    /**
     * Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
     * * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
     * * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
     * * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
     */
    etherType: string;
    /**
     * Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
     */
    name: string;
}

export interface GetZoneProtectionProfileScan {
    /**
     * Action
     */
    action: outputs.GetZoneProtectionProfileScanAction;
    /**
     * Interval
     */
    interval: number;
    /**
     * The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
     * * "8001" - TCP Port Scan
     * * "8002" - Host Sweep
     * * "8003" - UDP Port Scan
     * * "8006" - Port Scan
     */
    name: string;
    /**
     * Threshold
     */
    threshold: number;
}

export interface GetZoneProtectionProfileScanAction {
    /**
     * Alert
     */
    alert: outputs.GetZoneProtectionProfileScanActionAlert;
    /**
     * Allow
     */
    allow: outputs.GetZoneProtectionProfileScanActionAllow;
    /**
     * Block
     */
    block: outputs.GetZoneProtectionProfileScanActionBlock;
    /**
     * Block ip
     */
    blockIp: outputs.GetZoneProtectionProfileScanActionBlockIp;
}

export interface GetZoneProtectionProfileScanActionAlert {
}

export interface GetZoneProtectionProfileScanActionAllow {
}

export interface GetZoneProtectionProfileScanActionBlock {
}

export interface GetZoneProtectionProfileScanActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface GetZoneProtectionProfileScanWhiteList {
    /**
     * Ipv4
     */
    ipv4: string;
    /**
     * Ipv6
     */
    ipv6: string;
    /**
     * A descriptive name for the address to exclude.
     */
    name: string;
}

export interface GetZoneUserAcl {
    /**
     * Exclude list
     */
    excludeLists: string[];
    /**
     * Include list
     */
    includeLists: string[];
}

export interface HipObjectAntiMalware {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectAntiMalwareCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectAntiMalwareVendor[];
}

export interface HipObjectAntiMalwareCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last scan time
     */
    lastScanTime?: outputs.HipObjectAntiMalwareCriteriaLastScanTime;
    /**
     * Product version
     */
    productVersion?: outputs.HipObjectAntiMalwareCriteriaProductVersion;
    /**
     * real time protection
     */
    realTimeProtection?: string;
    /**
     * Virdef version
     */
    virdefVersion?: outputs.HipObjectAntiMalwareCriteriaVirdefVersion;
}

export interface HipObjectAntiMalwareCriteriaLastScanTime {
    /**
     * Not available
     */
    notAvailable?: outputs.HipObjectAntiMalwareCriteriaLastScanTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin?: outputs.HipObjectAntiMalwareCriteriaLastScanTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within?: outputs.HipObjectAntiMalwareCriteriaLastScanTimeWithin;
}

export interface HipObjectAntiMalwareCriteriaLastScanTimeNotAvailable {
}

export interface HipObjectAntiMalwareCriteriaLastScanTimeNotWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours?: number;
}

export interface HipObjectAntiMalwareCriteriaLastScanTimeWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours?: number;
}

export interface HipObjectAntiMalwareCriteriaProductVersion {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Greater equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterEqual?: string;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    greaterThan?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    isNot?: string;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessEqual?: string;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    lessThan?: string;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    notWithin?: outputs.HipObjectAntiMalwareCriteriaProductVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, `lessThan`, `notWithin`, and `within`.
     */
    within?: outputs.HipObjectAntiMalwareCriteriaProductVersionWithin;
}

export interface HipObjectAntiMalwareCriteriaProductVersionNotWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface HipObjectAntiMalwareCriteriaProductVersionWithin {
    /**
     * versions range
     */
    versions: number;
}

export interface HipObjectAntiMalwareCriteriaVirdefVersion {
    /**
     * Not within
     */
    notWithin?: outputs.HipObjectAntiMalwareCriteriaVirdefVersionNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within?: outputs.HipObjectAntiMalwareCriteriaVirdefVersionWithin;
}

export interface HipObjectAntiMalwareCriteriaVirdefVersionNotWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions?: number;
}

export interface HipObjectAntiMalwareCriteriaVirdefVersionWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify versions range
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `versions`.
     */
    versions?: number;
}

export interface HipObjectAntiMalwareVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products?: string[];
}

export interface HipObjectCertificate {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectCertificateCriteria;
}

export interface HipObjectCertificateCriteria {
    /**
     * Certificate attributes
     */
    certificateAttributes?: outputs.HipObjectCertificateCriteriaCertificateAttribute[];
    /**
     * Profile for authenticating client certificates
     */
    certificateProfile?: string;
}

export interface HipObjectCertificateCriteriaCertificateAttribute {
    /**
     * Attribute Name
     */
    name: string;
    /**
     * Key value
     */
    value?: string;
}

export interface HipObjectCustomChecks {
    /**
     * Criteria
     */
    criteria: outputs.HipObjectCustomChecksCriteria;
}

export interface HipObjectCustomChecksCriteria {
    /**
     * Plist
     */
    plists?: outputs.HipObjectCustomChecksCriteriaPlist[];
    /**
     * Process list
     */
    processLists?: outputs.HipObjectCustomChecksCriteriaProcessList[];
    /**
     * Registry key
     */
    registryKeys?: outputs.HipObjectCustomChecksCriteriaRegistryKey[];
}

export interface HipObjectCustomChecksCriteriaPlist {
    /**
     * Key
     */
    keys?: outputs.HipObjectCustomChecksCriteriaPlistKey[];
    /**
     * Preference list
     */
    name: string;
    /**
     * Plist does not exist
     */
    negate: boolean;
}

export interface HipObjectCustomChecksCriteriaPlistKey {
    /**
     * Key name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Key value
     */
    value?: string;
}

export interface HipObjectCustomChecksCriteriaProcessList {
    /**
     * Process Name
     */
    name: string;
    /**
     * Running
     */
    running: boolean;
}

export interface HipObjectCustomChecksCriteriaRegistryKey {
    /**
     * Registry key default value data
     */
    defaultValueData?: string;
    /**
     * Registry key
     */
    name: string;
    /**
     * Key does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value
     */
    registryValues?: outputs.HipObjectCustomChecksCriteriaRegistryKeyRegistryValue[];
}

export interface HipObjectCustomChecksCriteriaRegistryKeyRegistryValue {
    /**
     * Registry value name
     */
    name: string;
    /**
     * Value does not exist or match specified value data
     */
    negate: boolean;
    /**
     * Registry value data
     */
    valueData?: string;
}

export interface HipObjectDataLossPrevention {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectDataLossPreventionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectDataLossPreventionVendor[];
}

export interface HipObjectDataLossPreventionCriteria {
    /**
     * is enabled
     */
    isEnabled?: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface HipObjectDataLossPreventionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products?: string[];
}

export interface HipObjectDiskBackup {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectDiskBackupCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectDiskBackupVendor[];
}

export interface HipObjectDiskBackupCriteria {
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Last backup time
     */
    lastBackupTime?: outputs.HipObjectDiskBackupCriteriaLastBackupTime;
}

export interface HipObjectDiskBackupCriteriaLastBackupTime {
    /**
     * Not available
     */
    notAvailable?: outputs.HipObjectDiskBackupCriteriaLastBackupTimeNotAvailable;
    /**
     * Not within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    notWithin?: outputs.HipObjectDiskBackupCriteriaLastBackupTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notAvailable`, `notWithin`, and `within`.
     */
    within?: outputs.HipObjectDiskBackupCriteriaLastBackupTimeWithin;
}

export interface HipObjectDiskBackupCriteriaLastBackupTimeNotAvailable {
}

export interface HipObjectDiskBackupCriteriaLastBackupTimeNotWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours?: number;
}

export interface HipObjectDiskBackupCriteriaLastBackupTimeWithin {
    /**
     * specify time in days
     */
    days?: number;
    /**
     * specify time in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days` and `hours`.
     */
    hours?: number;
}

export interface HipObjectDiskBackupVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products?: string[];
}

export interface HipObjectDiskEncryption {
    /**
     * Encryption locations
     */
    criteria?: outputs.HipObjectDiskEncryptionCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectDiskEncryptionVendor[];
}

export interface HipObjectDiskEncryptionCriteria {
    /**
     * Encrypted locations
     */
    encryptedLocations?: outputs.HipObjectDiskEncryptionCriteriaEncryptedLocation[];
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface HipObjectDiskEncryptionCriteriaEncryptedLocation {
    /**
     * Encryption state
     */
    encryptionState?: outputs.HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionState;
    /**
     * Encryption location
     */
    name: string;
}

export interface HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionState {
    /**
     * Is
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectDiskEncryptionVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products?: string[];
}

export interface HipObjectFirewall {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectFirewallCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectFirewallVendor[];
}

export interface HipObjectFirewallCriteria {
    /**
     * is enabled
     */
    isEnabled?: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
}

export interface HipObjectFirewallVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product
     */
    products?: string[];
}

export interface HipObjectHostInfo {
    /**
     * Criteria
     */
    criteria: outputs.HipObjectHostInfoCriteria;
}

export interface HipObjectHostInfoCriteria {
    /**
     * Client version
     */
    clientVersion?: outputs.HipObjectHostInfoCriteriaClientVersion;
    /**
     * Domain
     */
    domain?: outputs.HipObjectHostInfoCriteriaDomain;
    /**
     * Host id
     */
    hostId?: outputs.HipObjectHostInfoCriteriaHostId;
    /**
     * Host name
     */
    hostName?: outputs.HipObjectHostInfoCriteriaHostName;
    /**
     * If device is managed
     */
    managed?: boolean;
    /**
     * Os
     */
    os?: outputs.HipObjectHostInfoCriteriaOs;
    /**
     * Serial number
     */
    serialNumber?: outputs.HipObjectHostInfoCriteriaSerialNumber;
}

export interface HipObjectHostInfoCriteriaClientVersion {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectHostInfoCriteriaDomain {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectHostInfoCriteriaHostId {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectHostInfoCriteriaHostName {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectHostInfoCriteriaOs {
    /**
     * Contains
     */
    contains?: outputs.HipObjectHostInfoCriteriaOsContains;
}

export interface HipObjectHostInfoCriteriaOsContains {
    /**
     * Apple
     */
    apple?: string;
    /**
     * Google
     */
    google?: string;
    /**
     * Linux
     */
    linux?: string;
    /**
     * Microsoft
     */
    microsoft?: string;
    /**
     * Other
     */
    other?: string;
}

export interface HipObjectHostInfoCriteriaSerialNumber {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectMobileDevice {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectMobileDeviceCriteria;
}

export interface HipObjectMobileDeviceCriteria {
    /**
     * Applications
     */
    applications?: outputs.HipObjectMobileDeviceCriteriaApplications;
    /**
     * If device's disk is encrypted
     */
    diskEncrypted?: boolean;
    /**
     * Imei
     */
    imei?: outputs.HipObjectMobileDeviceCriteriaImei;
    /**
     * If device is by rooted/jailbroken
     */
    jailbroken?: boolean;
    /**
     * Last checkin time
     */
    lastCheckinTime?: outputs.HipObjectMobileDeviceCriteriaLastCheckinTime;
    /**
     * Model
     */
    model?: outputs.HipObjectMobileDeviceCriteriaModel;
    /**
     * If device's passcode is present
     */
    passcodeSet?: boolean;
    /**
     * Phone number
     */
    phoneNumber?: outputs.HipObjectMobileDeviceCriteriaPhoneNumber;
    /**
     * Tag
     */
    tag?: outputs.HipObjectMobileDeviceCriteriaTag;
}

export interface HipObjectMobileDeviceCriteriaApplications {
    /**
     * Has malware
     */
    hasMalware?: outputs.HipObjectMobileDeviceCriteriaApplicationsHasMalware;
    /**
     * Has apps that are not managed
     */
    hasUnmanagedApp?: boolean;
    /**
     * Includes
     */
    includes?: outputs.HipObjectMobileDeviceCriteriaApplicationsInclude[];
}

export interface HipObjectMobileDeviceCriteriaApplicationsHasMalware {
    /**
     * No
     */
    no?: outputs.HipObjectMobileDeviceCriteriaApplicationsHasMalwareNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `no` and `yes`.
     */
    yes?: outputs.HipObjectMobileDeviceCriteriaApplicationsHasMalwareYes;
}

export interface HipObjectMobileDeviceCriteriaApplicationsHasMalwareNo {
}

export interface HipObjectMobileDeviceCriteriaApplicationsHasMalwareYes {
    /**
     * Excludes
     */
    excludes?: outputs.HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExclude[];
}

export interface HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExclude {
    /**
     * application hash
     */
    hash?: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package?: string;
}

export interface HipObjectMobileDeviceCriteriaApplicationsInclude {
    /**
     * application hash
     */
    hash?: string;
    /**
     * Name
     */
    name: string;
    /**
     * application package name
     */
    package?: string;
}

export interface HipObjectMobileDeviceCriteriaImei {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectMobileDeviceCriteriaLastCheckinTime {
    /**
     * Not within
     */
    notWithin?: outputs.HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithin;
    /**
     * Within
     *
     * > ℹ️ **Note:** You must specify exactly one of `notWithin` and `within`.
     */
    within?: outputs.HipObjectMobileDeviceCriteriaLastCheckinTimeWithin;
}

export interface HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface HipObjectMobileDeviceCriteriaLastCheckinTimeWithin {
    /**
     * specify time in days
     */
    days: number;
}

export interface HipObjectMobileDeviceCriteriaModel {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectMobileDeviceCriteriaPhoneNumber {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectMobileDeviceCriteriaTag {
    /**
     * Contains
     */
    contains?: string;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    is?: string;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `contains`, `is`, and `isNot`.
     */
    isNot?: string;
}

export interface HipObjectNetworkInfo {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectNetworkInfoCriteria;
}

export interface HipObjectNetworkInfoCriteria {
    /**
     * Network
     */
    network?: outputs.HipObjectNetworkInfoCriteriaNetwork;
}

export interface HipObjectNetworkInfoCriteriaNetwork {
    /**
     * Is
     */
    is?: outputs.HipObjectNetworkInfoCriteriaNetworkIs;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `is` and `isNot`.
     */
    isNot?: outputs.HipObjectNetworkInfoCriteriaNetworkIsNot;
}

export interface HipObjectNetworkInfoCriteriaNetworkIs {
    /**
     * Mobile
     */
    mobile?: outputs.HipObjectNetworkInfoCriteriaNetworkIsMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    unknown?: outputs.HipObjectNetworkInfoCriteriaNetworkIsUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
     */
    wifi?: outputs.HipObjectNetworkInfoCriteriaNetworkIsWifi;
}

export interface HipObjectNetworkInfoCriteriaNetworkIsMobile {
    /**
     * Carrier
     */
    carrier?: string;
}

export interface HipObjectNetworkInfoCriteriaNetworkIsNot {
    /**
     * Ethernet
     */
    ethernet?: outputs.HipObjectNetworkInfoCriteriaNetworkIsNotEthernet;
    /**
     * Mobile
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    mobile?: outputs.HipObjectNetworkInfoCriteriaNetworkIsNotMobile;
    /**
     * Unknown
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    unknown?: outputs.HipObjectNetworkInfoCriteriaNetworkIsNotUnknown;
    /**
     * Wifi
     *
     * > ℹ️ **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
     */
    wifi?: outputs.HipObjectNetworkInfoCriteriaNetworkIsNotWifi;
}

export interface HipObjectNetworkInfoCriteriaNetworkIsNotEthernet {
}

export interface HipObjectNetworkInfoCriteriaNetworkIsNotMobile {
    /**
     * Carrier
     */
    carrier?: string;
}

export interface HipObjectNetworkInfoCriteriaNetworkIsNotUnknown {
}

export interface HipObjectNetworkInfoCriteriaNetworkIsNotWifi {
    /**
     * SSID
     */
    ssid?: string;
}

export interface HipObjectNetworkInfoCriteriaNetworkIsUnknown {
}

export interface HipObjectNetworkInfoCriteriaNetworkIsWifi {
    /**
     * SSID
     */
    ssid?: string;
}

export interface HipObjectPatchManagement {
    /**
     * Criteria
     */
    criteria?: outputs.HipObjectPatchManagementCriteria;
    /**
     * Exclude vendor
     */
    excludeVendor: boolean;
    /**
     * Vendor name
     */
    vendors?: outputs.HipObjectPatchManagementVendor[];
}

export interface HipObjectPatchManagementCriteria {
    /**
     * is enabled
     */
    isEnabled?: string;
    /**
     * Is Installed
     */
    isInstalled: boolean;
    /**
     * Missing patches
     */
    missingPatches?: outputs.HipObjectPatchManagementCriteriaMissingPatches;
}

export interface HipObjectPatchManagementCriteriaMissingPatches {
    /**
     * Check
     */
    check: string;
    /**
     * Patches
     */
    patches?: string[];
    /**
     * Severity
     */
    severity?: outputs.HipObjectPatchManagementCriteriaMissingPatchesSeverity;
}

export interface HipObjectPatchManagementCriteriaMissingPatchesSeverity {
    /**
     * Greater equal
     */
    greaterEqual?: number;
    /**
     * Greater than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    greaterThan?: number;
    /**
     * Is
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    is?: number;
    /**
     * Is not
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    isNot?: number;
    /**
     * Less equal
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessEqual?: number;
    /**
     * Less than
     *
     * > ℹ️ **Note:** You must specify exactly one of `greaterEqual`, `greaterThan`, `is`, `isNot`, `lessEqual`, and `lessThan`.
     */
    lessThan?: number;
}

export interface HipObjectPatchManagementVendor {
    /**
     * Name
     */
    name: string;
    /**
     * Product name
     */
    products?: string[];
}

export interface HttpHeaderProfileHttpHeaderInsertion {
    /**
     * The name of the HTTP header insertion rule
     */
    name: string;
    /**
     * A list of HTTP header insertion definitions
     */
    types: outputs.HttpHeaderProfileHttpHeaderInsertionType[];
}

export interface HttpHeaderProfileHttpHeaderInsertionType {
    /**
     * A list of DNS domains
     */
    domains: string[];
    /**
     * Headers
     */
    headers: outputs.HttpHeaderProfileHttpHeaderInsertionTypeHeader[];
    /**
     * The HTTP header insertion type
     */
    name: string;
}

export interface HttpHeaderProfileHttpHeaderInsertionTypeHeader {
    /**
     * The HTTP header string
     */
    header: string;
    /**
     * Log the use of this HTTP header insertion?
     */
    log: boolean;
    /**
     * The name of the HTTP header
     */
    name: string;
    /**
     * The value associated with the HTTP header
     */
    value: string;
}

export interface HttpServerProfileFormat {
    /**
     * Auth
     */
    auth?: outputs.HttpServerProfileFormatAuth;
    /**
     * Config
     */
    config?: outputs.HttpServerProfileFormatConfig;
    /**
     * Correlation
     */
    correlation?: outputs.HttpServerProfileFormatCorrelation;
    /**
     * Data
     */
    data?: outputs.HttpServerProfileFormatData;
    /**
     * Decryption
     */
    decryption?: outputs.HttpServerProfileFormatDecryption;
    /**
     * Globalprotect
     */
    globalprotect?: outputs.HttpServerProfileFormatGlobalprotect;
    /**
     * Gtp
     */
    gtp?: outputs.HttpServerProfileFormatGtp;
    /**
     * Hip match
     */
    hipMatch?: outputs.HttpServerProfileFormatHipMatch;
    /**
     * Iptag
     */
    iptag?: outputs.HttpServerProfileFormatIptag;
    /**
     * Sctp
     */
    sctp?: outputs.HttpServerProfileFormatSctp;
    /**
     * System
     */
    system?: outputs.HttpServerProfileFormatSystem;
    /**
     * Threat
     */
    threat?: outputs.HttpServerProfileFormatThreat;
    /**
     * Traffic
     */
    traffic?: outputs.HttpServerProfileFormatTraffic;
    /**
     * Tunnel
     */
    tunnel?: outputs.HttpServerProfileFormatTunnel;
    /**
     * Url
     */
    url?: outputs.HttpServerProfileFormatUrl;
    /**
     * Userid
     */
    userid?: outputs.HttpServerProfileFormatUserid;
    /**
     * Wildfire
     */
    wildfire?: outputs.HttpServerProfileFormatWildfire;
}

export interface HttpServerProfileFormatAuth {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatAuthHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatAuthParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatAuthHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatAuthParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatConfig {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatConfigHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatConfigParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatConfigHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatConfigParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatCorrelation {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatCorrelationHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatCorrelationParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatCorrelationHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatCorrelationParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatData {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatDataHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatDataParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatDataHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatDataParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatDecryption {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatDecryptionHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatDecryptionParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatDecryptionHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatDecryptionParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatGlobalprotect {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatGlobalprotectHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatGlobalprotectParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatGlobalprotectHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatGlobalprotectParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatGtp {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatGtpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatGtpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatGtpHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatGtpParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatHipMatch {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatHipMatchHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatHipMatchParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatHipMatchHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatHipMatchParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatIptag {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatIptagHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatIptagParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatIptagHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatIptagParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatSctp {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatSctpHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatSctpParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatSctpHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatSctpParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatSystem {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatSystemHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatSystemParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatSystemHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatSystemParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatThreat {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatThreatHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatThreatParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatThreatHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatThreatParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatTraffic {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatTrafficHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatTrafficParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatTrafficHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatTrafficParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatTunnel {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatTunnelHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatTunnelParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatTunnelHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatTunnelParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatUrl {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatUrlHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatUrlParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatUrlHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatUrlParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatUserid {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatUseridHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatUseridParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatUseridHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatUseridParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileFormatWildfire {
    /**
     * Headers
     */
    headers?: outputs.HttpServerProfileFormatWildfireHeader[];
    /**
     * The name of the payload format
     */
    name: string;
    /**
     * Params
     */
    params?: outputs.HttpServerProfileFormatWildfireParam[];
    /**
     * The log payload format.  The accepted log field values are as follows.
     */
    payload?: string;
    /**
     * The URL path of the HTTP server
     */
    urlFormat?: string;
}

export interface HttpServerProfileFormatWildfireHeader {
    /**
     * Header name
     */
    name?: string;
    /**
     * Header value
     */
    value?: string;
}

export interface HttpServerProfileFormatWildfireParam {
    /**
     * Parameter name
     */
    name?: string;
    /**
     * Parameter value
     */
    value?: string;
}

export interface HttpServerProfileServer {
    /**
     * HTTP server address
     */
    address?: string;
    /**
     * HTTP server certificate profile
     */
    certificateProfile: string;
    /**
     * HTTP operation to perform
     */
    httpMethod?: string;
    /**
     * HTTP server name
     */
    name?: string;
    /**
     * HTTP server port
     */
    port?: number;
    /**
     * HTTP server protocol
     */
    protocol?: string;
    /**
     * HTTP server TLS version
     */
    tlsVersion?: string;
}

export interface IkeCryptoProfileLifetime {
    /**
     * specify lifetime in days
     */
    days?: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours?: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes?: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds?: number;
}

export interface IkeGatewayAuthentication {
    /**
     * Certificate
     */
    certificate?: outputs.IkeGatewayAuthenticationCertificate;
    /**
     * Pre shared key
     *
     * > ℹ️ **Note:** You must specify exactly one of `certificate` and `preSharedKey`.
     */
    preSharedKey?: outputs.IkeGatewayAuthenticationPreSharedKey;
}

export interface IkeGatewayAuthenticationCertificate {
    /**
     * Allow id payload mismatch
     */
    allowIdPayloadMismatch?: boolean;
    /**
     * Certificate profile
     */
    certificateProfile?: string;
    /**
     * Local certificate
     */
    localCertificate?: outputs.IkeGatewayAuthenticationCertificateLocalCertificate;
    /**
     * Strict validation revocation
     */
    strictValidationRevocation?: boolean;
    /**
     * Use management as source
     */
    useManagementAsSource?: boolean;
}

export interface IkeGatewayAuthenticationCertificateLocalCertificate {
    /**
     * Local certificate name
     */
    localCertificateName?: string;
}

export interface IkeGatewayAuthenticationPreSharedKey {
    /**
     * Key
     */
    key?: string;
}

export interface IkeGatewayLocalAddress {
    /**
     * Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
     */
    interface: string;
}

export interface IkeGatewayLocalId {
    /**
     * Local ID string
     */
    id?: string;
    /**
     * Type
     */
    type?: string;
}

export interface IkeGatewayPeerAddress {
    /**
     * Dynamic
     */
    dynamic?: outputs.IkeGatewayPeerAddressDynamic;
    /**
     * peer gateway FQDN name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    fqdn?: string;
    /**
     * peer gateway has static IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
     */
    ip?: string;
}

export interface IkeGatewayPeerAddressDynamic {
}

export interface IkeGatewayPeerId {
    /**
     * Peer ID string
     */
    id?: string;
    /**
     * Type
     */
    type?: string;
}

export interface IkeGatewayProtocol {
    /**
     * Ikev1
     */
    ikev1?: outputs.IkeGatewayProtocolIkev1;
    /**
     * Ikev2
     */
    ikev2?: outputs.IkeGatewayProtocolIkev2;
    /**
     * Version
     */
    version: string;
}

export interface IkeGatewayProtocolCommon {
    /**
     * Fragmentation
     */
    fragmentation: outputs.IkeGatewayProtocolCommonFragmentation;
    /**
     * Enables NAT traversal for the IKE gateway.
     */
    natTraversal: outputs.IkeGatewayProtocolCommonNatTraversal;
    /**
     * Passive mode
     */
    passiveMode: boolean;
}

export interface IkeGatewayProtocolCommonFragmentation {
    /**
     * Enable
     */
    enable: boolean;
}

export interface IkeGatewayProtocolCommonNatTraversal {
    /**
     * Enable
     */
    enable: boolean;
}

export interface IkeGatewayProtocolIkev1 {
    /**
     * Dpd
     */
    dpd?: outputs.IkeGatewayProtocolIkev1Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile?: string;
}

export interface IkeGatewayProtocolIkev1Dpd {
    /**
     * Enable
     */
    enable?: boolean;
}

export interface IkeGatewayProtocolIkev2 {
    /**
     * Dpd
     */
    dpd?: outputs.IkeGatewayProtocolIkev2Dpd;
    /**
     * Ike crypto profile
     */
    ikeCryptoProfile?: string;
}

export interface IkeGatewayProtocolIkev2Dpd {
    /**
     * Enable
     */
    enable?: boolean;
}

export interface InterfaceManagementProfilePermittedIp {
    /**
     * The allowed IP address or CIDR block.
     */
    name: string;
}

export interface IpsecCryptoProfileAh {
    /**
     * Authentication
     */
    authentications: string[];
}

export interface IpsecCryptoProfileEsp {
    /**
     * Authentication algorithm
     */
    authentications: string[];
    /**
     * Encryption algorithm
     */
    encryptions: string[];
}

export interface IpsecCryptoProfileLifesize {
    /**
     * specify lifesize in gigabytes(GB)
     */
    gb?: number;
    /**
     * specify lifesize in kilobytes(KB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    kb?: number;
    /**
     * specify lifesize in megabytes(MB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    mb?: number;
    /**
     * specify lifesize in terabytes(TB)
     *
     * > ℹ️ **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
     */
    tb?: number;
}

export interface IpsecCryptoProfileLifetime {
    /**
     * specify lifetime in days
     */
    days?: number;
    /**
     * specify lifetime in hours
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    hours?: number;
    /**
     * specify lifetime in minutes
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    minutes?: number;
    /**
     * specify lifetime in seconds
     *
     * > ℹ️ **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
     */
    seconds?: number;
}

export interface IpsecTunnelAutoKey {
    /**
     * Ike gateway
     */
    ikeGateways: outputs.IpsecTunnelAutoKeyIkeGateway[];
    /**
     * Ipsec crypto profile
     */
    ipsecCryptoProfile: string;
    /**
     * IPv6 type of proxy*id values
     */
    proxyIdV6s?: outputs.IpsecTunnelAutoKeyProxyIdV6[];
    /**
     * IPv4 type of proxy*id values
     */
    proxyIds?: outputs.IpsecTunnelAutoKeyProxyId[];
}

export interface IpsecTunnelAutoKeyIkeGateway {
    /**
     * Name
     */
    name?: string;
}

export interface IpsecTunnelAutoKeyProxyId {
    /**
     * Local
     */
    local?: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv4 type of proxy*id protocol values for TCP protocol
     */
    protocol?: outputs.IpsecTunnelAutoKeyProxyIdProtocol;
    /**
     * Remote
     */
    remote?: string;
}

export interface IpsecTunnelAutoKeyProxyIdProtocol {
    /**
     * IP protocol number
     */
    number?: number;
    /**
     * IPv4 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp?: outputs.IpsecTunnelAutoKeyProxyIdProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp?: outputs.IpsecTunnelAutoKeyProxyIdProtocolUdp;
}

export interface IpsecTunnelAutoKeyProxyIdProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface IpsecTunnelAutoKeyProxyIdProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface IpsecTunnelAutoKeyProxyIdV6 {
    /**
     * Local
     */
    local?: string;
    /**
     * Name
     */
    name: string;
    /**
     * IPv6 type of proxy*id protocol values for protocol
     */
    protocol?: outputs.IpsecTunnelAutoKeyProxyIdV6Protocol;
    /**
     * Remote
     */
    remote?: string;
}

export interface IpsecTunnelAutoKeyProxyIdV6Protocol {
    /**
     * IP protocol number
     */
    number?: number;
    /**
     * IPv6 type of proxyId protocol values for TCP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    tcp?: outputs.IpsecTunnelAutoKeyProxyIdV6ProtocolTcp;
    /**
     * IPv6 type of proxyId protocol values for UDP protocol
     *
     * > ℹ️ **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
     */
    udp?: outputs.IpsecTunnelAutoKeyProxyIdV6ProtocolUdp;
}

export interface IpsecTunnelAutoKeyProxyIdV6ProtocolTcp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface IpsecTunnelAutoKeyProxyIdV6ProtocolUdp {
    /**
     * Local port
     */
    localPort: number;
    /**
     * Remote port
     */
    remotePort: number;
}

export interface IpsecTunnelTunnelMonitor {
    /**
     * Destination IP to send ICMP probe
     */
    destinationIp: string;
    /**
     * Enable tunnel monitoring on this tunnel
     */
    enable: boolean;
    /**
     * Which proxy-id (or proxy-id-v6) the monitoring traffic will use
     */
    proxyId?: string;
}

export interface KerberosServerProfileServer {
    /**
     * The Kerberos server IP address
     */
    host: string;
    /**
     * The Kerberos server name
     */
    name: string;
    /**
     * The Kerberos server port
     */
    port?: number;
}

export interface Layer3SubinterfaceArp {
    /**
     * MAC address
     */
    hwAddress?: string;
    /**
     * IP address
     */
    name?: string;
}

export interface Layer3SubinterfaceDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp?: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface Layer3SubinterfaceDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Layer3 sub interfaces DHCP Client Send hostname
     */
    sendHostname?: outputs.Layer3SubinterfaceDhcpClientSendHostname;
}

export interface Layer3SubinterfaceDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface Layer3SubinterfaceIp {
    /**
     * L3 sub-interface IP address(es)
     */
    name: string;
}

export interface LdapServerProfileServer {
    /**
     * The LDAP server IP address
     */
    address?: string;
    /**
     * The LDAP server name
     */
    name?: string;
    /**
     * The LDAP server port
     */
    port?: number;
}

export interface LldpProfileOptionTlvs {
    /**
     * Management address
     */
    managementAddress?: outputs.LldpProfileOptionTlvsManagementAddress;
    /**
     * Option TLV Port Description
     */
    portDescription?: boolean;
    /**
     * Option TLV System Capabilities
     */
    systemCapabilities?: boolean;
    /**
     * Option TLV System Description
     */
    systemDescription?: boolean;
    /**
     * Option TLV System Name
     */
    systemName?: boolean;
}

export interface LldpProfileOptionTlvsManagementAddress {
    /**
     * Management address enabled
     */
    enabled?: boolean;
    /**
     * Iplist
     */
    iplists?: outputs.LldpProfileOptionTlvsManagementAddressIplist[];
}

export interface LldpProfileOptionTlvsManagementAddressIplist {
    /**
     * Interface
     */
    interface?: string;
    /**
     * IPv4 Address
     */
    ipv4?: string;
    /**
     * IPv6 Address
     */
    ipv6?: string;
    /**
     * Name
     */
    name?: string;
}

export interface LogForwardingProfileMatchList {
    /**
     * Match profile description
     */
    actionDesc?: string;
    /**
     * Filter match criteria
     */
    filter: string;
    /**
     * Log type
     */
    logType: string;
    /**
     * Name of the match profile
     */
    name: string;
    /**
     * A list of email server profiles
     */
    sendEmails?: string[];
    /**
     * A list of HTTP server profiles
     */
    sendHttps?: string[];
    /**
     * A list of SNMP server profiles
     */
    sendSnmptraps?: string[];
    /**
     * A list of syslog server profiles
     */
    sendSyslogs?: string[];
}

export interface LogicalRouterVrf {
    /**
     * Admin dists
     */
    adminDists?: outputs.LogicalRouterVrfAdminDists;
    /**
     * Bgp
     */
    bgp?: outputs.LogicalRouterVrfBgp;
    /**
     * Ecmp
     */
    ecmp?: outputs.LogicalRouterVrfEcmp;
    /**
     * Global vrid
     */
    globalVrid?: number;
    /**
     * Interface
     */
    interfaces?: string[];
    /**
     * Multicast
     */
    multicast?: outputs.LogicalRouterVrfMulticast;
    /**
     * Name
     */
    name: string;
    /**
     * Ospf
     */
    ospf?: outputs.LogicalRouterVrfOspf;
    /**
     * Ospfv3
     */
    ospfv3?: outputs.LogicalRouterVrfOspfv3;
    /**
     * Rib filter
     */
    ribFilter?: outputs.LogicalRouterVrfRibFilter;
    /**
     * Rip
     */
    rip?: outputs.LogicalRouterVrfRip;
    /**
     * Routing table
     */
    routingTable?: outputs.LogicalRouterVrfRoutingTable;
    /**
     * Sdwan type
     */
    sdwanType?: string;
    /**
     * Vr admin dists
     */
    vrAdminDists?: outputs.LogicalRouterVrfVrAdminDists;
    /**
     * Zone name
     */
    zoneName?: string;
}

export interface LogicalRouterVrfAdminDists {
    /**
     * Bgp external
     */
    bgpExternal?: number;
    /**
     * Bgp internal
     */
    bgpInternal?: number;
    /**
     * Bgp local
     */
    bgpLocal?: number;
    /**
     * Ospf ext
     */
    ospfExt?: number;
    /**
     * Ospf inter
     */
    ospfInter?: number;
    /**
     * Ospf intra
     */
    ospfIntra?: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext?: number;
    /**
     * Ospfv3 inter
     */
    ospfv3Inter?: number;
    /**
     * Ospfv3 intra
     */
    ospfv3Intra?: number;
    /**
     * Rip
     */
    rip?: number;
    /**
     * Static
     */
    static?: number;
    /**
     * Static ipv6
     */
    staticIpv6?: number;
}

export interface LogicalRouterVrfBgp {
    /**
     * Advertise network
     */
    advertiseNetwork?: outputs.LogicalRouterVrfBgpAdvertiseNetwork;
    /**
     * Aggregate
     */
    aggregate?: outputs.LogicalRouterVrfBgpAggregate;
    /**
     * Aggregate routes
     */
    aggregateRoutes?: outputs.LogicalRouterVrfBgpAggregateRoute[];
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute?: boolean;
    /**
     * Always advertise network route
     */
    alwaysAdvertiseNetworkRoute?: boolean;
    /**
     * As format
     */
    asFormat?: string;
    /**
     * Confederation member as
     */
    confederationMemberAs?: string;
    /**
     * Default local preference
     */
    defaultLocalPreference?: number;
    /**
     * Ecmp multi as
     */
    ecmpMultiAs?: boolean;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Enforce first as
     */
    enforceFirstAs?: boolean;
    /**
     * Fast external failover
     */
    fastExternalFailover?: boolean;
    /**
     * Global bfd
     */
    globalBfd?: outputs.LogicalRouterVrfBgpGlobalBfd;
    /**
     * Graceful restart
     */
    gracefulRestart?: outputs.LogicalRouterVrfBgpGracefulRestart;
    /**
     * Graceful shutdown
     */
    gracefulShutdown?: boolean;
    /**
     * Install route
     */
    installRoute?: boolean;
    /**
     * Local as
     */
    localAs?: string;
    /**
     * Med
     */
    med?: outputs.LogicalRouterVrfBgpMed;
    /**
     * Peer group
     */
    peerGroups?: outputs.LogicalRouterVrfBgpPeerGroup[];
    /**
     * Policy
     */
    policy?: outputs.LogicalRouterVrfBgpPolicy;
    /**
     * Redist rules
     */
    redistRules?: outputs.LogicalRouterVrfBgpRedistRule[];
    /**
     * Redistribution profile
     */
    redistributionProfile?: outputs.LogicalRouterVrfBgpRedistributionProfile;
    /**
     * Reject default route
     */
    rejectDefaultRoute?: boolean;
    /**
     * Router id
     */
    routerId?: string;
}

export interface LogicalRouterVrfBgpAdvertiseNetwork {
    /**
     * Ipv4
     */
    ipv4?: outputs.LogicalRouterVrfBgpAdvertiseNetworkIpv4;
    /**
     * Ipv6
     */
    ipv6?: outputs.LogicalRouterVrfBgpAdvertiseNetworkIpv6;
}

export interface LogicalRouterVrfBgpAdvertiseNetworkIpv4 {
    /**
     * Network
     */
    networks?: outputs.LogicalRouterVrfBgpAdvertiseNetworkIpv4Network[];
}

export interface LogicalRouterVrfBgpAdvertiseNetworkIpv4Network {
    /**
     * Backdoor
     */
    backdoor?: boolean;
    /**
     * Multicast
     */
    multicast?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast?: boolean;
}

export interface LogicalRouterVrfBgpAdvertiseNetworkIpv6 {
    /**
     * Network
     */
    networks?: outputs.LogicalRouterVrfBgpAdvertiseNetworkIpv6Network[];
}

export interface LogicalRouterVrfBgpAdvertiseNetworkIpv6Network {
    /**
     * Name
     */
    name: string;
    /**
     * Unicast
     */
    unicast?: boolean;
}

export interface LogicalRouterVrfBgpAggregate {
    /**
     * Aggregate med
     */
    aggregateMed?: boolean;
}

export interface LogicalRouterVrfBgpAggregateRoute {
    /**
     * As set
     */
    asSet?: boolean;
    /**
     * Description
     */
    description?: string;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Same med
     */
    sameMed?: boolean;
    /**
     * Summary only
     */
    summaryOnly?: boolean;
    /**
     * Type
     */
    type?: outputs.LogicalRouterVrfBgpAggregateRouteType;
}

export interface LogicalRouterVrfBgpAggregateRouteType {
    /**
     * Ipv4
     */
    ipv4?: outputs.LogicalRouterVrfBgpAggregateRouteTypeIpv4;
    /**
     * Ipv6
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4` and `ipv6`.
     */
    ipv6?: outputs.LogicalRouterVrfBgpAggregateRouteTypeIpv6;
}

export interface LogicalRouterVrfBgpAggregateRouteTypeIpv4 {
    /**
     * Attribute map
     */
    attributeMap?: string;
    /**
     * Summary prefix
     */
    summaryPrefix?: string;
    /**
     * Suppress map
     */
    suppressMap?: string;
}

export interface LogicalRouterVrfBgpAggregateRouteTypeIpv6 {
    /**
     * Attribute map
     */
    attributeMap?: string;
    /**
     * Summary prefix
     */
    summaryPrefix?: string;
    /**
     * Suppress map
     */
    suppressMap?: string;
}

export interface LogicalRouterVrfBgpGlobalBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfBgpGracefulRestart {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Local restart time
     */
    localRestartTime?: number;
    /**
     * Max peer restart time
     */
    maxPeerRestartTime?: number;
    /**
     * Stale route time
     */
    staleRouteTime?: number;
}

export interface LogicalRouterVrfBgpMed {
    /**
     * Always compare med
     */
    alwaysCompareMed?: boolean;
    /**
     * Deterministic med comparison
     */
    deterministicMedComparison?: boolean;
}

export interface LogicalRouterVrfBgpPeerGroup {
    /**
     * Address family
     */
    addressFamily?: outputs.LogicalRouterVrfBgpPeerGroupAddressFamily;
    /**
     * Aggregated confed as path
     */
    aggregatedConfedAsPath?: boolean;
    /**
     * Connection options
     */
    connectionOptions?: outputs.LogicalRouterVrfBgpPeerGroupConnectionOptions;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Filtering profile
     */
    filteringProfile?: outputs.LogicalRouterVrfBgpPeerGroupFilteringProfile;
    /**
     * Name
     */
    name: string;
    /**
     * Peer
     */
    peers?: outputs.LogicalRouterVrfBgpPeerGroupPeer[];
    /**
     * Soft reset with stored info
     */
    softResetWithStoredInfo?: boolean;
    /**
     * Type
     */
    type?: outputs.LogicalRouterVrfBgpPeerGroupType;
}

export interface LogicalRouterVrfBgpPeerGroupAddressFamily {
    /**
     * Ipv4
     */
    ipv4?: string;
    /**
     * Ipv6
     */
    ipv6?: string;
}

export interface LogicalRouterVrfBgpPeerGroupConnectionOptions {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Dampening
     */
    dampening?: string;
    /**
     * Multihop
     */
    multihop?: number;
    /**
     * Timers
     */
    timers?: string;
}

export interface LogicalRouterVrfBgpPeerGroupFilteringProfile {
    /**
     * Ipv4
     */
    ipv4?: string;
    /**
     * Ipv6
     */
    ipv6?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeer {
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfBgpPeerGroupPeerBfd;
    /**
     * Connection options
     */
    connectionOptions?: outputs.LogicalRouterVrfBgpPeerGroupPeerConnectionOptions;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Enable mp bgp
     */
    enableMpBgp?: boolean;
    /**
     * Enable sender side loop detection
     */
    enableSenderSideLoopDetection?: boolean;
    /**
     * Inherit
     */
    inherit?: outputs.LogicalRouterVrfBgpPeerGroupPeerInherit;
    /**
     * Local address
     */
    localAddress?: outputs.LogicalRouterVrfBgpPeerGroupPeerLocalAddress;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive?: boolean;
    /**
     * Peer address
     */
    peerAddress?: outputs.LogicalRouterVrfBgpPeerGroupPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs?: string;
    /**
     * Peering type
     */
    peeringType?: string;
    /**
     * Reflector client
     */
    reflectorClient?: string;
    /**
     * Subsequent address family identifier
     */
    subsequentAddressFamilyIdentifier?: outputs.LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier;
}

export interface LogicalRouterVrfBgpPeerGroupPeerBfd {
    /**
     * Multihop
     */
    multihop?: outputs.LogicalRouterVrfBgpPeerGroupPeerBfdMultihop;
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerBfdMultihop {
    /**
     * Min received ttl
     */
    minReceivedTtl?: number;
}

export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptions {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Dampening
     */
    dampening?: string;
    /**
     * Hold time
     */
    holdTime?: string;
    /**
     * Idle hold time
     */
    idleHoldTime?: number;
    /**
     * Incoming bgp connection
     */
    incomingBgpConnection?: outputs.LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection;
    /**
     * Keep alive interval
     */
    keepAliveInterval?: string;
    /**
     * Max prefixes
     */
    maxPrefixes?: string;
    /**
     * Min route adv interval
     */
    minRouteAdvInterval?: number;
    /**
     * Multihop
     */
    multihop?: string;
    /**
     * Open delay time
     */
    openDelayTime?: number;
    /**
     * Outgoing bgp connection
     */
    outgoingBgpConnection?: outputs.LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection;
    /**
     * Timers
     */
    timers?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection {
    /**
     * Allow
     */
    allow?: boolean;
    /**
     * Remote port
     */
    remotePort?: number;
}

export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection {
    /**
     * Allow
     */
    allow?: boolean;
    /**
     * Local port
     */
    localPort?: number;
}

export interface LogicalRouterVrfBgpPeerGroupPeerInherit {
    /**
     * No
     */
    no?: outputs.LogicalRouterVrfBgpPeerGroupPeerInheritNo;
    /**
     * Yes
     *
     * > ℹ️ **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
     */
    yes?: outputs.LogicalRouterVrfBgpPeerGroupPeerInheritYes;
}

export interface LogicalRouterVrfBgpPeerGroupPeerInheritNo {
    /**
     * Address family
     */
    addressFamily?: outputs.LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily;
    /**
     * Filtering profile
     */
    filteringProfile?: outputs.LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile;
}

export interface LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily {
    /**
     * Ipv4
     */
    ipv4?: string;
    /**
     * Ipv6
     */
    ipv6?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile {
    /**
     * Ipv4
     */
    ipv4?: string;
    /**
     * Ipv6
     */
    ipv6?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerInheritYes {
}

export interface LogicalRouterVrfBgpPeerGroupPeerLocalAddress {
    /**
     * Interface
     */
    interface?: string;
    /**
     * Ip
     */
    ip?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn?: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip?: string;
}

export interface LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier {
    /**
     * Multicast
     */
    multicast?: boolean;
    /**
     * Unicast
     */
    unicast?: boolean;
}

export interface LogicalRouterVrfBgpPeerGroupType {
    /**
     * Ebgp
     */
    ebgp?: outputs.LogicalRouterVrfBgpPeerGroupTypeEbgp;
    /**
     * Ebgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ebgpConfed?: outputs.LogicalRouterVrfBgpPeerGroupTypeEbgpConfed;
    /**
     * Ibgp
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgp?: outputs.LogicalRouterVrfBgpPeerGroupTypeIbgp;
    /**
     * Ibgp confed
     *
     * > ℹ️ **Note:** You must specify exactly one of `ebgp`, `ebgpConfed`, `ibgp`, and `ibgpConfed`.
     */
    ibgpConfed?: outputs.LogicalRouterVrfBgpPeerGroupTypeIbgpConfed;
}

export interface LogicalRouterVrfBgpPeerGroupTypeEbgp {
    /**
     * Export nexthop
     */
    exportNexthop?: string;
    /**
     * Import nexthop
     */
    importNexthop?: string;
    /**
     * Remove private as
     */
    removePrivateAs?: boolean;
}

export interface LogicalRouterVrfBgpPeerGroupTypeEbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop?: string;
}

export interface LogicalRouterVrfBgpPeerGroupTypeIbgp {
    /**
     * Export nexthop
     */
    exportNexthop?: string;
}

export interface LogicalRouterVrfBgpPeerGroupTypeIbgpConfed {
    /**
     * Export nexthop
     */
    exportNexthop?: string;
}

export interface LogicalRouterVrfBgpPolicy {
    /**
     * Aggregation
     */
    aggregation?: outputs.LogicalRouterVrfBgpPolicyAggregation;
    /**
     * Conditional advertisement
     */
    conditionalAdvertisement?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisement;
    /**
     * Export
     */
    export?: outputs.LogicalRouterVrfBgpPolicyExport;
    /**
     * Import
     */
    import?: outputs.LogicalRouterVrfBgpPolicyImport;
}

export interface LogicalRouterVrfBgpPolicyAggregation {
    /**
     * Address
     */
    addresses?: outputs.LogicalRouterVrfBgpPolicyAggregationAddress[];
}

export interface LogicalRouterVrfBgpPolicyAggregationAddress {
    /**
     * Advertise filters
     */
    advertiseFilters?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilter[];
    /**
     * Aggregate route attributes
     */
    aggregateRouteAttributes?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes;
    /**
     * As set
     */
    asSet?: boolean;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Prefix
     */
    prefix?: string;
    /**
     * Summary
     */
    summary?: boolean;
    /**
     * Suppress filters
     */
    suppressFilters?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilter[];
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilter {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes {
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath;
    /**
     * As path limit
     */
    asPathLimit?: number;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity;
    /**
     * Local preference
     */
    localPreference?: number;
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthop?: string;
    /**
     * Origin
     */
    origin?: string;
    /**
     * Weight
     */
    weight?: number;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath {
    /**
     * None
     */
    none?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend?: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend?: number;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilter {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisement {
    /**
     * Policy
     */
    policies?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy[];
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy {
    /**
     * Advertise filters
     */
    advertiseFilters?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter[];
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Non exist filters
     */
    nonExistFilters?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter[];
    /**
     * Used by
     */
    usedBies?: string[];
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilter {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilter {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyExport {
    /**
     * Rules
     */
    rules?: outputs.LogicalRouterVrfBgpPolicyExportRule[];
}

export interface LogicalRouterVrfBgpPolicyExportRule {
    /**
     * Action
     */
    action?: outputs.LogicalRouterVrfBgpPolicyExportRuleAction;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyExportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies?: string[];
}

export interface LogicalRouterVrfBgpPolicyExportRuleAction {
    /**
     * Allow
     */
    allow?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionDeny;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllow {
    /**
     * Update
     */
    update?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdate;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit?: number;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference?: number;
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthop?: string;
    /**
     * Origin
     */
    origin?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend?: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend?: number;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNone {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemove {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyExportRuleActionDeny {
}

export interface LogicalRouterVrfBgpPolicyExportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyExportRuleMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyExportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyImport {
    /**
     * Rules
     */
    rules?: outputs.LogicalRouterVrfBgpPolicyImportRule[];
}

export interface LogicalRouterVrfBgpPolicyImportRule {
    /**
     * Action
     */
    action?: outputs.LogicalRouterVrfBgpPolicyImportRuleAction;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Match
     */
    match?: outputs.LogicalRouterVrfBgpPolicyImportRuleMatch;
    /**
     * Name
     */
    name: string;
    /**
     * Used by
     */
    usedBies?: string[];
}

export interface LogicalRouterVrfBgpPolicyImportRuleAction {
    /**
     * Allow
     */
    allow?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllow;
    /**
     * Deny
     *
     * > ℹ️ **Note:** You must specify exactly one of `allow` and `deny`.
     */
    deny?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionDeny;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllow {
    /**
     * Dampening
     */
    dampening?: string;
    /**
     * Update
     */
    update?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdate;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdate {
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPath;
    /**
     * As path limit
     */
    asPathLimit?: number;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity;
    /**
     * Local preference
     */
    localPreference?: number;
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthop?: string;
    /**
     * Origin
     */
    origin?: string;
    /**
     * Weight
     */
    weight?: number;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPath {
    /**
     * None
     */
    none?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone;
    /**
     * Prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    prepend?: number;
    /**
     * Remove
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    remove?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove;
    /**
     * Remove and prepend
     *
     * > ℹ️ **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `removeAndPrepend`.
     */
    removeAndPrepend?: number;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNone {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemove {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunity {
    /**
     * Append
     */
    appends?: string[];
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    none?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone;
    /**
     * Overwrite
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    overwrites?: string[];
    /**
     * Remove all
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeAll?: outputs.LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll;
    /**
     * Remove regex
     *
     * > ℹ️ **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `removeAll`, and `removeRegex`.
     */
    removeRegex?: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNone {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAll {
}

export interface LogicalRouterVrfBgpPolicyImportRuleActionDeny {
}

export interface LogicalRouterVrfBgpPolicyImportRuleMatch {
    /**
     * Address prefix
     */
    addressPrefixes?: outputs.LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefix[];
    /**
     * Afi
     */
    afi?: string;
    /**
     * As path
     */
    asPath?: outputs.LogicalRouterVrfBgpPolicyImportRuleMatchAsPath;
    /**
     * Community
     */
    community?: outputs.LogicalRouterVrfBgpPolicyImportRuleMatchCommunity;
    /**
     * Extended community
     */
    extendedCommunity?: outputs.LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunity;
    /**
     * From peer
     */
    fromPeers?: string[];
    /**
     * Med
     */
    med?: number;
    /**
     * Nexthop
     */
    nexthops?: string[];
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Safi
     */
    safi?: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefix {
    /**
     * Exact
     */
    exact?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleMatchAsPath {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleMatchCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunity {
    /**
     * Regex
     */
    regex?: string;
}

export interface LogicalRouterVrfBgpRedistRule {
    /**
     * Address family identifier
     */
    addressFamilyIdentifier?: string;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Route table
     */
    routeTable?: string;
    /**
     * Set as path limit
     */
    setAsPathLimit?: number;
    /**
     * Set community
     */
    setCommunities?: string[];
    /**
     * Set extended community
     */
    setExtendedCommunities?: string[];
    /**
     * Set local preference
     */
    setLocalPreference?: number;
    /**
     * Set med
     */
    setMed?: number;
    /**
     * Set origin
     */
    setOrigin?: string;
}

export interface LogicalRouterVrfBgpRedistributionProfile {
    /**
     * Ipv4
     */
    ipv4?: outputs.LogicalRouterVrfBgpRedistributionProfileIpv4;
    /**
     * Ipv6
     */
    ipv6?: outputs.LogicalRouterVrfBgpRedistributionProfileIpv6;
}

export interface LogicalRouterVrfBgpRedistributionProfileIpv4 {
    /**
     * Unicast
     */
    unicast?: string;
}

export interface LogicalRouterVrfBgpRedistributionProfileIpv6 {
    /**
     * Unicast
     */
    unicast?: string;
}

export interface LogicalRouterVrfEcmp {
    /**
     * Algorithm
     */
    algorithm?: outputs.LogicalRouterVrfEcmpAlgorithm;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Max path
     */
    maxPath?: number;
    /**
     * Strict source path
     */
    strictSourcePath?: boolean;
    /**
     * Symmetric return
     */
    symmetricReturn?: boolean;
}

export interface LogicalRouterVrfEcmpAlgorithm {
    /**
     * Balanced round robin
     */
    balancedRoundRobin?: outputs.LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin;
    /**
     * Ip hash
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipHash?: outputs.LogicalRouterVrfEcmpAlgorithmIpHash;
    /**
     * Ip modulo
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    ipModulo?: outputs.LogicalRouterVrfEcmpAlgorithmIpModulo;
    /**
     * Weighted round robin
     *
     * > ℹ️ **Note:** You must specify exactly one of `balancedRoundRobin`, `ipHash`, `ipModulo`, and `weightedRoundRobin`.
     */
    weightedRoundRobin?: outputs.LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin;
}

export interface LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin {
}

export interface LogicalRouterVrfEcmpAlgorithmIpHash {
    /**
     * Hash seed
     */
    hashSeed?: number;
    /**
     * Src only
     */
    srcOnly?: boolean;
    /**
     * Use port
     */
    usePort?: boolean;
}

export interface LogicalRouterVrfEcmpAlgorithmIpModulo {
}

export interface LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin {
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface[];
}

export interface LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface {
    /**
     * Name
     */
    name: string;
    /**
     * Weight
     */
    weight?: number;
}

export interface LogicalRouterVrfMulticast {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Enable v6
     */
    enableV6?: boolean;
    /**
     * Igmp
     */
    igmp?: outputs.LogicalRouterVrfMulticastIgmp;
    /**
     * Interface group
     */
    interfaceGroups?: outputs.LogicalRouterVrfMulticastInterfaceGroup[];
    /**
     * Mode
     */
    mode?: string;
    /**
     * Msdp
     */
    msdp?: outputs.LogicalRouterVrfMulticastMsdp;
    /**
     * Pim
     */
    pim?: outputs.LogicalRouterVrfMulticastPim;
    /**
     * Route ageout time
     */
    routeAgeoutTime?: number;
    /**
     * Rp
     */
    rp?: outputs.LogicalRouterVrfMulticastRp;
    /**
     * Spt threshold
     */
    sptThresholds?: outputs.LogicalRouterVrfMulticastSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpaces?: outputs.LogicalRouterVrfMulticastSsmAddressSpace[];
    /**
     * Static route
     */
    staticRoutes?: outputs.LogicalRouterVrfMulticastStaticRoute[];
}

export interface LogicalRouterVrfMulticastIgmp {
    /**
     * Dynamic
     */
    dynamic?: outputs.LogicalRouterVrfMulticastIgmpDynamic;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Static
     */
    statics?: outputs.LogicalRouterVrfMulticastIgmpStatic[];
}

export interface LogicalRouterVrfMulticastIgmpDynamic {
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfMulticastIgmpDynamicInterface[];
}

export interface LogicalRouterVrfMulticastIgmpDynamicInterface {
    /**
     * Group filter
     */
    groupFilter?: string;
    /**
     * Max groups
     */
    maxGroups?: string;
    /**
     * Max sources
     */
    maxSources?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Query profile
     */
    queryProfile?: string;
    /**
     * Robustness
     */
    robustness?: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing?: boolean;
    /**
     * Version
     */
    version?: string;
}

export interface LogicalRouterVrfMulticastIgmpStatic {
    /**
     * Group address
     */
    groupAddress?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress?: string;
}

export interface LogicalRouterVrfMulticastInterfaceGroup {
    /**
     * Description
     */
    description?: string;
    /**
     * Group permission
     */
    groupPermission?: outputs.LogicalRouterVrfMulticastInterfaceGroupGroupPermission;
    /**
     * Igmp
     */
    igmp?: outputs.LogicalRouterVrfMulticastInterfaceGroupIgmp;
    /**
     * Interface
     */
    interfaces?: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Pim
     */
    pim?: outputs.LogicalRouterVrfMulticastInterfaceGroupPim;
}

export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermission {
    /**
     * Any source multicast
     */
    anySourceMulticasts?: outputs.LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[];
    /**
     * Source specific multicast
     */
    sourceSpecificMulticasts?: outputs.LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[];
}

export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast {
    /**
     * Group address
     */
    groupAddress?: string;
    /**
     * Included
     */
    included?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast {
    /**
     * Group address
     */
    groupAddress?: string;
    /**
     * Included
     */
    included?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Source address
     */
    sourceAddress?: string;
}

export interface LogicalRouterVrfMulticastInterfaceGroupIgmp {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Immediate leave
     */
    immediateLeave?: boolean;
    /**
     * Last member query interval
     */
    lastMemberQueryInterval?: number;
    /**
     * Max groups
     */
    maxGroups?: string;
    /**
     * Max query response time
     */
    maxQueryResponseTime?: number;
    /**
     * Max sources
     */
    maxSources?: string;
    /**
     * Mode
     */
    mode?: string;
    /**
     * Query interval
     */
    queryInterval?: number;
    /**
     * Robustness
     */
    robustness?: string;
    /**
     * Router alert policing
     */
    routerAlertPolicing?: boolean;
    /**
     * Version
     */
    version?: string;
}

export interface LogicalRouterVrfMulticastInterfaceGroupPim {
    /**
     * Allowed neighbors
     */
    allowedNeighbors?: outputs.LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbor[];
    /**
     * Assert interval
     */
    assertInterval?: number;
    /**
     * Bsr border
     */
    bsrBorder?: boolean;
    /**
     * Dr priority
     */
    drPriority?: number;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Hello interval
     */
    helloInterval?: number;
    /**
     * Join prune interval
     */
    joinPruneInterval?: number;
}

export interface LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfMulticastMsdp {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Global authentication
     */
    globalAuthentication?: string;
    /**
     * Global timer
     */
    globalTimer?: string;
    /**
     * Originator id
     */
    originatorId?: outputs.LogicalRouterVrfMulticastMsdpOriginatorId;
    /**
     * Peer
     */
    peers?: outputs.LogicalRouterVrfMulticastMsdpPeer[];
}

export interface LogicalRouterVrfMulticastMsdpOriginatorId {
    /**
     * Interface
     */
    interface?: string;
    /**
     * Ip
     */
    ip?: string;
}

export interface LogicalRouterVrfMulticastMsdpPeer {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Inbound sa filter
     */
    inboundSaFilter?: string;
    /**
     * Local address
     */
    localAddress?: outputs.LogicalRouterVrfMulticastMsdpPeerLocalAddress;
    /**
     * Max sa
     */
    maxSa?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Outbound sa filter
     */
    outboundSaFilter?: string;
    /**
     * Peer address
     */
    peerAddress?: outputs.LogicalRouterVrfMulticastMsdpPeerPeerAddress;
    /**
     * Peer as
     */
    peerAs?: string;
}

export interface LogicalRouterVrfMulticastMsdpPeerLocalAddress {
    /**
     * Interface
     */
    interface?: string;
    /**
     * Ip
     */
    ip?: string;
}

export interface LogicalRouterVrfMulticastMsdpPeerPeerAddress {
    /**
     * Fqdn
     */
    fqdn?: string;
    /**
     * Ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ip`.
     */
    ip?: string;
}

export interface LogicalRouterVrfMulticastPim {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Group permission
     */
    groupPermission?: string;
    /**
     * If timer global
     */
    ifTimerGlobal?: string;
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfMulticastPimInterface[];
    /**
     * Route ageout time
     */
    routeAgeoutTime?: number;
    /**
     * Rp
     */
    rp?: outputs.LogicalRouterVrfMulticastPimRp;
    /**
     * Rpf lookup mode
     */
    rpfLookupMode?: string;
    /**
     * Spt threshold
     */
    sptThresholds?: outputs.LogicalRouterVrfMulticastPimSptThreshold[];
    /**
     * Ssm address space
     */
    ssmAddressSpace?: outputs.LogicalRouterVrfMulticastPimSsmAddressSpace;
}

export interface LogicalRouterVrfMulticastPimInterface {
    /**
     * Description
     */
    description?: string;
    /**
     * Dr priority
     */
    drPriority?: number;
    /**
     * If timer
     */
    ifTimer?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor filter
     */
    neighborFilter?: string;
    /**
     * Send bsm
     */
    sendBsm?: boolean;
}

export interface LogicalRouterVrfMulticastPimRp {
    /**
     * External rp
     */
    externalRps?: outputs.LogicalRouterVrfMulticastPimRpExternalRp[];
    /**
     * Local rp
     */
    localRp?: outputs.LogicalRouterVrfMulticastPimRpLocalRp;
}

export interface LogicalRouterVrfMulticastPimRpExternalRp {
    /**
     * Group list
     */
    groupList?: string;
    /**
     * Name
     */
    name?: string;
    /**
     * Override
     */
    override?: boolean;
}

export interface LogicalRouterVrfMulticastPimRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp?: outputs.LogicalRouterVrfMulticastPimRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp?: outputs.LogicalRouterVrfMulticastPimRpLocalRpStaticRp;
}

export interface LogicalRouterVrfMulticastPimRpLocalRpCandidateRp {
    /**
     * Address
     */
    address?: string;
    /**
     * Advertisement interval
     */
    advertisementInterval?: number;
    /**
     * Group list
     */
    groupList?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Priority
     */
    priority?: number;
}

export interface LogicalRouterVrfMulticastPimRpLocalRpStaticRp {
    /**
     * Address
     */
    address?: string;
    /**
     * Group list
     */
    groupList?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Override
     */
    override?: boolean;
}

export interface LogicalRouterVrfMulticastPimSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold?: string;
}

export interface LogicalRouterVrfMulticastPimSsmAddressSpace {
    /**
     * Group list
     */
    groupList?: string;
}

export interface LogicalRouterVrfMulticastRp {
    /**
     * External rp
     */
    externalRps?: outputs.LogicalRouterVrfMulticastRpExternalRp[];
    /**
     * Local rp
     */
    localRp?: outputs.LogicalRouterVrfMulticastRpLocalRp;
}

export interface LogicalRouterVrfMulticastRpExternalRp {
    /**
     * Group addresses
     */
    groupAddresses?: string[];
    /**
     * Name
     */
    name: string;
    /**
     * Override
     */
    override?: boolean;
}

export interface LogicalRouterVrfMulticastRpLocalRp {
    /**
     * Candidate rp
     */
    candidateRp?: outputs.LogicalRouterVrfMulticastRpLocalRpCandidateRp;
    /**
     * Static rp
     *
     * > ℹ️ **Note:** You must specify exactly one of `candidateRp` and `staticRp`.
     */
    staticRp?: outputs.LogicalRouterVrfMulticastRpLocalRpStaticRp;
}

export interface LogicalRouterVrfMulticastRpLocalRpCandidateRp {
    /**
     * Address
     */
    address?: string;
    /**
     * Advertisement interval
     */
    advertisementInterval?: number;
    /**
     * Group addresses
     */
    groupAddresses?: string[];
    /**
     * Interface
     */
    interface?: string;
    /**
     * Priority
     */
    priority?: number;
}

export interface LogicalRouterVrfMulticastRpLocalRpStaticRp {
    /**
     * Address
     */
    address?: string;
    /**
     * Group addresses
     */
    groupAddresses?: string[];
    /**
     * Interface
     */
    interface?: string;
    /**
     * Override
     */
    override?: boolean;
}

export interface LogicalRouterVrfMulticastSptThreshold {
    /**
     * Name
     */
    name: string;
    /**
     * Threshold
     */
    threshold?: string;
}

export interface LogicalRouterVrfMulticastSsmAddressSpace {
    /**
     * Group address
     */
    groupAddress?: string;
    /**
     * Included
     */
    included?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfMulticastStaticRoute {
    /**
     * Destination
     */
    destination?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop?: outputs.LogicalRouterVrfMulticastStaticRouteNexthop;
    /**
     * Preference
     */
    preference?: number;
}

export interface LogicalRouterVrfMulticastStaticRouteNexthop {
    /**
     * Ip address
     */
    ipAddress?: string;
}

export interface LogicalRouterVrfOspf {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute?: boolean;
    /**
     * Area
     */
    areas?: outputs.LogicalRouterVrfOspfArea[];
    /**
     * Auth profile
     */
    authProfiles?: outputs.LogicalRouterVrfOspfAuthProfile[];
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Export rules
     */
    exportRules?: outputs.LogicalRouterVrfOspfExportRule[];
    /**
     * Flood prevention
     */
    floodPrevention?: outputs.LogicalRouterVrfOspfFloodPrevention;
    /**
     * Global bfd
     */
    globalBfd?: outputs.LogicalRouterVrfOspfGlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer?: string;
    /**
     * Graceful restart
     */
    gracefulRestart?: outputs.LogicalRouterVrfOspfGracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile?: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute?: boolean;
    /**
     * Rfc1583
     */
    rfc1583?: boolean;
    /**
     * Router id
     */
    routerId?: string;
    /**
     * Spf timer
     */
    spfTimer?: string;
    /**
     * Vr timers
     */
    vrTimers?: outputs.LogicalRouterVrfOspfVrTimers;
}

export interface LogicalRouterVrfOspfArea {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfOspfAreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges?: outputs.LogicalRouterVrfOspfAreaRange[];
    /**
     * Type
     */
    type?: outputs.LogicalRouterVrfOspfAreaType;
    /**
     * Virtual link
     */
    virtualLinks?: outputs.LogicalRouterVrfOspfAreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges?: outputs.LogicalRouterVrfOspfAreaVrRange[];
}

export interface LogicalRouterVrfOspfAreaInterface {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfOspfAreaInterfaceBfd;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Link type
     */
    linkType?: outputs.LogicalRouterVrfOspfAreaInterfaceLinkType;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Mtu ignore
     */
    mtuIgnore?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Passive
     */
    passive?: boolean;
    /**
     * Priority
     */
    priority?: number;
    /**
     * Timing
     */
    timing?: string;
    /**
     * Vr timing
     */
    vrTiming?: outputs.LogicalRouterVrfOspfAreaInterfaceVrTiming;
}

export interface LogicalRouterVrfOspfAreaInterfaceBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfAreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast?: outputs.LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp?: outputs.LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p?: outputs.LogicalRouterVrfOspfAreaInterfaceLinkTypeP2p;
}

export interface LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast {
}

export interface LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors?: outputs.LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority?: number;
}

export interface LogicalRouterVrfOspfAreaInterfaceLinkTypeP2p {
}

export interface LogicalRouterVrfOspfAreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts?: number;
    /**
     * Gr delay
     */
    grDelay?: number;
    /**
     * Hello interval
     */
    helloInterval?: number;
    /**
     * Retransmit interval
     */
    retransmitInterval?: number;
    /**
     * Transit delay
     */
    transitDelay?: number;
}

export interface LogicalRouterVrfOspfAreaRange {
    /**
     * Advertise
     */
    advertise?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Substitute
     */
    substitute?: string;
}

export interface LogicalRouterVrfOspfAreaType {
    /**
     * Normal
     */
    normal?: outputs.LogicalRouterVrfOspfAreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa?: outputs.LogicalRouterVrfOspfAreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub?: outputs.LogicalRouterVrfOspfAreaTypeStub;
}

export interface LogicalRouterVrfOspfAreaTypeNormal {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfAreaTypeNormalAbr;
}

export interface LogicalRouterVrfOspfAreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfAreaTypeNssa {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfAreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary?: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate?: outputs.LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute?: outputs.LogicalRouterVrfOspfAreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary?: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges?: outputs.LogicalRouterVrfOspfAreaTypeNssaNssaExtRange[];
}

export interface LogicalRouterVrfOspfAreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges?: outputs.LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag?: number;
}

export interface LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Metric type
     */
    metricType?: string;
}

export interface LogicalRouterVrfOspfAreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable?: outputs.LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisable;
}

export interface LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Type
     */
    type?: string;
}

export interface LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisable {
}

export interface LogicalRouterVrfOspfAreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress?: outputs.LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppress;
}

export interface LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertise {
}

export interface LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppress {
}

export interface LogicalRouterVrfOspfAreaTypeStub {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfAreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary?: boolean;
    /**
     * Default route
     */
    defaultRoute?: outputs.LogicalRouterVrfOspfAreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric?: number;
    /**
     * No summary
     */
    noSummary?: boolean;
}

export interface LogicalRouterVrfOspfAreaTypeStubAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfAreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable?: outputs.LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisable;
}

export interface LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric?: number;
}

export interface LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisable {
}

export interface LogicalRouterVrfOspfAreaVirtualLink {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfOspfAreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Instance id
     */
    instanceId?: number;
    /**
     * Interface id
     */
    interfaceId?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId?: string;
    /**
     * Passive
     */
    passive?: boolean;
    /**
     * Timing
     */
    timing?: string;
    /**
     * Transit area id
     */
    transitAreaId?: string;
    /**
     * Vr timing
     */
    vrTiming?: outputs.LogicalRouterVrfOspfAreaVirtualLinkVrTiming;
}

export interface LogicalRouterVrfOspfAreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfAreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts?: number;
    /**
     * Hello interval
     */
    helloInterval?: number;
    /**
     * Retransmit interval
     */
    retransmitInterval?: number;
    /**
     * Transit delay
     */
    transitDelay?: number;
}

export interface LogicalRouterVrfOspfAreaVrRange {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfAreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress?: outputs.LogicalRouterVrfOspfAreaVrRangeSuppress;
}

export interface LogicalRouterVrfOspfAreaVrRangeAdvertise {
}

export interface LogicalRouterVrfOspfAreaVrRangeSuppress {
}

export interface LogicalRouterVrfOspfAuthProfile {
    /**
     * Md5
     */
    md5s?: outputs.LogicalRouterVrfOspfAuthProfileMd5[];
    /**
     * Name
     */
    name: string;
    /**
     * Password
     */
    password?: string;
}

export interface LogicalRouterVrfOspfAuthProfileMd5 {
    /**
     * Key
     */
    key?: string;
    /**
     * Name
     */
    name: number;
    /**
     * Preferred
     */
    preferred?: boolean;
}

export interface LogicalRouterVrfOspfExportRule {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType?: string;
    /**
     * New tag
     */
    newTag?: string;
}

export interface LogicalRouterVrfOspfFloodPrevention {
    /**
     * Hello
     */
    hello?: outputs.LogicalRouterVrfOspfFloodPreventionHello;
    /**
     * Lsa
     */
    lsa?: outputs.LogicalRouterVrfOspfFloodPreventionLsa;
}

export interface LogicalRouterVrfOspfFloodPreventionHello {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Max packet
     */
    maxPacket?: number;
}

export interface LogicalRouterVrfOspfFloodPreventionLsa {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Max packet
     */
    maxPacket?: number;
}

export interface LogicalRouterVrfOspfGlobalBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfGracefulRestart {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Grace period
     */
    gracePeriod?: number;
    /**
     * Helper enable
     */
    helperEnable?: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime?: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking?: boolean;
}

export interface LogicalRouterVrfOspfVrTimers {
    /**
     * Lsa interval
     */
    lsaInterval?: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay?: number;
}

export interface LogicalRouterVrfOspfv3 {
    /**
     * Allow redist default route
     */
    allowRedistDefaultRoute?: boolean;
    /**
     * Area
     */
    areas?: outputs.LogicalRouterVrfOspfv3Area[];
    /**
     * Auth profile
     */
    authProfiles?: outputs.LogicalRouterVrfOspfv3AuthProfile[];
    /**
     * Disable transit traffic
     */
    disableTransitTraffic?: boolean;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Export rules
     */
    exportRules?: outputs.LogicalRouterVrfOspfv3ExportRule[];
    /**
     * Global bfd
     */
    globalBfd?: outputs.LogicalRouterVrfOspfv3GlobalBfd;
    /**
     * Global if timer
     */
    globalIfTimer?: string;
    /**
     * Graceful restart
     */
    gracefulRestart?: outputs.LogicalRouterVrfOspfv3GracefulRestart;
    /**
     * Redistribution profile
     */
    redistributionProfile?: string;
    /**
     * Reject default route
     */
    rejectDefaultRoute?: boolean;
    /**
     * Router id
     */
    routerId?: string;
    /**
     * Spf timer
     */
    spfTimer?: string;
    /**
     * Vr timers
     */
    vrTimers?: outputs.LogicalRouterVrfOspfv3VrTimers;
}

export interface LogicalRouterVrfOspfv3Area {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfOspfv3AreaInterface[];
    /**
     * Name
     */
    name: string;
    /**
     * Range
     */
    ranges?: outputs.LogicalRouterVrfOspfv3AreaRange[];
    /**
     * Type
     */
    type?: outputs.LogicalRouterVrfOspfv3AreaType;
    /**
     * Virtual link
     */
    virtualLinks?: outputs.LogicalRouterVrfOspfv3AreaVirtualLink[];
    /**
     * Vr range
     */
    vrRanges?: outputs.LogicalRouterVrfOspfv3AreaVrRange[];
}

export interface LogicalRouterVrfOspfv3AreaInterface {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfOspfv3AreaInterfaceBfd;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Instance id
     */
    instanceId?: number;
    /**
     * Link type
     */
    linkType?: outputs.LogicalRouterVrfOspfv3AreaInterfaceLinkType;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Mtu ignore
     */
    mtuIgnore?: boolean;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor
     */
    neighbors?: outputs.LogicalRouterVrfOspfv3AreaInterfaceNeighbor[];
    /**
     * Passive
     */
    passive?: boolean;
    /**
     * Priority
     */
    priority?: number;
    /**
     * Timing
     */
    timing?: string;
    /**
     * Vr timing
     */
    vrTiming?: outputs.LogicalRouterVrfOspfv3AreaInterfaceVrTiming;
}

export interface LogicalRouterVrfOspfv3AreaInterfaceBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfv3AreaInterfaceLinkType {
    /**
     * Broadcast
     */
    broadcast?: outputs.LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcast;
    /**
     * P2mp
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2mp?: outputs.LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mp;
    /**
     * P2p
     *
     * > ℹ️ **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
     */
    p2p?: outputs.LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2p;
}

export interface LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcast {
}

export interface LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mp {
    /**
     * Neighbor
     */
    neighbors?: outputs.LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor[];
}

export interface LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor {
    /**
     * Name
     */
    name: string;
    /**
     * Priority
     */
    priority?: number;
}

export interface LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2p {
}

export interface LogicalRouterVrfOspfv3AreaInterfaceNeighbor {
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfOspfv3AreaInterfaceVrTiming {
    /**
     * Dead counts
     */
    deadCounts?: number;
    /**
     * Gr delay
     */
    grDelay?: number;
    /**
     * Hello interval
     */
    helloInterval?: number;
    /**
     * Retransmit interval
     */
    retransmitInterval?: number;
    /**
     * Transit delay
     */
    transitDelay?: number;
}

export interface LogicalRouterVrfOspfv3AreaRange {
    /**
     * Advertise
     */
    advertise?: boolean;
    /**
     * Name
     */
    name: string;
}

export interface LogicalRouterVrfOspfv3AreaType {
    /**
     * Normal
     */
    normal?: outputs.LogicalRouterVrfOspfv3AreaTypeNormal;
    /**
     * Nssa
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    nssa?: outputs.LogicalRouterVrfOspfv3AreaTypeNssa;
    /**
     * Stub
     *
     * > ℹ️ **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
     */
    stub?: outputs.LogicalRouterVrfOspfv3AreaTypeStub;
}

export interface LogicalRouterVrfOspfv3AreaTypeNormal {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfv3AreaTypeNormalAbr;
}

export interface LogicalRouterVrfOspfv3AreaTypeNormalAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssa {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaAbr;
    /**
     * Accept summary
     */
    acceptSummary?: boolean;
    /**
     * Default information originate
     */
    defaultInformationOriginate?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginate;
    /**
     * Default route
     */
    defaultRoute?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaDefaultRoute;
    /**
     * No summary
     */
    noSummary?: boolean;
    /**
     * Nssa ext range
     */
    nssaExtRanges?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRange[];
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Nssa ext range
     */
    nssaExtRanges?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRange[];
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRange {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag?: number;
    /**
     * Suppress
     */
    suppress?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertise {
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppress {
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginate {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Metric type
     */
    metricType?: string;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaDefaultRoute {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisable;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Type
     */
    type?: string;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisable {
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRange {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Route tag
     */
    routeTag?: number;
    /**
     * Suppress
     */
    suppress?: outputs.LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppress;
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertise {
}

export interface LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppress {
}

export interface LogicalRouterVrfOspfv3AreaTypeStub {
    /**
     * Abr
     */
    abr?: outputs.LogicalRouterVrfOspfv3AreaTypeStubAbr;
    /**
     * Accept summary
     */
    acceptSummary?: boolean;
    /**
     * Default route
     */
    defaultRoute?: outputs.LogicalRouterVrfOspfv3AreaTypeStubDefaultRoute;
    /**
     * Default route metric
     */
    defaultRouteMetric?: number;
    /**
     * No summary
     */
    noSummary?: boolean;
}

export interface LogicalRouterVrfOspfv3AreaTypeStubAbr {
    /**
     * Export list
     */
    exportList?: string;
    /**
     * Import list
     */
    importList?: string;
    /**
     * Inbound filter list
     */
    inboundFilterList?: string;
    /**
     * Outbound filter list
     */
    outboundFilterList?: string;
}

export interface LogicalRouterVrfOspfv3AreaTypeStubDefaultRoute {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertise;
    /**
     * Disable
     *
     * > ℹ️ **Note:** You must specify exactly one of `advertise` and `disable`.
     */
    disable?: outputs.LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisable;
}

export interface LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertise {
    /**
     * Metric
     */
    metric?: number;
}

export interface LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisable {
}

export interface LogicalRouterVrfOspfv3AreaVirtualLink {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfOspfv3AreaVirtualLinkBfd;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Instance id
     */
    instanceId?: number;
    /**
     * Interface id
     */
    interfaceId?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Neighbor id
     */
    neighborId?: string;
    /**
     * Passive
     */
    passive?: boolean;
    /**
     * Timing
     */
    timing?: string;
    /**
     * Transit area id
     */
    transitAreaId?: string;
    /**
     * Vr timing
     */
    vrTiming?: outputs.LogicalRouterVrfOspfv3AreaVirtualLinkVrTiming;
}

export interface LogicalRouterVrfOspfv3AreaVirtualLinkBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfv3AreaVirtualLinkVrTiming {
    /**
     * Dead counts
     */
    deadCounts?: number;
    /**
     * Hello interval
     */
    helloInterval?: number;
    /**
     * Retransmit interval
     */
    retransmitInterval?: number;
    /**
     * Transit delay
     */
    transitDelay?: number;
}

export interface LogicalRouterVrfOspfv3AreaVrRange {
    /**
     * Advertise
     */
    advertise?: outputs.LogicalRouterVrfOspfv3AreaVrRangeAdvertise;
    /**
     * Name
     */
    name: string;
    /**
     * Suppress
     */
    suppress?: outputs.LogicalRouterVrfOspfv3AreaVrRangeSuppress;
}

export interface LogicalRouterVrfOspfv3AreaVrRangeAdvertise {
}

export interface LogicalRouterVrfOspfv3AreaVrRangeSuppress {
}

export interface LogicalRouterVrfOspfv3AuthProfile {
    /**
     * Ah
     */
    ah?: outputs.LogicalRouterVrfOspfv3AuthProfileAh;
    /**
     * Esp
     */
    esp?: outputs.LogicalRouterVrfOspfv3AuthProfileEsp;
    /**
     * Name
     */
    name: string;
    /**
     * Spi
     */
    spi?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileAh {
    /**
     * Md5
     */
    md5?: outputs.LogicalRouterVrfOspfv3AuthProfileAhMd5;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1?: outputs.LogicalRouterVrfOspfv3AuthProfileAhSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256?: outputs.LogicalRouterVrfOspfv3AuthProfileAhSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384?: outputs.LogicalRouterVrfOspfv3AuthProfileAhSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512?: outputs.LogicalRouterVrfOspfv3AuthProfileAhSha512;
}

export interface LogicalRouterVrfOspfv3AuthProfileAhMd5 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileAhSha1 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileAhSha256 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileAhSha384 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileAhSha512 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEsp {
    /**
     * Authentication
     */
    authentication?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthentication;
    /**
     * Encryption
     */
    encryption?: outputs.LogicalRouterVrfOspfv3AuthProfileEspEncryption;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthentication {
    /**
     * Md5
     */
    md5?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    none?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNone;
    /**
     * Sha1
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha1?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1;
    /**
     * Sha256
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha256?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256;
    /**
     * Sha384
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha384?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384;
    /**
     * Sha512
     *
     * > ℹ️ **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
     */
    sha512?: outputs.LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNone {
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512 {
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3AuthProfileEspEncryption {
    /**
     * Algorithm
     */
    algorithm?: string;
    /**
     * Key
     */
    key?: string;
}

export interface LogicalRouterVrfOspfv3ExportRule {
    /**
     * Metric
     */
    metric?: number;
    /**
     * Name
     */
    name: string;
    /**
     * New path type
     */
    newPathType?: string;
    /**
     * New tag
     */
    newTag?: string;
}

export interface LogicalRouterVrfOspfv3GlobalBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfOspfv3GracefulRestart {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Grace period
     */
    gracePeriod?: number;
    /**
     * Helper enable
     */
    helperEnable?: boolean;
    /**
     * Max neighbor restart time
     */
    maxNeighborRestartTime?: number;
    /**
     * Strict l s a checking
     */
    strictLsaChecking?: boolean;
}

export interface LogicalRouterVrfOspfv3VrTimers {
    /**
     * Lsa interval
     */
    lsaInterval?: number;
    /**
     * Spf calculation delay
     */
    spfCalculationDelay?: number;
}

export interface LogicalRouterVrfRibFilter {
    /**
     * Ipv4
     */
    ipv4?: outputs.LogicalRouterVrfRibFilterIpv4;
    /**
     * Ipv6
     */
    ipv6?: outputs.LogicalRouterVrfRibFilterIpv6;
}

export interface LogicalRouterVrfRibFilterIpv4 {
    /**
     * Bgp
     */
    bgp?: outputs.LogicalRouterVrfRibFilterIpv4Bgp;
    /**
     * Ospf
     */
    ospf?: outputs.LogicalRouterVrfRibFilterIpv4Ospf;
    /**
     * Rip
     */
    rip?: outputs.LogicalRouterVrfRibFilterIpv4Rip;
    /**
     * Static
     */
    static?: outputs.LogicalRouterVrfRibFilterIpv4Static;
}

export interface LogicalRouterVrfRibFilterIpv4Bgp {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv4Ospf {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv4Rip {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv4Static {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv6 {
    /**
     * Bgp
     */
    bgp?: outputs.LogicalRouterVrfRibFilterIpv6Bgp;
    /**
     * Ospfv3
     */
    ospfv3?: outputs.LogicalRouterVrfRibFilterIpv6Ospfv3;
    /**
     * Static
     */
    static?: outputs.LogicalRouterVrfRibFilterIpv6Static;
}

export interface LogicalRouterVrfRibFilterIpv6Bgp {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv6Ospfv3 {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRibFilterIpv6Static {
    /**
     * Route map
     */
    routeMap?: string;
}

export interface LogicalRouterVrfRip {
    /**
     * Auth profile
     */
    authProfile?: string;
    /**
     * Default information originate
     */
    defaultInformationOriginate?: boolean;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Global bfd
     */
    globalBfd?: outputs.LogicalRouterVrfRipGlobalBfd;
    /**
     * Global inbound distribute list
     */
    globalInboundDistributeList?: outputs.LogicalRouterVrfRipGlobalInboundDistributeList;
    /**
     * Global outbound distribute list
     */
    globalOutboundDistributeList?: outputs.LogicalRouterVrfRipGlobalOutboundDistributeList;
    /**
     * Global timer
     */
    globalTimer?: string;
    /**
     * Interface
     */
    interfaces?: outputs.LogicalRouterVrfRipInterface[];
    /**
     * Redistribution profile
     */
    redistributionProfile?: string;
}

export interface LogicalRouterVrfRipGlobalBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfRipGlobalInboundDistributeList {
    /**
     * Access list
     */
    accessList?: string;
}

export interface LogicalRouterVrfRipGlobalOutboundDistributeList {
    /**
     * Access list
     */
    accessList?: string;
}

export interface LogicalRouterVrfRipInterface {
    /**
     * Authentication
     */
    authentication?: string;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfRipInterfaceBfd;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Interface inbound distribute list
     */
    interfaceInboundDistributeList?: outputs.LogicalRouterVrfRipInterfaceInterfaceInboundDistributeList;
    /**
     * Interface outbound distribute list
     */
    interfaceOutboundDistributeList?: outputs.LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeList;
    /**
     * Mode
     */
    mode?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Split horizon
     */
    splitHorizon?: string;
}

export interface LogicalRouterVrfRipInterfaceBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfRipInterfaceInterfaceInboundDistributeList {
    /**
     * Access list
     */
    accessList?: string;
    /**
     * Metric
     */
    metric?: number;
}

export interface LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeList {
    /**
     * Access list
     */
    accessList?: string;
    /**
     * Metric
     */
    metric?: number;
}

export interface LogicalRouterVrfRoutingTable {
    /**
     * Ip
     */
    ip?: outputs.LogicalRouterVrfRoutingTableIp;
    /**
     * Ipv6
     */
    ipv6?: outputs.LogicalRouterVrfRoutingTableIpv6;
}

export interface LogicalRouterVrfRoutingTableIp {
    /**
     * Static route
     */
    staticRoutes?: outputs.LogicalRouterVrfRoutingTableIpStaticRoute[];
}

export interface LogicalRouterVrfRoutingTableIpStaticRoute {
    /**
     * Admin dist
     */
    adminDist?: number;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteBfd;
    /**
     * Destination
     */
    destination?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteNexthop;
    /**
     * Path monitor
     */
    pathMonitor?: outputs.LogicalRouterVrfRoutingTableIpStaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteRouteTable;
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteNexthop {
    /**
     * Discard
     */
    discard?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn?: string;
    /**
     * Ip address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipAddress?: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address?: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr?: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr?: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipAddress`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel?: string;
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscard {
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceive {
}

export interface LogicalRouterVrfRoutingTableIpStaticRoutePathMonitor {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Failure condition
     */
    failureCondition?: string;
    /**
     * Hold time
     */
    holdTime?: number;
    /**
     * Monitor destinations
     */
    monitorDestinations?: outputs.LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination[];
}

export interface LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count?: number;
    /**
     * Destination
     */
    destination?: string;
    /**
     * Destination fqdn
     */
    destinationFqdn?: string;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Interval
     */
    interval?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source?: string;
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteRouteTable {
    /**
     * Both
     */
    both?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBoth;
    /**
     * Multicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    multicast?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticast;
    /**
     * No install
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    noInstall?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstall;
    /**
     * Unicast
     *
     * > ℹ️ **Note:** You must specify exactly one of `both`, `multicast`, `noInstall`, and `unicast`.
     */
    unicast?: outputs.LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicast;
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBoth {
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticast {
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstall {
}

export interface LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicast {
}

export interface LogicalRouterVrfRoutingTableIpv6 {
    /**
     * Static route
     */
    staticRoutes?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRoute[];
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRoute {
    /**
     * Admin dist
     */
    adminDist?: number;
    /**
     * Bfd
     */
    bfd?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteBfd;
    /**
     * Destination
     */
    destination?: string;
    /**
     * Interface
     */
    interface?: string;
    /**
     * Metric
     */
    metric?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Nexthop
     */
    nexthop?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteNexthop;
    /**
     * Option
     */
    option?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteOption;
    /**
     * Path monitor
     */
    pathMonitor?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitor;
    /**
     * Route table
     */
    routeTable?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTable;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteBfd {
    /**
     * Profile
     */
    profile?: string;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteNexthop {
    /**
     * Discard
     */
    discard?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscard;
    /**
     * Fqdn
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    fqdn?: string;
    /**
     * Ipv6 address
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    ipv6Address?: string;
    /**
     * Next lr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextLr?: string;
    /**
     * Next vr
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    nextVr?: string;
    /**
     * Receive
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    receive?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceive;
    /**
     * Tunnel
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6Address`, `nextLr`, `nextVr`, `receive`, and `tunnel`.
     */
    tunnel?: string;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscard {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceive {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteOption {
    /**
     * Passive
     */
    passive?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassive;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassive {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitor {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Failure condition
     */
    failureCondition?: string;
    /**
     * Hold time
     */
    holdTime?: number;
    /**
     * Monitor destinations
     */
    monitorDestinations?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination[];
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestination {
    /**
     * Count
     */
    count?: number;
    /**
     * Destination
     */
    destination?: string;
    /**
     * Destination fqdn
     */
    destinationFqdn?: string;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Interval
     */
    interval?: number;
    /**
     * Name
     */
    name: string;
    /**
     * Source
     */
    source?: string;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTable {
    /**
     * Both
     */
    both?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBoth;
    /**
     * Multicast
     */
    multicast?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticast;
    /**
     * No install
     */
    noInstall?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstall;
    /**
     * Unicast
     */
    unicast?: outputs.LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicast;
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBoth {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticast {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstall {
}

export interface LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicast {
}

export interface LogicalRouterVrfVrAdminDists {
    /**
     * Ebgp
     */
    ebgp?: number;
    /**
     * Ibgp
     */
    ibgp?: number;
    /**
     * Ospf ext
     */
    ospfExt?: number;
    /**
     * Ospf int
     */
    ospfInt?: number;
    /**
     * Ospfv3 ext
     */
    ospfv3Ext?: number;
    /**
     * Ospfv3 int
     */
    ospfv3Int?: number;
    /**
     * Rip
     */
    rip?: number;
    /**
     * Static
     */
    static?: number;
    /**
     * Static ipv6
     */
    staticIpv6?: number;
}

export interface LoopbackInterfaceIp {
    /**
     * Loopback IP address(es)
     */
    name: string;
}

export interface LoopbackInterfaceIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses?: outputs.LoopbackInterfaceIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface LoopbackInterfaceIpv6Address {
    /**
     * Anycast
     */
    anycast?: outputs.LoopbackInterfaceIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name?: string;
    /**
     * Use interface ID as host portion
     */
    prefix?: outputs.LoopbackInterfaceIpv6AddressPrefix;
}

export interface LoopbackInterfaceIpv6AddressAnycast {
}

export interface LoopbackInterfaceIpv6AddressPrefix {
}

export interface ManagementInterfaceManagementInterface {
    /**
     * IP type
     */
    mgmtType?: outputs.ManagementInterfaceManagementInterfaceMgmtType;
    /**
     * MTU
     */
    mtu: number;
    /**
     * Permitting IP addresses
     */
    permittedIps?: outputs.ManagementInterfaceManagementInterfacePermittedIp[];
    /**
     * Network services
     */
    service?: outputs.ManagementInterfaceManagementInterfaceService;
    /**
     * Speed and duplex
     */
    speedDuplex: string;
}

export interface ManagementInterfaceManagementInterfaceMgmtType {
    /**
     * Dhcp client
     */
    dhcpClient?: outputs.ManagementInterfaceManagementInterfaceMgmtTypeDhcpClient;
    /**
     * Static
     *
     * > ℹ️ **Note:** You must specify exactly one of `dhcpClient` and `static`.
     */
    static?: outputs.ManagementInterfaceManagementInterfaceMgmtTypeStatic;
}

export interface ManagementInterfaceManagementInterfaceMgmtTypeDhcpClient {
    /**
     * Accept DHCP server provided domain name
     */
    acceptDhcpDomain: boolean;
    /**
     * Accept DHCP server provided hostname
     */
    acceptDhcpHostname: boolean;
    /**
     * Send client ID
     */
    sendClientId: boolean;
    /**
     * Send hostname
     */
    sendHostname: boolean;
}

export interface ManagementInterfaceManagementInterfaceMgmtTypeStatic {
    /**
     * Default gateway
     */
    defaultGateway: string;
    /**
     * IP address
     */
    ipAddress: string;
    /**
     * Netmask
     */
    netmask: string;
}

export interface ManagementInterfaceManagementInterfacePermittedIp {
    /**
     * Description
     */
    description?: string;
    /**
     * IP address
     */
    name?: string;
}

export interface ManagementInterfaceManagementInterfaceService {
    /**
     * HTTP
     */
    disableHttp: boolean;
    /**
     * HTTP OCSP
     */
    disableHttpOcsp: boolean;
    /**
     * HTTPS
     */
    disableHttps: boolean;
    /**
     * Ping
     */
    disableIcmp: boolean;
    /**
     * SNMP
     */
    disableSnmp: boolean;
    /**
     * SSH
     */
    disableSsh: boolean;
    /**
     * Telnet
     */
    disableTelnet: boolean;
    /**
     * User-ID
     */
    disableUseridService: boolean;
    /**
     * User-ID syslog listener over SSL
     */
    disableUseridSyslogListenerSsl: boolean;
    /**
     * User-ID syslog listener over UDP
     */
    disableUseridSyslogListenerUdp: boolean;
}

export interface MfaServerMfaVendorType {
    /**
     * Integration with [Duo Security](https://duo.com/product)
     */
    duoSecurityV2?: outputs.MfaServerMfaVendorTypeDuoSecurityV2;
    /**
     * Integration with [Okta Adaptive MFA](https://www.okta.com/products/adaptive-multi-factor-authentication)
     *
     * > ℹ️ **Note:** You must specify exactly one of `duoSecurityV2`, `oktaAdaptiveV1`, `pingIdentityV1`, and `rsaSecuridAccessV1`.
     */
    oktaAdaptiveV1?: outputs.MfaServerMfaVendorTypeOktaAdaptiveV1;
    /**
     * Integation with [Ping Identity](https://www.pingidentity.com/en/platform.html)
     *
     * > ℹ️ **Note:** You must specify exactly one of `duoSecurityV2`, `oktaAdaptiveV1`, `pingIdentityV1`, and `rsaSecuridAccessV1`.
     */
    pingIdentityV1?: outputs.MfaServerMfaVendorTypePingIdentityV1;
    /**
     * Integration with [RSA SecurID](https://www.rsa.com/products/securid/)
     *
     * > ℹ️ **Note:** You must specify exactly one of `duoSecurityV2`, `oktaAdaptiveV1`, `pingIdentityV1`, and `rsaSecuridAccessV1`.
     */
    rsaSecuridAccessV1?: outputs.MfaServerMfaVendorTypeRsaSecuridAccessV1;
}

export interface MfaServerMfaVendorTypeDuoSecurityV2 {
    /**
     * Duo Security API hostname
     */
    duoApiHost: string;
    /**
     * Duo Security API base URI
     */
    duoBaseuri: string;
    /**
     * Duo Security integration key
     */
    duoIntegrationKey: string;
    /**
     * Duo Security secret key
     */
    duoSecretKey: string;
    /**
     * Duo Security timeout (seconds)
     */
    duoTimeout: number;
}

export interface MfaServerMfaVendorTypeOktaAdaptiveV1 {
    /**
     * Okta API hostname
     */
    oktaApiHost: string;
    /**
     * Okta baseuri
     */
    oktaBaseuri: string;
    /**
     * Okta organization
     */
    oktaOrg: string;
    /**
     * Okta timeout (seconds)
     */
    oktaTimeout: number;
    /**
     * Okta API token
     */
    oktaToken: string;
}

export interface MfaServerMfaVendorTypePingIdentityV1 {
    /**
     * Ping Identity API hostname
     */
    pingApiHost: string;
    /**
     * Ping Identity API base URI
     */
    pingBaseuri: string;
    /**
     * Ping Identity client organization ID
     */
    pingOrgAlias?: string;
    /**
     * Ping Identity timeout (seconds)
     */
    pingTimeout: number;
    /**
     * Ping Identity API token
     */
    pingToken: string;
    /**
     * Ping Identity Base64 key
     */
    pingUseBase64Key: string;
}

export interface MfaServerMfaVendorTypeRsaSecuridAccessV1 {
    /**
     * RSA SecurID access ID
     */
    rsaAccessid?: string;
    /**
     * RSA SecurID access key
     */
    rsaAccesskey?: string;
    /**
     * RSA SecurID hostname
     */
    rsaApiHost?: string;
    /**
     * RSA SecurID assurance level
     */
    rsaAssurancepolicyid?: string;
    /**
     * RSA SecurID API base URI
     */
    rsaBaseuri: string;
    /**
     * RSA SecurID timeout (seconds)
     */
    rsaTimeout: number;
}

export interface MotdBannerSettingMotdAndBanner {
    /**
     * Banner footer
     */
    bannerFooter?: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterColor?: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerFooterTextColor?: string;
    /**
     * Banner header
     */
    bannerHeader?: string;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderColor?: string;
    /**
     * Banner header footer match
     */
    bannerHeaderFooterMatch?: boolean;
    /**
     * The following list details the supported values and their colors.
     */
    bannerHeaderTextColor?: string;
    /**
     * Message
     */
    message?: string;
    /**
     * The following list details the supported values and their colors.
     */
    motdColor?: string;
    /**
     * Motd do not display again
     */
    motdDoNotDisplayAgain?: boolean;
    /**
     * Motd enable
     */
    motdEnable?: boolean;
    /**
     * Motd title
     */
    motdTitle?: string;
    /**
     * Severity
     */
    severity?: string;
}

export interface NatRuleDestinationTranslation {
    /**
     * DNS rewrite
     */
    dnsRewrite?: outputs.NatRuleDestinationTranslationDnsRewrite;
    /**
     * Translated destination IP address
     */
    translatedAddress?: string;
    /**
     * Translated destination port
     */
    translatedPort?: number;
}

export interface NatRuleDestinationTranslationDnsRewrite {
    /**
     * Direction
     */
    direction?: string;
}

export interface NatRuleDynamicDestinationTranslation {
    /**
     * Distribution method
     */
    distribution?: string;
    /**
     * Translated destination IP address
     */
    translatedAddress?: string;
    /**
     * Translated destination port
     */
    translatedPort?: number;
}

export interface NatRuleSourceTranslation {
    /**
     * Dynamic IP
     */
    dynamicIp?: outputs.NatRuleSourceTranslationDynamicIp;
    /**
     * Dynamic IP and port
     */
    dynamicIpAndPort?: outputs.NatRuleSourceTranslationDynamicIpAndPort;
    /**
     * Static IP
     */
    staticIp?: outputs.NatRuleSourceTranslationStaticIp;
}

export interface NatRuleSourceTranslationDynamicIp {
    /**
     * Fallback
     */
    fallback?: outputs.NatRuleSourceTranslationDynamicIpFallback;
    /**
     * Translated IP addresses
     */
    translatedAddresses?: string[];
}

export interface NatRuleSourceTranslationDynamicIpAndPort {
    /**
     * Translated source interface
     */
    interfaceAddress?: outputs.NatRuleSourceTranslationDynamicIpAndPortInterfaceAddress;
    /**
     * Translated source IP addresses
     */
    translatedAddresses?: string[];
}

export interface NatRuleSourceTranslationDynamicIpAndPortInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp?: string;
    /**
     * Interface name
     */
    interface?: string;
    /**
     * Translated source IP address
     */
    ip?: string;
}

export interface NatRuleSourceTranslationDynamicIpFallback {
    /**
     * Fallback interface
     */
    interfaceAddress?: outputs.NatRuleSourceTranslationDynamicIpFallbackInterfaceAddress;
    /**
     * Fallback IP addresses
     */
    translatedAddresses?: string[];
}

export interface NatRuleSourceTranslationDynamicIpFallbackInterfaceAddress {
    /**
     * Floating IP address
     */
    floatingIp?: string;
    /**
     * Interface name
     */
    interface?: string;
    /**
     * IP address
     */
    ip?: string;
}

export interface NatRuleSourceTranslationStaticIp {
    /**
     * Bi directional
     */
    biDirectional?: string;
    /**
     * Translated IP address
     */
    translatedAddress?: string;
}

export interface OspfAuthProfileMd5 {
    /**
     * MD5 hash
     */
    key?: string;
    /**
     * Key ID
     */
    name?: number;
    /**
     * Preferred?
     */
    preferred?: boolean;
}

export interface PbfRuleAction {
    /**
     * Discard
     */
    discard?: outputs.PbfRuleActionDiscard;
    /**
     * Forward
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    forward?: outputs.PbfRuleActionForward;
    /**
     * No pbf
     *
     * > ℹ️ **Note:** You must specify exactly one of `discard`, `forward`, and `noPbf`.
     */
    noPbf?: outputs.PbfRuleActionNoPbf;
}

export interface PbfRuleActionDiscard {
}

export interface PbfRuleActionForward {
    /**
     * Egress interface
     */
    egressInterface?: string;
    /**
     * Monitor
     */
    monitor?: outputs.PbfRuleActionForwardMonitor;
    /**
     * Nexthop
     */
    nexthop?: outputs.PbfRuleActionForwardNexthop;
}

export interface PbfRuleActionForwardMonitor {
    /**
     * Disable this rule if nexthop/monitor ip is unreachable?
     */
    disableIfUnreachable?: boolean;
    /**
     * Monitor IP address
     */
    ipAddress?: string;
    /**
     * Monitoring profile
     */
    profile?: string;
}

export interface PbfRuleActionForwardNexthop {
    /**
     * Next hop FQDN
     */
    fqdn?: string;
    /**
     * Next hop IP address
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddress?: string;
}

export interface PbfRuleActionNoPbf {
}

export interface PbfRuleEnforceSymmetricReturn {
    /**
     * Enforce symmetric return?
     */
    enabled?: boolean;
    /**
     * Next hop IP addresses
     */
    nexthopAddressLists?: outputs.PbfRuleEnforceSymmetricReturnNexthopAddressList[];
}

export interface PbfRuleEnforceSymmetricReturnNexthopAddressList {
    /**
     * Next hop IP address
     */
    name?: string;
}

export interface PbfRuleFrom {
    /**
     * Source interfaces
     */
    interfaces?: string[];
    /**
     * Source zones
     *
     * > ℹ️ **Note:** You must specify exactly one of `interface` and `zone`.
     */
    zones?: string[];
}

export interface QosPolicyRuleAction {
    /**
     * Class
     */
    class?: string;
}

export interface QosPolicyRuleDscpTos {
    /**
     * Codepoints
     */
    codepoints?: outputs.QosPolicyRuleDscpTosCodepoint[];
}

export interface QosPolicyRuleDscpTosCodepoint {
    /**
     * Name
     */
    name?: string;
    /**
     * Type
     */
    type?: outputs.QosPolicyRuleDscpTosCodepointType;
}

export interface QosPolicyRuleDscpTosCodepointType {
    /**
     * Af
     */
    af?: outputs.QosPolicyRuleDscpTosCodepointTypeAf;
    /**
     * Cs
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    cs?: outputs.QosPolicyRuleDscpTosCodepointTypeCs;
    /**
     * Custom
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    custom?: outputs.QosPolicyRuleDscpTosCodepointTypeCustom;
    /**
     * Ef
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    ef?: outputs.QosPolicyRuleDscpTosCodepointTypeEf;
    /**
     * Tos
     *
     * > ℹ️ **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
     */
    tos?: outputs.QosPolicyRuleDscpTosCodepointTypeTos;
}

export interface QosPolicyRuleDscpTosCodepointTypeAf {
    /**
     * Codepoint
     */
    codepoint?: string;
}

export interface QosPolicyRuleDscpTosCodepointTypeCs {
    /**
     * Codepoint
     */
    codepoint?: string;
}

export interface QosPolicyRuleDscpTosCodepointTypeCustom {
    /**
     * Codepoint
     */
    codepoint?: outputs.QosPolicyRuleDscpTosCodepointTypeCustomCodepoint;
}

export interface QosPolicyRuleDscpTosCodepointTypeCustomCodepoint {
    /**
     * Binary value
     */
    binaryValue?: string;
    /**
     * Codepoint name
     */
    codepointName?: string;
}

export interface QosPolicyRuleDscpTosCodepointTypeEf {
}

export interface QosPolicyRuleDscpTosCodepointTypeTos {
    /**
     * Codepoint
     */
    codepoint?: string;
}

export interface QosProfileAggregateBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed?: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax?: number;
}

export interface QosProfileClassBandwidthType {
    /**
     * Mbps
     */
    mbps?: outputs.QosProfileClassBandwidthTypeMbps;
    /**
     * Percentage
     *
     * > ℹ️ **Note:** You must specify exactly one of `mbps` and `percentage`.
     */
    percentage?: outputs.QosProfileClassBandwidthTypePercentage;
}

export interface QosProfileClassBandwidthTypeMbps {
    /**
     * QoS setting for traffic classes
     */
    classes?: outputs.QosProfileClassBandwidthTypeMbpsClass[];
}

export interface QosProfileClassBandwidthTypeMbpsClass {
    /**
     * Class bandwidth
     */
    classBandwidth?: outputs.QosProfileClassBandwidthTypeMbpsClassClassBandwidth;
    /**
     * Traffic class
     */
    name?: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface QosProfileClassBandwidthTypeMbpsClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in mbps
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in mbps
     */
    egressMax: number;
}

export interface QosProfileClassBandwidthTypePercentage {
    /**
     * QoS setting for traffic classes
     */
    classes?: outputs.QosProfileClassBandwidthTypePercentageClass[];
}

export interface QosProfileClassBandwidthTypePercentageClass {
    /**
     * Class bandwidth
     */
    classBandwidth?: outputs.QosProfileClassBandwidthTypePercentageClassClassBandwidth;
    /**
     * Traffic class
     */
    name?: string;
    /**
     * traffic class priority
     */
    priority: string;
}

export interface QosProfileClassBandwidthTypePercentageClassClassBandwidth {
    /**
     * guaranteed sending bandwidth in percentage
     */
    egressGuaranteed: number;
    /**
     * max sending bandwidth in percentage
     */
    egressMax: number;
}

export interface RadiusServerProfileProtocol {
    /**
     * C h a p
     */
    chap?: outputs.RadiusServerProfileProtocolChap;
    /**
     * E a p t t l s with p a p
     */
    eapTtlsWithPap?: outputs.RadiusServerProfileProtocolEapTtlsWithPap;
    /**
     * P a p
     */
    pap?: outputs.RadiusServerProfileProtocolPap;
    /**
     * P e a p m s c h a pv2
     */
    peapMschaPv2?: outputs.RadiusServerProfileProtocolPeapMschaPv2;
    /**
     * P e a p with g t c
     */
    peapWithGtc?: outputs.RadiusServerProfileProtocolPeapWithGtc;
}

export interface RadiusServerProfileProtocolChap {
}

export interface RadiusServerProfileProtocolEapTtlsWithPap {
    /**
     * Anon outer id
     */
    anonOuterId?: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile?: string;
}

export interface RadiusServerProfileProtocolPap {
}

export interface RadiusServerProfileProtocolPeapMschaPv2 {
    /**
     * Allow pwd change
     */
    allowPwdChange?: boolean;
    /**
     * Anon outer id
     */
    anonOuterId?: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile?: string;
}

export interface RadiusServerProfileProtocolPeapWithGtc {
    /**
     * Anon outer id
     */
    anonOuterId?: boolean;
    /**
     * Radius cert profile
     */
    radiusCertProfile?: string;
}

export interface RadiusServerProfileServer {
    /**
     * The IP address of the RADIUS server
     */
    ipAddress?: string;
    /**
     * The name of the RADIUS server
     */
    name?: string;
    /**
     * The RADIUS server port
     */
    port?: number;
    /**
     * The RADIUS secret
     */
    secret?: string;
}

export interface RegionGeoLocation {
    /**
     * The latitudinal position of the region
     */
    latitude: number;
    /**
     * The longitudinal postition of the region
     */
    longitude: number;
}

export interface RemoteNetworkEcmpTunnel {
    /**
     * Ipsec tunnel
     */
    ipsecTunnel: string;
    /**
     * Name
     */
    name: string;
    /**
     * Protocol
     */
    protocol: outputs.RemoteNetworkEcmpTunnelProtocol;
}

export interface RemoteNetworkEcmpTunnelProtocol {
    /**
     * Bgp
     */
    bgp?: outputs.RemoteNetworkEcmpTunnelProtocolBgp;
}

export interface RemoteNetworkEcmpTunnelProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes?: boolean;
    /**
     * Enable BGP peering?
     */
    enable?: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress?: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute?: boolean;
    /**
     * BGP peer ASN
     */
    peerAs?: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress?: string;
    /**
     * Route exchange types
     */
    peeringType?: string;
    /**
     * BGP peering secret
     */
    secret?: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes?: boolean;
}

export interface RemoteNetworkProtocol {
    /**
     * Bgp
     */
    bgp?: outputs.RemoteNetworkProtocolBgp;
    /**
     * secondary bgp routing as bgp*peer
     */
    bgpPeer?: outputs.RemoteNetworkProtocolBgpPeer;
}

export interface RemoteNetworkProtocolBgp {
    /**
     * Do not export routes?
     */
    doNotExportRoutes?: boolean;
    /**
     * Enable BGP peering?
     */
    enable?: boolean;
    /**
     * Local peer IP address
     */
    localIpAddress?: string;
    /**
     * Originate default route?
     */
    originateDefaultRoute?: boolean;
    /**
     * BGP peer ASN
     */
    peerAs?: string;
    /**
     * Remote peer IP address
     */
    peerIpAddress?: string;
    /**
     * Route exchange types
     */
    peeringType?: string;
    /**
     * BGP peering secret
     */
    secret?: string;
    /**
     * Summarize mobile user routes?
     */
    summarizeMobileUserRoutes?: boolean;
}

export interface RemoteNetworkProtocolBgpPeer {
    /**
     * Local peer IP address (secondary WAN)
     */
    localIpAddress?: string;
    /**
     * Remote peer IP address (secondary WAN)
     */
    peerIpAddress?: string;
    /**
     * BGP peering secret (secondary WAN)
     */
    secret?: string;
}

export interface RouteAccessListType {
    /**
     * Ipv4
     */
    ipv4?: outputs.RouteAccessListTypeIpv4;
}

export interface RouteAccessListTypeIpv4 {
    /**
     * IPv4 access lists
     */
    ipv4Entries?: outputs.RouteAccessListTypeIpv4Ipv4Entry[];
}

export interface RouteAccessListTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action?: string;
    /**
     * Destination address
     */
    destinationAddress?: outputs.RouteAccessListTypeIpv4Ipv4EntryDestinationAddress;
    /**
     * Sequence number
     */
    name?: number;
    /**
     * Source address
     */
    sourceAddress?: outputs.RouteAccessListTypeIpv4Ipv4EntrySourceAddress;
}

export interface RouteAccessListTypeIpv4Ipv4EntryDestinationAddress {
    /**
     * Destination IP address
     */
    address?: string;
    /**
     * Entry
     */
    entry?: outputs.RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntry;
}

export interface RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntry {
    /**
     * Destination IP address
     */
    address?: string;
    /**
     * Destination IP wildcard
     */
    wildcard?: string;
}

export interface RouteAccessListTypeIpv4Ipv4EntrySourceAddress {
    /**
     * Source IP address
     */
    address?: string;
    /**
     * Entry
     */
    entry?: outputs.RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntry;
}

export interface RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntry {
    /**
     * Source IP address
     */
    address?: string;
    /**
     * Source IP wildcard
     */
    wildcard?: string;
}

export interface RouteCommunityListType {
    /**
     * Extended
     */
    extended?: outputs.RouteCommunityListTypeExtended;
    /**
     * Large
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    large?: outputs.RouteCommunityListTypeLarge;
    /**
     * Regular
     *
     * > ℹ️ **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
     */
    regular?: outputs.RouteCommunityListTypeRegular;
}

export interface RouteCommunityListTypeExtended {
    /**
     * Extended community lists
     */
    extendedEntries?: outputs.RouteCommunityListTypeExtendedExtendedEntry[];
}

export interface RouteCommunityListTypeExtendedExtendedEntry {
    /**
     * Action
     */
    action?: string;
    /**
     * Extended community regular expression
     */
    lcRegexes?: string[];
    /**
     * Sequence number
     */
    name?: number;
}

export interface RouteCommunityListTypeLarge {
    /**
     * Large community lists
     */
    largeEntries?: outputs.RouteCommunityListTypeLargeLargeEntry[];
}

export interface RouteCommunityListTypeLargeLargeEntry {
    /**
     * Action
     */
    action?: string;
    /**
     * Large community regular expression
     */
    lcRegexes?: string[];
    /**
     * Sequence number
     */
    name?: number;
}

export interface RouteCommunityListTypeRegular {
    /**
     * Regular community lists
     */
    regularEntries?: outputs.RouteCommunityListTypeRegularRegularEntry[];
}

export interface RouteCommunityListTypeRegularRegularEntry {
    /**
     * Action
     */
    action?: string;
    /**
     * Communities
     */
    communities?: string[];
    /**
     * Sequence number
     */
    name?: number;
}

export interface RoutePathAccessListAspathEntry {
    /**
     * Action
     */
    action?: string;
    /**
     * AS path regular expression
     */
    aspathRegex?: string;
    /**
     * Sequence number
     */
    name?: number;
}

export interface RoutePrefixListType {
    /**
     * Ipv4
     */
    ipv4: outputs.RoutePrefixListTypeIpv4;
}

export interface RoutePrefixListTypeIpv4 {
    /**
     * IPv4 prefix lists
     */
    ipv4Entries?: outputs.RoutePrefixListTypeIpv4Ipv4Entry[];
}

export interface RoutePrefixListTypeIpv4Ipv4Entry {
    /**
     * Action
     */
    action?: string;
    /**
     * Sequence number
     */
    name?: number;
    /**
     * Prefix
     */
    prefix?: outputs.RoutePrefixListTypeIpv4Ipv4EntryPrefix;
}

export interface RoutePrefixListTypeIpv4Ipv4EntryPrefix {
    /**
     * Entry
     */
    entry?: outputs.RoutePrefixListTypeIpv4Ipv4EntryPrefixEntry;
    /**
     * Network
     *
     * > ℹ️ **Note:** You must specify exactly one of `entry` and `network`.
     */
    network?: string;
}

export interface RoutePrefixListTypeIpv4Ipv4EntryPrefixEntry {
    /**
     * Greater than or equal to
     */
    greaterThanOrEqual?: number;
    /**
     * Less than or equal to
     */
    lessThanOrEqual?: number;
    /**
     * Network
     */
    network?: string;
}

export interface ScepProfileAlgorithm {
    /**
     * Key length (bits)
     */
    rsa: outputs.ScepProfileAlgorithmRsa;
}

export interface ScepProfileAlgorithmRsa {
    /**
     * Rsa nbits
     */
    rsaNbits: string;
}

export interface ScepProfileCertificateAttributes {
    /**
     * Dnsname
     */
    dnsname?: string;
    /**
     * Rfc822name
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    rfc822name?: string;
    /**
     * Uniform resource identifier
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniformResourceIdentifier`.
     */
    uniformResourceIdentifier?: string;
}

export interface ScepProfileScepChallenge {
    /**
     * Dynamic
     */
    dynamic?: outputs.ScepProfileScepChallengeDynamic;
    /**
     * Challenge to use for SCEP server on mobile clients
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    fixed?: string;
    /**
     * No OTP
     *
     * > ℹ️ **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
     */
    none?: outputs.ScepProfileScepChallengeNone;
}

export interface ScepProfileScepChallengeDynamic {
    /**
     * OTP server URL
     */
    otpServerUrl?: string;
    /**
     * OTP password
     */
    password?: string;
    /**
     * OTP username
     */
    username?: string;
}

export interface ScepProfileScepChallengeNone {
}

export interface ScheduleScheduleType {
    /**
     * Non recurring
     */
    nonRecurrings?: string[];
    /**
     * Recurring
     *
     * > ℹ️ **Note:** You must specify exactly one of `nonRecurring` and `recurring`.
     */
    recurring?: outputs.ScheduleScheduleTypeRecurring;
}

export interface ScheduleScheduleTypeRecurring {
    /**
     * Daily
     */
    dailies?: string[];
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily` and `weekly`.
     */
    weekly?: outputs.ScheduleScheduleTypeRecurringWeekly;
}

export interface ScheduleScheduleTypeRecurringWeekly {
    /**
     * Friday
     */
    fridays?: string[];
    /**
     * Monday
     */
    mondays?: string[];
    /**
     * Saturday
     */
    saturdays?: string[];
    /**
     * Sunday
     */
    sundays?: string[];
    /**
     * Thursday
     */
    thursdays?: string[];
    /**
     * Tuesday
     */
    tuesdays?: string[];
    /**
     * Wednesday
     */
    wednesdays?: string[];
}

export interface SdwanErrorCorrectionProfileMode {
    /**
     * Forward error correction
     */
    forwardErrorCorrection?: outputs.SdwanErrorCorrectionProfileModeForwardErrorCorrection;
    /**
     * Packet duplication
     *
     * > ℹ️ **Note:** You must specify exactly one of `forwardErrorCorrection` and `packetDuplication`.
     */
    packetDuplication?: outputs.SdwanErrorCorrectionProfileModePacketDuplication;
}

export interface SdwanErrorCorrectionProfileModeForwardErrorCorrection {
    /**
     * Ratio
     */
    ratio: string;
    /**
     * Recovery duration
     */
    recoveryDuration: number;
}

export interface SdwanErrorCorrectionProfileModePacketDuplication {
    /**
     * Recovery duration pd
     */
    recoveryDurationPd: number;
}

export interface SdwanPathQualityProfileMetric {
    /**
     * Jitter
     */
    jitter: outputs.SdwanPathQualityProfileMetricJitter;
    /**
     * Latency
     */
    latency: outputs.SdwanPathQualityProfileMetricLatency;
    /**
     * Pkt loss
     */
    pktLoss?: outputs.SdwanPathQualityProfileMetricPktLoss;
}

export interface SdwanPathQualityProfileMetricJitter {
    /**
     * Jitter sensitivity
     */
    sensitivity: string;
    /**
     * Jitter threshold (ms)
     */
    threshold: number;
}

export interface SdwanPathQualityProfileMetricLatency {
    /**
     * Latency sensitivity
     */
    sensitivity: string;
    /**
     * Latency threshold (ms)
     */
    threshold: number;
}

export interface SdwanPathQualityProfileMetricPktLoss {
    /**
     * Packet loss sensitivity
     */
    sensitivity: string;
    /**
     * Packet loss threshold (percentage)
     */
    threshold: number;
}

export interface SdwanRuleAction {
    /**
     * Traffic dstribution profile
     */
    trafficDistributionProfile: string;
}

export interface SdwanSaasQualityProfileMonitorMode {
    /**
     * Adaptive
     */
    adaptive?: outputs.SdwanSaasQualityProfileMonitorModeAdaptive;
    /**
     * Http https
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    httpHttps?: outputs.SdwanSaasQualityProfileMonitorModeHttpHttps;
    /**
     * Static ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `adaptive`, `httpHttps`, and `staticIp`.
     */
    staticIp?: outputs.SdwanSaasQualityProfileMonitorModeStaticIp;
}

export interface SdwanSaasQualityProfileMonitorModeAdaptive {
}

export interface SdwanSaasQualityProfileMonitorModeHttpHttps {
    /**
     * Monitored URL
     */
    monitoredUrl: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface SdwanSaasQualityProfileMonitorModeStaticIp {
    /**
     * Fqdn
     */
    fqdn?: outputs.SdwanSaasQualityProfileMonitorModeStaticIpFqdn;
    /**
     * List of IP addresses
     *
     * > ℹ️ **Note:** You must specify exactly one of `fqdn` and `ipAddress`.
     */
    ipAddresses?: outputs.SdwanSaasQualityProfileMonitorModeStaticIpIpAddress[];
}

export interface SdwanSaasQualityProfileMonitorModeStaticIpFqdn {
    /**
     * FQDN
     */
    fqdnName: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface SdwanSaasQualityProfileMonitorModeStaticIpIpAddress {
    /**
     * IP address
     */
    name: string;
    /**
     * Probe interval (seconds)
     */
    probeInterval: number;
}

export interface SdwanTrafficDistributionProfileLinkTag {
    /**
     * Link-Tag used for identifying a set of interfaces
     */
    name: string;
    /**
     * Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
     */
    weight?: number;
}

export interface SecurityRuleAllowUrlCategory {
    /**
     * Additional action
     */
    additionalAction: string;
    /**
     * Credential enforcement
     */
    credentialEnforcement: string;
    /**
     * Decryption
     */
    decryption: string;
    /**
     * Dlp
     */
    dlp?: string;
    /**
     * File control
     */
    fileControl?: outputs.SecurityRuleAllowUrlCategoryFileControl;
    /**
     * Isolation profiles
     */
    isolationProfiles: string;
    /**
     * Name
     */
    name?: string;
}

export interface SecurityRuleAllowUrlCategoryFileControl {
    /**
     * Download
     */
    download?: string;
    /**
     * Upload
     */
    upload?: string;
}

export interface SecurityRuleAllowWebApplication {
    /**
     * Application function
     */
    applicationFunctions?: string[];
    /**
     * Dlp
     */
    dlp?: string;
    /**
     * File control
     */
    fileControl?: outputs.SecurityRuleAllowWebApplicationFileControl;
    /**
     * Name
     */
    name?: string;
    /**
     * Saas enterprise control
     */
    saasEnterpriseControl?: outputs.SecurityRuleAllowWebApplicationSaasEnterpriseControl;
    /**
     * Saas tenant list
     */
    saasTenantLists?: string[];
    /**
     * Saas user list
     */
    saasUserLists?: string[];
    /**
     * Tenant control
     */
    tenantControl?: outputs.SecurityRuleAllowWebApplicationTenantControl;
    /**
     * Type
     */
    type?: string;
}

export interface SecurityRuleAllowWebApplicationFileControl {
    /**
     * Download
     */
    download?: string;
    /**
     * Upload
     */
    upload?: string;
}

export interface SecurityRuleAllowWebApplicationSaasEnterpriseControl {
    /**
     * Consumer access
     */
    consumerAccess?: outputs.SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccess;
    /**
     * Enterprise access
     */
    enterpriseAccess?: outputs.SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccess;
}

export interface SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccess {
    /**
     * Enable
     */
    enable?: string;
}

export interface SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccess {
    /**
     * Enable
     */
    enable?: string;
    /**
     * Tenant restrictions
     */
    tenantRestrictions?: string[];
}

export interface SecurityRuleAllowWebApplicationTenantControl {
    /**
     * Allowed activities
     */
    allowedActivities?: string[];
    /**
     * Blocked activities
     */
    blockedActivities?: string[];
    /**
     * Parent application
     */
    parentApplication?: string;
    /**
     * Tenants
     */
    tenants?: string[];
}

export interface SecurityRuleDefaultProfileSettings {
    /**
     * Dlp
     */
    dlp: string;
    /**
     * File control
     */
    fileControl: outputs.SecurityRuleDefaultProfileSettingsFileControl;
}

export interface SecurityRuleDefaultProfileSettingsFileControl {
    /**
     * Download
     */
    download: string;
    /**
     * Upload
     */
    upload: string;
}

export interface SecurityRuleLogSettings {
    /**
     * Log sessions
     */
    logSessions: boolean;
}

export interface SecurityRuleProfileSetting {
    /**
     * The security profile group
     */
    groups: string[];
}

export interface SecurityRuleSecuritySettings {
    /**
     * Anti spyware
     */
    antiSpyware: string;
    /**
     * Virus and wildfire analysis
     */
    virusAndWildfireAnalysis: string;
    /**
     * Vulnerability
     */
    vulnerability: string;
}

export interface ServiceConnectionBgpPeer {
    /**
     * Local ip address
     */
    localIpAddress?: string;
    /**
     * Local ipv6 address
     */
    localIpv6Address?: string;
    /**
     * Peer ip address
     */
    peerIpAddress?: string;
    /**
     * Peer ipv6 address
     */
    peerIpv6Address?: string;
    /**
     * Secret
     */
    secret?: string;
}

export interface ServiceConnectionProtocol {
    /**
     * Bgp
     */
    bgp?: outputs.ServiceConnectionProtocolBgp;
}

export interface ServiceConnectionProtocolBgp {
    /**
     * Do not export routes
     */
    doNotExportRoutes?: boolean;
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Fast failover
     */
    fastFailover?: boolean;
    /**
     * Local ip address
     */
    localIpAddress?: string;
    /**
     * Originate default route
     */
    originateDefaultRoute?: boolean;
    /**
     * Peer as
     */
    peerAs: string;
    /**
     * Peer ip address
     */
    peerIpAddress?: string;
    /**
     * Secret
     */
    secret?: string;
    /**
     * Summarize mobile user routes
     */
    summarizeMobileUserRoutes?: boolean;
}

export interface ServiceConnectionQos {
    /**
     * Enable
     */
    enable?: boolean;
    /**
     * Qos profile
     */
    qosProfile?: string;
}

export interface ServiceProtocol {
    /**
     * Tcp
     */
    tcp?: outputs.ServiceProtocolTcp;
    /**
     * Udp
     *
     * > ℹ️ **Note:** You must specify exactly one of `tcp` and `udp`.
     */
    udp?: outputs.ServiceProtocolUdp;
}

export interface ServiceProtocolTcp {
    /**
     * Override
     */
    override?: outputs.ServiceProtocolTcpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort?: string;
}

export interface ServiceProtocolTcpOverride {
    /**
     * tcp session half-close timeout value (in second)
     */
    halfcloseTimeout: number;
    /**
     * tcp session timeout value (in second)
     */
    timeout: number;
    /**
     * tcp session time-wait timeout value (in second)
     */
    timewaitTimeout: number;
}

export interface ServiceProtocolUdp {
    /**
     * Override
     */
    override?: outputs.ServiceProtocolUdpOverride;
    /**
     * Port
     */
    port: string;
    /**
     * Source port
     */
    sourcePort?: string;
}

export interface ServiceProtocolUdpOverride {
    /**
     * udp session timeout value (in second)
     */
    timeout: number;
}

export interface ServiceRouteRoute {
    /**
     * Destination
     */
    destinations?: outputs.ServiceRouteRouteDestination[];
    /**
     * Service
     */
    services?: outputs.ServiceRouteRouteService[];
}

export interface ServiceRouteRouteDestination {
    /**
     * Name
     */
    name?: string;
    /**
     * Source
     */
    source?: outputs.ServiceRouteRouteDestinationSource;
}

export interface ServiceRouteRouteDestinationSource {
    /**
     * Address
     */
    address?: string;
    /**
     * Interface
     */
    interface?: string;
}

export interface ServiceRouteRouteService {
    /**
     * The follow list details the accepted `name` values and their corresponding service description.
     */
    name?: string;
    /**
     * Source
     */
    source?: outputs.ServiceRouteRouteServiceSource;
    /**
     * Source v6
     */
    sourceV6?: outputs.ServiceRouteRouteServiceSourceV6;
}

export interface ServiceRouteRouteServiceSource {
    /**
     * Address
     */
    address?: string;
    /**
     * Interface
     */
    interface?: string;
}

export interface ServiceRouteRouteServiceSourceV6 {
    /**
     * Address
     */
    address?: string;
    /**
     * Interface
     */
    interface?: string;
}

export interface ServiceSettingServices {
    /**
     * Dns setting
     */
    dnsSetting?: outputs.ServiceSettingServicesDnsSetting;
    /**
     * Fqdn refresh time
     */
    fqdnRefreshTime: number;
    /**
     * Fqdn stale entry timeout
     */
    fqdnStaleEntryTimeout: number;
    /**
     * Inline cloud proxy
     */
    inlineCloudProxy: boolean;
    /**
     * Lcaas use proxy
     */
    lcaasUseProxy: boolean;
    /**
     * Ntp servers
     */
    ntpServers?: outputs.ServiceSettingServicesNtpServers;
    /**
     * Secure proxy password
     */
    secureProxyPassword?: string;
    /**
     * Secure proxy port
     */
    secureProxyPort?: number;
    /**
     * Secure proxy server
     */
    secureProxyServer?: string;
    /**
     * Secure proxy user
     */
    secureProxyUser?: string;
    /**
     * Server verification
     */
    serverVerification: boolean;
    /**
     * Update server
     */
    updateServer: string;
}

export interface ServiceSettingServicesDnsSetting {
    /**
     * Dns proxy object
     */
    dnsProxyObject?: string;
    /**
     * Servers
     *
     * > ℹ️ **Note:** You must specify exactly one of `dnsProxyObject` and `servers`.
     */
    servers?: outputs.ServiceSettingServicesDnsSettingServers;
}

export interface ServiceSettingServicesDnsSettingServers {
    /**
     * Primary
     */
    primary?: string;
    /**
     * Secondary
     */
    secondary?: string;
}

export interface ServiceSettingServicesNtpServers {
    /**
     * Primary ntp server
     */
    primaryNtpServer?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServer;
    /**
     * Secondary ntp server
     */
    secondaryNtpServer?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServer;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress?: string;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokey {
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNone {
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId?: number;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1?: outputs.ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey?: string;
}

export interface ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey?: string;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServer {
    /**
     * Authentication type
     */
    authenticationType?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationType;
    /**
     * Ntp server address
     */
    ntpServerAddress?: string;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationType {
    /**
     * Autokey
     */
    autokey?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    none?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNone;
    /**
     * Symmetric key
     *
     * > ℹ️ **Note:** You must specify exactly one of `autokey`, `none`, and `symmetricKey`.
     */
    symmetricKey?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokey {
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNone {
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKey {
    /**
     * Algorithm
     */
    algorithm?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm;
    /**
     * Key id
     */
    keyId?: number;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithm {
    /**
     * Md5
     */
    md5?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5;
    /**
     * Sha1
     */
    sha1?: outputs.ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5 {
    /**
     * Authentication key
     */
    authenticationKey?: string;
}

export interface ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1 {
    /**
     * Authentication key
     */
    authenticationKey?: string;
}

export interface SessionSettingSessionSettings {
    /**
     * Enable accelerated aging
     */
    acceleratedAgingEnable: boolean;
    /**
     * Accelerated aging scaling factor
     */
    acceleratedAgingScalingFactor: number;
    /**
     * Accelerated aging threshold
     */
    acceleratedAgingThreshold: number;
    /**
     * Config
     */
    config?: outputs.SessionSettingSessionSettingsConfig;
    /**
     * Enable DHCP broadcast session
     */
    dhcpBcastSessionOn: boolean;
    /**
     * Enable ERSPAN support
     */
    erspan: boolean;
    /**
     * ICMP unreachable packet rate (per second)
     */
    icmpUnreachableRate: number;
    /**
     * ICMPv6 rate limiting
     */
    icmpv6RateLimit?: outputs.SessionSettingSessionSettingsIcmpv6RateLimit;
    /**
     * Enable IPv6 firewalling
     */
    ipv6Firewalling: boolean;
    /**
     * Enable jumbo frame support
     */
    jumboFrame?: outputs.SessionSettingSessionSettingsJumboFrame;
    /**
     * Multicast route setup buffer size
     */
    maxPendingMcastPktsPerSession: number;
    /**
     * Multicast route setup buffering
     */
    multicastRouteSetupBuffering: boolean;
    /**
     * Nat
     */
    nat?: outputs.SessionSettingSessionSettingsNat;
    /**
     * Nat64
     */
    nat64?: outputs.SessionSettingSessionSettingsNat64;
    /**
     * Activate (%)
     */
    packetBufferProtectionActivate: number;
    /**
     * Alert (%)
     */
    packetBufferProtectionAlert: number;
    /**
     * Block countdown threshold (%)
     */
    packetBufferProtectionBlockCountdown: number;
    /**
     * Block duration (seconds)
     */
    packetBufferProtectionBlockDurationTime: number;
    /**
     * Block hold time (seconds)
     */
    packetBufferProtectionBlockHoldTime: number;
    /**
     * Enable packet buffer protection
     */
    packetBufferProtectionEnable: boolean;
    /**
     * Latency activate (milliseconds)
     */
    packetBufferProtectionLatencyActivate: number;
    /**
     * Latency alert (milliseconds)
     */
    packetBufferProtectionLatencyAlert: number;
    /**
     * Block countdown threshold (milliseconds)
     */
    packetBufferProtectionLatencyBlockCountdown: number;
    /**
     * Latency max tolerate (milliseconds)
     */
    packetBufferProtectionLatencyMaxTolerate: number;
    /**
     * Packet buffer protection monitor only
     */
    packetBufferProtectionMonitorOnly: boolean;
    /**
     * Enabled latency-based activation
     */
    packetBufferProtectionUseLatency: boolean;
}

export interface SessionSettingSessionSettingsConfig {
    /**
     * Rematch all sessions on config policy change
     */
    rematch: boolean;
}

export interface SessionSettingSessionSettingsIcmpv6RateLimit {
    /**
     * ICMPv6 token bucket size
     */
    bucketSize: number;
    /**
     * ICMPv6 error packet pate (per second)
     */
    packetRate: number;
}

export interface SessionSettingSessionSettingsJumboFrame {
    /**
     * Global MTU
     */
    mtu: number;
}

export interface SessionSettingSessionSettingsNat {
    /**
     * NAT oversubscription rate
     */
    dippOversub: string;
}

export interface SessionSettingSessionSettingsNat64 {
    /**
     * NAT64 IPv6 minimum network MTU
     */
    ipv6MinNetworkMtu: number;
}

export interface SessionTimeoutSessionTimeouts {
    /**
     * Captive Portal (seconds)
     */
    timeoutCaptivePortal: number;
    /**
     * Default timeout (seconds)
     */
    timeoutDefault: number;
    /**
     * Discard default (seconds)
     */
    timeoutDiscardDefault: number;
    /**
     * Discard TCP (seconds)
     */
    timeoutDiscardTcp: number;
    /**
     * Discard UDP (seconds)
     */
    timeoutDiscardUdp: number;
    /**
     * ICMP (seconds)
     */
    timeoutIcmp: number;
    /**
     * Scan (seconds)
     */
    timeoutScan: number;
    /**
     * TCP (seconds)
     */
    timeoutTcp: number;
    /**
     * TCP Half Closed (seconds)
     */
    timeoutTcpHalfClosed: number;
    /**
     * TCP Time Wait (seconds)
     */
    timeoutTcpTimeWait: number;
    /**
     * Unverified RST (seconds)
     */
    timeoutTcpUnverifiedRst: number;
    /**
     * TCP handshake (seconds)
     */
    timeoutTcphandshake: number;
    /**
     * TCP init (seconds)
     */
    timeoutTcpinit: number;
    /**
     * UDP (seconds)
     */
    timeoutUdp: number;
}

export interface SiteMember {
    /**
     * UUID of the remote network
     */
    id: string;
    /**
     * The mode of the remote network
     */
    mode: string;
    /**
     * The member name
     */
    name: string;
    /**
     * The remote network name
     */
    remoteNetwork?: string;
}

export interface SiteQos {
    /**
     * The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    backupCir?: number;
    /**
     * The CIR in Mbps. This is distributed equally for all tunnels in the site.
     */
    cir?: number;
    /**
     * The name of the site QoS profile
     */
    profile?: string;
}

export interface SyslogServerProfileFormat {
    /**
     * Auth
     */
    auth?: string;
    /**
     * Config
     */
    config?: string;
    /**
     * Correlation
     */
    correlation?: string;
    /**
     * Data
     */
    data?: string;
    /**
     * Decryption
     */
    decryption?: string;
    /**
     * Escaping
     */
    escaping?: outputs.SyslogServerProfileFormatEscaping;
    /**
     * Globalprotect
     */
    globalprotect?: string;
    /**
     * Gtp
     */
    gtp?: string;
    /**
     * Hip match
     */
    hipMatch?: string;
    /**
     * Iptag
     */
    iptag?: string;
    /**
     * Sctp
     */
    sctp?: string;
    /**
     * System
     */
    system?: string;
    /**
     * Threat
     */
    threat?: string;
    /**
     * Traffic
     */
    traffic?: string;
    /**
     * Tunnel
     */
    tunnel?: string;
    /**
     * Url
     */
    url?: string;
    /**
     * Userid
     */
    userid?: string;
    /**
     * Wildfire
     */
    wildfire?: string;
}

export interface SyslogServerProfileFormatEscaping {
    /**
     * Escape sequence delimiter
     */
    escapeCharacter?: string;
    /**
     * A list of all the characters to be escaped (without spaces).
     */
    escapedCharacters?: string;
}

export interface SyslogServerProfileServer {
    /**
     * Syslog facility
     */
    facility?: string;
    /**
     * Syslog format
     */
    format?: string;
    /**
     * Syslog server name
     */
    name?: string;
    /**
     * Syslog server port
     */
    port?: number;
    /**
     * Syslog server address
     */
    server?: string;
    /**
     * Transport protocol
     */
    transport?: string;
}

export interface TacacsServerProfileServer {
    /**
     * The IP address of the TACACS+ server
     */
    address?: string;
    /**
     * The name of the TACACS+ server
     */
    name?: string;
    /**
     * The TACACS+ server port
     */
    port?: number;
    /**
     * The TACACS+ secret
     */
    secret?: string;
}

export interface TcpSettingTcp {
    /**
     * Allow arbitrary ACK in response to SYN?
     */
    allowChallengeAck?: boolean;
    /**
     * Asymmetric path action
     */
    asymmetricPath?: string;
    /**
     * Forward segments exceeding TCP out-of-order queue?
     */
    bypassExceedOoQueue?: boolean;
    /**
     * Drop segments with null timestamp option?
     */
    checkTimestampOption?: boolean;
    /**
     * Drop segments without flag?
     */
    dropZeroFlag?: boolean;
    /**
     * SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
     */
    siptcpCleartextProxy?: string;
    /**
     * Strip MPTCP option?
     */
    stripMptcpOption?: boolean;
    /**
     * TCP retransmit scan?
     */
    tcpRetransmitScan?: boolean;
    /**
     * Urgent data flag action
     */
    urgentData?: string;
}

export interface TlsServiceProfileProtocolSettings {
    /**
     * Allow SHA1 authentication?
     */
    authAlgoSha1?: boolean;
    /**
     * Allow SHA256 authentication?
     */
    authAlgoSha256?: boolean;
    /**
     * Allow SHA384 authentication?
     */
    authAlgoSha384?: boolean;
    /**
     * Allow AES-128-CBC algorithm?
     */
    encAlgoAes128Cbc?: boolean;
    /**
     * Allow AES-128-GCM algorithm?
     */
    encAlgoAes128Gcm?: boolean;
    /**
     * Allow AES-256-CBC algorithm?
     */
    encAlgoAes256Cbc?: boolean;
    /**
     * Allow algorithm AES-256-GCM
     */
    encAlgoAes256Gcm?: boolean;
    /**
     * Allow DHE algorithm?
     */
    keyxchgAlgoDhe?: boolean;
    /**
     * Allow ECDHE algorithm?
     */
    keyxchgAlgoEcdhe?: boolean;
    /**
     * Allow RSA algorithm?
     */
    keyxchgAlgoRsa?: boolean;
    /**
     * Maximum TLS version
     */
    maxVersion?: string;
    /**
     * Minimum TLS version
     */
    minVersion?: string;
}

export interface TrafficSteeringRuleAction {
    /**
     * Forward
     */
    forward?: outputs.TrafficSteeringRuleActionForward;
}

export interface TrafficSteeringRuleActionForward {
    /**
     * Forward
     */
    forward?: outputs.TrafficSteeringRuleActionForwardForward;
    /**
     * No pbf
     */
    noPbf?: outputs.TrafficSteeringRuleActionForwardNoPbf;
}

export interface TrafficSteeringRuleActionForwardForward {
    /**
     * Target
     */
    target?: string;
}

export interface TrafficSteeringRuleActionForwardNoPbf {
}

export interface TunnelInterfaceIp {
    /**
     * Tunnel Interface IP address(es)
     */
    name: string;
}

export interface TunnelInterfaceIpv6 {
    /**
     * IPv6 Address Parent
     */
    addresses?: outputs.TunnelInterfaceIpv6Address[];
    /**
     * Enable IPv6
     */
    enabled: boolean;
    /**
     * Interface ID
     */
    interfaceId: string;
}

export interface TunnelInterfaceIpv6Address {
    /**
     * Anycast
     */
    anycast?: outputs.TunnelInterfaceIpv6AddressAnycast;
    /**
     * Enable Address on Interface
     */
    enableOnInterface: boolean;
    /**
     * IPv6 Address
     */
    name?: string;
    /**
     * Use interface ID as host portion
     */
    prefix?: outputs.TunnelInterfaceIpv6AddressPrefix;
}

export interface TunnelInterfaceIpv6AddressAnycast {
}

export interface TunnelInterfaceIpv6AddressPrefix {
}

export interface UpdateScheduleUpdateSchedule {
    /**
     * Anti virus
     */
    antiVirus: outputs.UpdateScheduleUpdateScheduleAntiVirus;
    /**
     * Threats
     */
    threats: outputs.UpdateScheduleUpdateScheduleThreats;
    /**
     * Wildfire
     */
    wildfire: outputs.UpdateScheduleUpdateScheduleWildfire;
}

export interface UpdateScheduleUpdateScheduleAntiVirus {
    /**
     * Recurring
     */
    recurring: outputs.UpdateScheduleUpdateScheduleAntiVirusRecurring;
}

export interface UpdateScheduleUpdateScheduleAntiVirusRecurring {
    /**
     * Daily
     */
    daily?: outputs.UpdateScheduleUpdateScheduleAntiVirusRecurringDaily;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    hourly?: outputs.UpdateScheduleUpdateScheduleAntiVirusRecurringHourly;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    none?: outputs.UpdateScheduleUpdateScheduleAntiVirusRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold?: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
     */
    weekly?: outputs.UpdateScheduleUpdateScheduleAntiVirusRecurringWeekly;
}

export interface UpdateScheduleUpdateScheduleAntiVirusRecurringDaily {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: string;
}

export interface UpdateScheduleUpdateScheduleAntiVirusRecurringHourly {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
}

export interface UpdateScheduleUpdateScheduleAntiVirusRecurringNone {
}

export interface UpdateScheduleUpdateScheduleAntiVirusRecurringWeekly {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at?: string;
    /**
     * Day of week
     */
    dayOfWeek?: string;
}

export interface UpdateScheduleUpdateScheduleThreats {
    /**
     * Recurring
     */
    recurring: outputs.UpdateScheduleUpdateScheduleThreatsRecurring;
}

export interface UpdateScheduleUpdateScheduleThreatsRecurring {
    /**
     * Daily
     */
    daily?: outputs.UpdateScheduleUpdateScheduleThreatsRecurringDaily;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    every30Mins?: outputs.UpdateScheduleUpdateScheduleThreatsRecurringEvery30Mins;
    /**
     * Hourly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    hourly?: outputs.UpdateScheduleUpdateScheduleThreatsRecurringHourly;
    /**
     * New app threshold
     */
    newAppThreshold?: number;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    none?: outputs.UpdateScheduleUpdateScheduleThreatsRecurringNone;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
    /**
     * Threshold
     */
    threshold?: number;
    /**
     * Weekly
     *
     * > ℹ️ **Note:** You must specify exactly one of `daily`, `every30Mins`, `hourly`, `none`, and `weekly`.
     */
    weekly?: outputs.UpdateScheduleUpdateScheduleThreatsRecurringWeekly;
}

export interface UpdateScheduleUpdateScheduleThreatsRecurringDaily {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface UpdateScheduleUpdateScheduleThreatsRecurringEvery30Mins {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface UpdateScheduleUpdateScheduleThreatsRecurringHourly {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface UpdateScheduleUpdateScheduleThreatsRecurringNone {
}

export interface UpdateScheduleUpdateScheduleThreatsRecurringWeekly {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: string;
    /**
     * Day of week
     */
    dayOfWeek: string;
    /**
     * Disable new content
     */
    disableNewContent: boolean;
}

export interface UpdateScheduleUpdateScheduleWildfire {
    /**
     * Recurring
     */
    recurring: outputs.UpdateScheduleUpdateScheduleWildfireRecurring;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurring {
    /**
     * Every15 mins
     */
    every15Mins?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringEvery15Mins;
    /**
     * Every30 mins
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    every30Mins?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringEvery30Mins;
    /**
     * Every hour
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyHour?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringEveryHour;
    /**
     * Every min
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    everyMin?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringEveryMin;
    /**
     * None
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    none?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringNone;
    /**
     * Real time
     *
     * > ℹ️ **Note:** You must specify exactly one of `every15Mins`, `every30Mins`, `everyHour`, `everyMin`, `none`, and `realTime`.
     */
    realTime?: outputs.UpdateScheduleUpdateScheduleWildfireRecurringRealTime;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringEvery15Mins {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringEvery30Mins {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringEveryHour {
    /**
     * Action
     */
    action?: string;
    /**
     * At
     */
    at: number;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringEveryMin {
    /**
     * Action
     */
    action?: string;
    /**
     * Sync to peer
     */
    syncToPeer: boolean;
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringNone {
}

export interface UpdateScheduleUpdateScheduleWildfireRecurringRealTime {
}

export interface UrlAccessProfileCredentialEnforcement {
    /**
     * Alert
     */
    alerts?: string[];
    /**
     * Allow
     */
    allows?: string[];
    /**
     * Block
     */
    blocks?: string[];
    /**
     * Continue
     */
    continues?: string[];
    /**
     * Log severity
     */
    logSeverity: string;
    /**
     * Mode
     */
    mode?: outputs.UrlAccessProfileCredentialEnforcementMode;
}

export interface UrlAccessProfileCredentialEnforcementMode {
    /**
     * Disabled
     */
    disabled?: outputs.UrlAccessProfileCredentialEnforcementModeDisabled;
    /**
     * Domain credentials
     */
    domainCredentials?: outputs.UrlAccessProfileCredentialEnforcementModeDomainCredentials;
    /**
     * Group mapping
     */
    groupMapping?: string;
    /**
     * Ip user
     */
    ipUser?: outputs.UrlAccessProfileCredentialEnforcementModeIpUser;
}

export interface UrlAccessProfileCredentialEnforcementModeDisabled {
}

export interface UrlAccessProfileCredentialEnforcementModeDomainCredentials {
}

export interface UrlAccessProfileCredentialEnforcementModeIpUser {
}

export interface VlanInterfaceArp {
    /**
     * MAC address
     */
    hwAddress?: string;
    /**
     * ARP interface
     */
    interface?: string;
    /**
     * IP address
     */
    name?: string;
}

export interface VlanInterfaceDdnsConfig {
    /**
     * Certificate profile
     */
    ddnsCertProfile: string;
    /**
     * Enable DDNS?
     */
    ddnsEnabled: boolean;
    /**
     * Ddns hostname
     */
    ddnsHostname: string;
    /**
     * IP to register (static only)
     */
    ddnsIp?: string;
    /**
     * Update interval (days)
     */
    ddnsUpdateInterval: number;
    /**
     * DDNS vendor
     */
    ddnsVendor: string;
    /**
     * DDNS vendor
     */
    ddnsVendorConfig: string;
}

export interface VlanInterfaceDhcpClient {
    /**
     * Automatically create default route pointing to default gateway provided by server
     */
    createDefaultRoute: boolean;
    /**
     * Metric of the default route created
     */
    defaultRouteMetric: number;
    /**
     * Enable DHCP?
     */
    enable: boolean;
    /**
     * Send hostname
     */
    sendHostname?: outputs.VlanInterfaceDhcpClientSendHostname;
}

export interface VlanInterfaceDhcpClientSendHostname {
    /**
     * Enable
     */
    enable: boolean;
    /**
     * Set interface hostname
     */
    hostname: string;
}

export interface VlanInterfaceIp {
    /**
     * VLAN Interface IP address(es)
     */
    name: string;
}

export interface VpnSettingVpn {
    /**
     * Ikev2
     */
    ikev2?: outputs.VpnSettingVpnIkev2;
}

export interface VpnSettingVpnIkev2 {
    /**
     * Maximum cached certificates
     */
    certificateCacheSize: number;
    /**
     * Cookie activation threshold
     */
    cookieThreshold: number;
    /**
     * Maximum half-opened SA
     */
    maxHalfOpenedSa: number;
}

export interface VulnerabilityProtectionProfileRule {
    /**
     * vulnerability profiles threat exception default action
     */
    action?: outputs.VulnerabilityProtectionProfileRuleAction;
    /**
     * Category
     */
    category?: string;
    /**
     * Cve
     */
    cves?: string[];
    /**
     * Host
     */
    host?: string;
    /**
     * Name
     */
    name?: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
    /**
     * Severity
     */
    severities?: string[];
    /**
     * Threat name
     */
    threatName?: string;
    /**
     * Vendor id
     */
    vendorIds?: string[];
}

export interface VulnerabilityProtectionProfileRuleAction {
    /**
     * Alert
     */
    alert?: outputs.VulnerabilityProtectionProfileRuleActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.VulnerabilityProtectionProfileRuleActionAllow;
    /**
     * vulnerability protection block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.VulnerabilityProtectionProfileRuleActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default?: outputs.VulnerabilityProtectionProfileRuleActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.VulnerabilityProtectionProfileRuleActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.VulnerabilityProtectionProfileRuleActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.VulnerabilityProtectionProfileRuleActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.VulnerabilityProtectionProfileRuleActionResetServer;
}

export interface VulnerabilityProtectionProfileRuleActionAlert {
}

export interface VulnerabilityProtectionProfileRuleActionAllow {
}

export interface VulnerabilityProtectionProfileRuleActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface VulnerabilityProtectionProfileRuleActionDefault {
}

export interface VulnerabilityProtectionProfileRuleActionDrop {
}

export interface VulnerabilityProtectionProfileRuleActionResetBoth {
}

export interface VulnerabilityProtectionProfileRuleActionResetClient {
}

export interface VulnerabilityProtectionProfileRuleActionResetServer {
}

export interface VulnerabilityProtectionProfileThreatException {
    /**
     * vulnerability threat exception default action
     */
    action?: outputs.VulnerabilityProtectionProfileThreatExceptionAction;
    /**
     * Exempt ip
     */
    exemptIps?: outputs.VulnerabilityProtectionProfileThreatExceptionExemptIp[];
    /**
     * Name
     */
    name?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Packet capture
     */
    packetCapture?: string;
    /**
     * vulnerability time attribute
     */
    timeAttribute?: outputs.VulnerabilityProtectionProfileThreatExceptionTimeAttribute;
}

export interface VulnerabilityProtectionProfileThreatExceptionAction {
    /**
     * Alert
     */
    alert?: outputs.VulnerabilityProtectionProfileThreatExceptionActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.VulnerabilityProtectionProfileThreatExceptionActionAllow;
    /**
     * vulnerability protection threat exception block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.VulnerabilityProtectionProfileThreatExceptionActionBlockIp;
    /**
     * Default
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    default?: outputs.VulnerabilityProtectionProfileThreatExceptionActionDefault;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.VulnerabilityProtectionProfileThreatExceptionActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.VulnerabilityProtectionProfileThreatExceptionActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.VulnerabilityProtectionProfileThreatExceptionActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `default`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.VulnerabilityProtectionProfileThreatExceptionActionResetServer;
}

export interface VulnerabilityProtectionProfileThreatExceptionActionAlert {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionAllow {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface VulnerabilityProtectionProfileThreatExceptionActionDefault {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionDrop {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionResetBoth {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionResetClient {
}

export interface VulnerabilityProtectionProfileThreatExceptionActionResetServer {
}

export interface VulnerabilityProtectionProfileThreatExceptionExemptIp {
    /**
     * Name
     */
    name: string;
}

export interface VulnerabilityProtectionProfileThreatExceptionTimeAttribute {
    /**
     * Interval
     */
    interval?: number;
    /**
     * Threshold
     */
    threshold?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface VulnerabilityProtectionSignatureAffectedHost {
    /**
     * Client
     */
    client?: boolean;
    /**
     * Server
     *
     * > ℹ️ **Note:** You must specify exactly one of `client` and `server`.
     */
    server?: boolean;
}

export interface VulnerabilityProtectionSignatureDefaultAction {
    /**
     * Alert
     */
    alert?: outputs.VulnerabilityProtectionSignatureDefaultActionAlert;
    /**
     * Allow
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    allow?: outputs.VulnerabilityProtectionSignatureDefaultActionAllow;
    /**
     * vulnerability protection bugtraq block ip
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    blockIp?: outputs.VulnerabilityProtectionSignatureDefaultActionBlockIp;
    /**
     * Drop
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    drop?: outputs.VulnerabilityProtectionSignatureDefaultActionDrop;
    /**
     * Reset both
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetBoth?: outputs.VulnerabilityProtectionSignatureDefaultActionResetBoth;
    /**
     * Reset client
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetClient?: outputs.VulnerabilityProtectionSignatureDefaultActionResetClient;
    /**
     * Reset server
     *
     * > ℹ️ **Note:** You must specify exactly one of `alert`, `allow`, `blockIp`, `drop`, `resetBoth`, `resetClient`, and `resetServer`.
     */
    resetServer?: outputs.VulnerabilityProtectionSignatureDefaultActionResetServer;
}

export interface VulnerabilityProtectionSignatureDefaultActionAlert {
}

export interface VulnerabilityProtectionSignatureDefaultActionAllow {
}

export interface VulnerabilityProtectionSignatureDefaultActionBlockIp {
    /**
     * Duration
     */
    duration?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface VulnerabilityProtectionSignatureDefaultActionDrop {
}

export interface VulnerabilityProtectionSignatureDefaultActionResetBoth {
}

export interface VulnerabilityProtectionSignatureDefaultActionResetClient {
}

export interface VulnerabilityProtectionSignatureDefaultActionResetServer {
}

export interface VulnerabilityProtectionSignatureSignature {
    /**
     * vulnerability protection signature combination object
     */
    combination?: outputs.VulnerabilityProtectionSignatureSignatureCombination;
    /**
     * vulnerability protection signature standard array
     *
     * > ℹ️ **Note:** You must specify exactly one of `combination` and `standard`.
     */
    standards?: outputs.VulnerabilityProtectionSignatureSignatureStandard[];
}

export interface VulnerabilityProtectionSignatureSignatureCombination {
    /**
     * vulnerability protection signature combination object and condition
     */
    andConditions?: outputs.VulnerabilityProtectionSignatureSignatureCombinationAndCondition[];
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Time attribute
     */
    timeAttribute?: outputs.VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute;
}

export interface VulnerabilityProtectionSignatureSignatureCombinationAndCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * vulnerability protection signature combination object and condition object or condition
     */
    orConditions?: outputs.VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition[];
}

export interface VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * Threat id
     */
    threatId?: string;
}

export interface VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute {
    /**
     * Interval
     */
    interval?: number;
    /**
     * Threshold
     */
    threshold?: number;
    /**
     * Track by
     */
    trackBy?: string;
}

export interface VulnerabilityProtectionSignatureSignatureStandard {
    /**
     * vulnerability protection signature standard object and condition
     */
    andConditions?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndCondition[];
    /**
     * Comment
     */
    comment?: string;
    /**
     * Name
     */
    name: string;
    /**
     * Order free
     */
    orderFree: boolean;
    /**
     * Scope
     */
    scope?: string;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * vulnerability protection signature standard object and condition object or condition
     */
    orConditions?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition[];
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition {
    /**
     * Name
     */
    name?: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators
     */
    operator?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator {
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to
     */
    equalTo?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than
     */
    greaterThan?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than
     */
    lessThan?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match
     */
    patternMatch?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo {
    /**
     * Context
     */
    context?: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
     */
    qualifiers?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan {
    /**
     * Context
     */
    context?: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
     */
    qualifiers?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan {
    /**
     * Context
     */
    context?: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators less*than array
     */
    qualifiers?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[];
    /**
     * Value
     */
    value?: number;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch {
    /**
     * Context
     */
    context?: string;
    /**
     * Negate
     */
    negate: boolean;
    /**
     * Pattern
     */
    pattern?: string;
    /**
     * vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
     */
    qualifiers?: outputs.VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[];
}

export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
    /**
     * Name
     */
    name?: string;
    /**
     * Value
     */
    value?: string;
}

export interface WildfireAntiVirusProfileMlavException {
    /**
     * Description
     */
    description?: string;
    /**
     * Filename
     */
    filename?: string;
    /**
     * Name
     */
    name?: string;
}

export interface WildfireAntiVirusProfileRule {
    /**
     * Analysis
     */
    analysis?: string;
    /**
     * Application
     */
    applications?: string[];
    /**
     * Direction
     */
    direction?: string;
    /**
     * File type
     */
    fileTypes?: string[];
    /**
     * Name
     */
    name?: string;
}

export interface WildfireAntiVirusProfileThreatException {
    /**
     * Name
     */
    name?: string;
    /**
     * Notes
     */
    notes?: string;
}

export interface ZoneDeviceAcl {
    /**
     * Exclude list
     */
    excludeLists?: string[];
    /**
     * Include list
     */
    includeLists?: string[];
}

export interface ZoneNetwork {
    /**
     * Enable packet buffer protection
     */
    enablePacketBufferProtection?: boolean;
    /**
     * External
     */
    externals?: string[];
    /**
     * Layer2
     */
    layer2s?: string[];
    /**
     * Layer3
     */
    layer3s?: string[];
    /**
     * Log setting
     */
    logSetting?: string;
    /**
     * Tap
     */
    taps?: string[];
    /**
     * Tunnel
     */
    tunnel?: outputs.ZoneNetworkTunnel;
    /**
     * Virtual wire
     */
    virtualWires?: string[];
    /**
     * Zone protection profile
     */
    zoneProtectionProfile?: string;
}

export interface ZoneNetworkTunnel {
}

export interface ZoneProtectionProfileFlood {
    /**
     * Icmp
     */
    icmp?: outputs.ZoneProtectionProfileFloodIcmp;
    /**
     * Icmpv6
     */
    icmpv6?: outputs.ZoneProtectionProfileFloodIcmpv6;
    /**
     * Other ip
     */
    otherIp?: outputs.ZoneProtectionProfileFloodOtherIp;
    /**
     * Sctp init
     */
    sctpInit?: outputs.ZoneProtectionProfileFloodSctpInit;
    /**
     * Tcp syn
     */
    tcpSyn?: outputs.ZoneProtectionProfileFloodTcpSyn;
    /**
     * Udp
     */
    udp?: outputs.ZoneProtectionProfileFloodUdp;
}

export interface ZoneProtectionProfileFloodIcmp {
    /**
     * Enable protection against ICMP floods?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodIcmpRed;
}

export interface ZoneProtectionProfileFloodIcmpRed {
    /**
     * The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodIcmpv6 {
    /**
     * Enable protection against ICMPv6 floods?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodIcmpv6Red;
}

export interface ZoneProtectionProfileFloodIcmpv6Red {
    /**
     * The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
     */
    activateRate: number;
    /**
     * The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodOtherIp {
    /**
     * Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodOtherIpRed;
}

export interface ZoneProtectionProfileFloodOtherIpRed {
    /**
     * Activate rate
     */
    activateRate: number;
    /**
     * Alarm rate
     */
    alarmRate: number;
    /**
     * Maximal rate
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodSctpInit {
    /**
     * Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodSctpInitRed;
}

export interface ZoneProtectionProfileFloodSctpInitRed {
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
     */
    activateRate: number;
    /**
     * The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodTcpSyn {
    /**
     * Enable protection against SYN floods?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodTcpSynRed;
    /**
     * Syn cookies
     */
    synCookies?: outputs.ZoneProtectionProfileFloodTcpSynSynCookies;
}

export interface ZoneProtectionProfileFloodTcpSynRed {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodTcpSynSynCookies {
    /**
     * When the flow exceeds the `activateRate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
     */
    activateRate: number;
    /**
     * When the flow exceeds the `alertRate`` threshold, an alarm is generated.
     */
    alarmRate: number;
    /**
     * When the flow exceeds the `maximalRate` threshold, 100% of incoming SYN packets are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileFloodUdp {
    /**
     * Enable protection against UDP floods?
     */
    enable?: boolean;
    /**
     * Red
     */
    red?: outputs.ZoneProtectionProfileFloodUdpRed;
}

export interface ZoneProtectionProfileFloodUdpRed {
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
     */
    activateRate: number;
    /**
     * The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
     */
    alarmRate: number;
    /**
     * The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
     */
    maximalRate: number;
}

export interface ZoneProtectionProfileIpv6 {
    /**
     * Discard IPv6 packets that contain an anycast source address.
     */
    anycastSource?: boolean;
    /**
     * Filter ext hdr
     */
    filterExtHdr?: outputs.ZoneProtectionProfileIpv6FilterExtHdr;
    /**
     * Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
     */
    icmpv6TooBigSmallMtuDiscard?: boolean;
    /**
     * Ignore inv pkt
     */
    ignoreInvPkt?: outputs.ZoneProtectionProfileIpv6IgnoreInvPkt;
    /**
     * Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
     */
    ipv4CompatibleAddress?: boolean;
    /**
     * Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
     */
    needlessFragmentHdr?: boolean;
    /**
     * Discard IPv6 packets that contain invalid IPv6 options in an extension header.
     */
    optionsInvalidIpv6Discard?: boolean;
    /**
     * Discard IPv6 packets that have a header with a reserved field not set to zero.
     */
    reservedFieldSetDiscard?: boolean;
    /**
     * Drop packets with type 0 routing header.
     */
    routingHeader0?: boolean;
    /**
     * Drop packets with type 1 routing header.
     */
    routingHeader1?: boolean;
    /**
     * Drop packets with type 253 routing header.
     */
    routingHeader253?: boolean;
    /**
     * Drop packets with type 254 routing header.
     */
    routingHeader254?: boolean;
    /**
     * Drop packets with type 255 routing header.
     */
    routingHeader255?: boolean;
    /**
     * Drop packets with type 3 routing header.
     */
    routingHeader3?: boolean;
    /**
     * Drop packets with type 4 to type 252 routing header.
     */
    routingHeader4252?: boolean;
}

export interface ZoneProtectionProfileIpv6FilterExtHdr {
    /**
     * Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
     */
    destOptionHdr?: boolean;
    /**
     * Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
     */
    hopByHopHdr?: boolean;
    /**
     * Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
     */
    routingHdr?: boolean;
}

export interface ZoneProtectionProfileIpv6IgnoreInvPkt {
    /**
     * Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
     */
    destUnreach?: boolean;
    /**
     * Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
     */
    paramProblem?: boolean;
    /**
     * Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
     */
    pktTooBig?: boolean;
    /**
     * Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
     */
    redirect?: boolean;
    /**
     * Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
     */
    timeExceeded?: boolean;
}

export interface ZoneProtectionProfileL2SecGroupTagProtection {
    /**
     * Tags
     */
    tags?: outputs.ZoneProtectionProfileL2SecGroupTagProtectionTag[];
}

export interface ZoneProtectionProfileL2SecGroupTagProtectionTag {
    /**
     * Enable this exclude list for Ethernet SGT protection.
     */
    enable?: boolean;
    /**
     * Name for the list of Security Group Tags (SGTs).
     */
    name: string;
    /**
     * The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
     */
    tag: string;
}

export interface ZoneProtectionProfileNonIpProtocol {
    /**
     * Specify the type of list you are creating for protocol protection:
     * * Include List—Only the protocols on the list are allowed—in addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
     * * Exclude List—Only the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
     */
    listType?: string;
    /**
     * Protocol
     */
    protocols?: outputs.ZoneProtectionProfileNonIpProtocolProtocol[];
}

export interface ZoneProtectionProfileNonIpProtocolProtocol {
    /**
     * Enable the Ethertype code on the list.
     */
    enable?: boolean;
    /**
     * Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
     * * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
     * * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
     * * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
     */
    etherType: string;
    /**
     * Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
     */
    name: string;
}

export interface ZoneProtectionProfileScan {
    /**
     * Action
     */
    action?: outputs.ZoneProtectionProfileScanAction;
    /**
     * Interval
     */
    interval?: number;
    /**
     * The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
     * * "8001" - TCP Port Scan
     * * "8002" - Host Sweep
     * * "8003" - UDP Port Scan
     * * "8006" - Port Scan
     */
    name: string;
    /**
     * Threshold
     */
    threshold?: number;
}

export interface ZoneProtectionProfileScanAction {
    /**
     * Alert
     */
    alert?: outputs.ZoneProtectionProfileScanActionAlert;
    /**
     * Allow
     */
    allow?: outputs.ZoneProtectionProfileScanActionAllow;
    /**
     * Block
     */
    block?: outputs.ZoneProtectionProfileScanActionBlock;
    /**
     * Block ip
     */
    blockIp?: outputs.ZoneProtectionProfileScanActionBlockIp;
}

export interface ZoneProtectionProfileScanActionAlert {
}

export interface ZoneProtectionProfileScanActionAllow {
}

export interface ZoneProtectionProfileScanActionBlock {
}

export interface ZoneProtectionProfileScanActionBlockIp {
    /**
     * Duration
     */
    duration: number;
    /**
     * Track by
     */
    trackBy: string;
}

export interface ZoneProtectionProfileScanWhiteList {
    /**
     * Ipv4
     */
    ipv4?: string;
    /**
     * Ipv6
     */
    ipv6?: string;
    /**
     * A descriptive name for the address to exclude.
     */
    name: string;
}

export interface ZoneUserAcl {
    /**
     * Exclude list
     */
    excludeLists?: string[];
    /**
     * Include list
     */
    includeLists?: string[];
}

