// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package scm

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-scm/sdk/go/scm/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// RemoteNetwork resource
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-scm/sdk/go/scm"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// --- DEPENDENCY 1: IKE Crypto Profile ---
//			// This profile defines the encryption and authentication algorithms for the IKE Gateway.
//			// The values are taken from the 'createTestIKECryptoProfile' helper function.
//			example, err := scm.NewIkeCryptoProfile(ctx, "example", &scm.IkeCryptoProfileArgs{
//				Name:   pulumi.String("example-ike-crypto-prf-for-rn"),
//				Folder: pulumi.String("Remote Networks"),
//				Hashes: pulumi.StringArray{
//					pulumi.String("sha256"),
//				},
//				DhGroups: pulumi.StringArray{
//					pulumi.String("group14"),
//				},
//				Encryptions: pulumi.StringArray{
//					pulumi.String("aes-256-cbc"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// --- DEPENDENCY 2: IKE Gateway ---
//			// This defines the VPN peer. It depends on the IKE Crypto Profile created above.
//			// The values are taken from the 'createTestIKEGateway' helper function.
//			exampleIkeGateway, err := scm.NewIkeGateway(ctx, "example", &scm.IkeGatewayArgs{
//				Name:   pulumi.String("example-ike-gateway-for-rn"),
//				Folder: pulumi.String("Remote Networks"),
//				Authentication: &scm.IkeGatewayAuthenticationArgs{
//					PreSharedKey: &scm.IkeGatewayAuthenticationPreSharedKeyArgs{
//						Key: pulumi.String("secret"),
//					},
//				},
//				PeerAddress: &scm.IkeGatewayPeerAddressArgs{
//					Ip: pulumi.String("1.1.1.1"),
//				},
//				Protocol: &scm.IkeGatewayProtocolArgs{
//					Ikev1: &scm.IkeGatewayProtocolIkev1Args{
//						IkeCryptoProfile: example.Name,
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				example,
//			}))
//			if err != nil {
//				return err
//			}
//			// --- DEPENDENCY 3: IPsec Tunnel ---
//			// This defines the tunnel interface itself and uses the IKE Gateway.
//			// The values are taken from the 'createTestIPsecTunnel' helper function.
//			exampleIpsecTunnel, err := scm.NewIpsecTunnel(ctx, "example", &scm.IpsecTunnelArgs{
//				Name:                   pulumi.String("example-ipsec-tunnel-for-rn"),
//				Folder:                 pulumi.String("Remote Networks"),
//				AntiReplay:             pulumi.Bool(true),
//				CopyTos:                pulumi.Bool(false),
//				EnableGreEncapsulation: pulumi.Bool(false),
//				AutoKey: &scm.IpsecTunnelAutoKeyArgs{
//					IkeGateways: scm.IpsecTunnelAutoKeyIkeGatewayArray{
//						&scm.IpsecTunnelAutoKeyIkeGatewayArgs{
//							Name: exampleIkeGateway.Name,
//						},
//					},
//					IpsecCryptoProfile: pulumi.String("PaloAlto-Networks-IPSec-Crypto"),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				exampleIkeGateway,
//			}))
//			if err != nil {
//				return err
//			}
//			// --- MAIN RESOURCE: Remote Network ---
//			// This is the final resource, which uses the IPsec Tunnel created above.
//			// The values are taken directly from the 'Test_deployment_services_RemoteNetworksAPIService_Create' test.
//			_, err = scm.NewRemoteNetwork(ctx, "example", &scm.RemoteNetworkArgs{
//				Name:        pulumi.String("example-remote-network"),
//				Folder:      pulumi.String("Remote Networks"),
//				LicenseType: pulumi.String("FWAAS-AGGREGATE"),
//				Region:      pulumi.String("us-west-2"),
//				SpnName:     pulumi.String("us-west-dakota"),
//				Subnets: pulumi.StringArray{
//					pulumi.String("192.168.1.0/24"),
//				},
//				IpsecTunnel: exampleIpsecTunnel.Name,
//				Protocol: &scm.RemoteNetworkProtocolArgs{
//					Bgp: &scm.RemoteNetworkProtocolBgpArgs{
//						Enable:                    pulumi.Bool(true),
//						PeerAs:                    pulumi.String("65000"),
//						LocalIpAddress:            pulumi.String("169.254.1.1"),
//						PeerIpAddress:             pulumi.String("169.254.1.2"),
//						DoNotExportRoutes:         pulumi.Bool(false),
//						OriginateDefaultRoute:     pulumi.Bool(false),
//						SummarizeMobileUserRoutes: pulumi.Bool(false),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				exampleIpsecTunnel,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type RemoteNetwork struct {
	pulumi.CustomResourceState

	// Ecmp load balancing
	EcmpLoadBalancing pulumi.StringOutput `pulumi:"ecmpLoadBalancing"`
	// ecmp*tunnels is required when ecmp*load*balancing is enable
	EcmpTunnels RemoteNetworkEcmpTunnelArrayOutput `pulumi:"ecmpTunnels"`
	// Map of sensitive values returned from the API.
	EncryptedValues pulumi.StringMapOutput `pulumi:"encryptedValues"`
	// The folder that contains the remote network
	Folder pulumi.StringOutput `pulumi:"folder"`
	// ipsec*tunnel is required when ecmp*load_balancing is disable
	IpsecTunnel pulumi.StringPtrOutput `pulumi:"ipsecTunnel"`
	// New customer will only be on aggregate bandwidth licensing
	LicenseType pulumi.StringOutput `pulumi:"licenseType"`
	// The name of the remote network
	Name pulumi.StringOutput `pulumi:"name"`
	// setup the protocol when ecmp*load*balancing is disable
	Protocol RemoteNetworkProtocolPtrOutput `pulumi:"protocol"`
	// Region
	Region pulumi.StringOutput `pulumi:"region"`
	// specify secondary ipsecTunnel if needed
	SecondaryIpsecTunnel pulumi.StringPtrOutput `pulumi:"secondaryIpsecTunnel"`
	// spn-name is needed when licenseType is FWAAS-AGGREGATE
	SpnName pulumi.StringPtrOutput `pulumi:"spnName"`
	// Subnets
	Subnets pulumi.StringArrayOutput `pulumi:"subnets"`
	Tfid    pulumi.StringOutput      `pulumi:"tfid"`
}

// NewRemoteNetwork registers a new resource with the given unique name, arguments, and options.
func NewRemoteNetwork(ctx *pulumi.Context,
	name string, args *RemoteNetworkArgs, opts ...pulumi.ResourceOption) (*RemoteNetwork, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Folder == nil {
		return nil, errors.New("invalid value for required argument 'Folder'")
	}
	if args.LicenseType == nil {
		return nil, errors.New("invalid value for required argument 'LicenseType'")
	}
	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"encryptedValues",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RemoteNetwork
	err := ctx.RegisterResource("scm:index/remoteNetwork:RemoteNetwork", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRemoteNetwork gets an existing RemoteNetwork resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRemoteNetwork(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RemoteNetworkState, opts ...pulumi.ResourceOption) (*RemoteNetwork, error) {
	var resource RemoteNetwork
	err := ctx.ReadResource("scm:index/remoteNetwork:RemoteNetwork", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RemoteNetwork resources.
type remoteNetworkState struct {
	// Ecmp load balancing
	EcmpLoadBalancing *string `pulumi:"ecmpLoadBalancing"`
	// ecmp*tunnels is required when ecmp*load*balancing is enable
	EcmpTunnels []RemoteNetworkEcmpTunnel `pulumi:"ecmpTunnels"`
	// Map of sensitive values returned from the API.
	EncryptedValues map[string]string `pulumi:"encryptedValues"`
	// The folder that contains the remote network
	Folder *string `pulumi:"folder"`
	// ipsec*tunnel is required when ecmp*load_balancing is disable
	IpsecTunnel *string `pulumi:"ipsecTunnel"`
	// New customer will only be on aggregate bandwidth licensing
	LicenseType *string `pulumi:"licenseType"`
	// The name of the remote network
	Name *string `pulumi:"name"`
	// setup the protocol when ecmp*load*balancing is disable
	Protocol *RemoteNetworkProtocol `pulumi:"protocol"`
	// Region
	Region *string `pulumi:"region"`
	// specify secondary ipsecTunnel if needed
	SecondaryIpsecTunnel *string `pulumi:"secondaryIpsecTunnel"`
	// spn-name is needed when licenseType is FWAAS-AGGREGATE
	SpnName *string `pulumi:"spnName"`
	// Subnets
	Subnets []string `pulumi:"subnets"`
	Tfid    *string  `pulumi:"tfid"`
}

type RemoteNetworkState struct {
	// Ecmp load balancing
	EcmpLoadBalancing pulumi.StringPtrInput
	// ecmp*tunnels is required when ecmp*load*balancing is enable
	EcmpTunnels RemoteNetworkEcmpTunnelArrayInput
	// Map of sensitive values returned from the API.
	EncryptedValues pulumi.StringMapInput
	// The folder that contains the remote network
	Folder pulumi.StringPtrInput
	// ipsec*tunnel is required when ecmp*load_balancing is disable
	IpsecTunnel pulumi.StringPtrInput
	// New customer will only be on aggregate bandwidth licensing
	LicenseType pulumi.StringPtrInput
	// The name of the remote network
	Name pulumi.StringPtrInput
	// setup the protocol when ecmp*load*balancing is disable
	Protocol RemoteNetworkProtocolPtrInput
	// Region
	Region pulumi.StringPtrInput
	// specify secondary ipsecTunnel if needed
	SecondaryIpsecTunnel pulumi.StringPtrInput
	// spn-name is needed when licenseType is FWAAS-AGGREGATE
	SpnName pulumi.StringPtrInput
	// Subnets
	Subnets pulumi.StringArrayInput
	Tfid    pulumi.StringPtrInput
}

func (RemoteNetworkState) ElementType() reflect.Type {
	return reflect.TypeOf((*remoteNetworkState)(nil)).Elem()
}

type remoteNetworkArgs struct {
	// Ecmp load balancing
	EcmpLoadBalancing *string `pulumi:"ecmpLoadBalancing"`
	// ecmp*tunnels is required when ecmp*load*balancing is enable
	EcmpTunnels []RemoteNetworkEcmpTunnel `pulumi:"ecmpTunnels"`
	// The folder that contains the remote network
	Folder string `pulumi:"folder"`
	// ipsec*tunnel is required when ecmp*load_balancing is disable
	IpsecTunnel *string `pulumi:"ipsecTunnel"`
	// New customer will only be on aggregate bandwidth licensing
	LicenseType string `pulumi:"licenseType"`
	// The name of the remote network
	Name *string `pulumi:"name"`
	// setup the protocol when ecmp*load*balancing is disable
	Protocol *RemoteNetworkProtocol `pulumi:"protocol"`
	// Region
	Region string `pulumi:"region"`
	// specify secondary ipsecTunnel if needed
	SecondaryIpsecTunnel *string `pulumi:"secondaryIpsecTunnel"`
	// spn-name is needed when licenseType is FWAAS-AGGREGATE
	SpnName *string `pulumi:"spnName"`
	// Subnets
	Subnets []string `pulumi:"subnets"`
}

// The set of arguments for constructing a RemoteNetwork resource.
type RemoteNetworkArgs struct {
	// Ecmp load balancing
	EcmpLoadBalancing pulumi.StringPtrInput
	// ecmp*tunnels is required when ecmp*load*balancing is enable
	EcmpTunnels RemoteNetworkEcmpTunnelArrayInput
	// The folder that contains the remote network
	Folder pulumi.StringInput
	// ipsec*tunnel is required when ecmp*load_balancing is disable
	IpsecTunnel pulumi.StringPtrInput
	// New customer will only be on aggregate bandwidth licensing
	LicenseType pulumi.StringInput
	// The name of the remote network
	Name pulumi.StringPtrInput
	// setup the protocol when ecmp*load*balancing is disable
	Protocol RemoteNetworkProtocolPtrInput
	// Region
	Region pulumi.StringInput
	// specify secondary ipsecTunnel if needed
	SecondaryIpsecTunnel pulumi.StringPtrInput
	// spn-name is needed when licenseType is FWAAS-AGGREGATE
	SpnName pulumi.StringPtrInput
	// Subnets
	Subnets pulumi.StringArrayInput
}

func (RemoteNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*remoteNetworkArgs)(nil)).Elem()
}

type RemoteNetworkInput interface {
	pulumi.Input

	ToRemoteNetworkOutput() RemoteNetworkOutput
	ToRemoteNetworkOutputWithContext(ctx context.Context) RemoteNetworkOutput
}

func (*RemoteNetwork) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoteNetwork)(nil)).Elem()
}

func (i *RemoteNetwork) ToRemoteNetworkOutput() RemoteNetworkOutput {
	return i.ToRemoteNetworkOutputWithContext(context.Background())
}

func (i *RemoteNetwork) ToRemoteNetworkOutputWithContext(ctx context.Context) RemoteNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoteNetworkOutput)
}

// RemoteNetworkArrayInput is an input type that accepts RemoteNetworkArray and RemoteNetworkArrayOutput values.
// You can construct a concrete instance of `RemoteNetworkArrayInput` via:
//
//	RemoteNetworkArray{ RemoteNetworkArgs{...} }
type RemoteNetworkArrayInput interface {
	pulumi.Input

	ToRemoteNetworkArrayOutput() RemoteNetworkArrayOutput
	ToRemoteNetworkArrayOutputWithContext(context.Context) RemoteNetworkArrayOutput
}

type RemoteNetworkArray []RemoteNetworkInput

func (RemoteNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RemoteNetwork)(nil)).Elem()
}

func (i RemoteNetworkArray) ToRemoteNetworkArrayOutput() RemoteNetworkArrayOutput {
	return i.ToRemoteNetworkArrayOutputWithContext(context.Background())
}

func (i RemoteNetworkArray) ToRemoteNetworkArrayOutputWithContext(ctx context.Context) RemoteNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoteNetworkArrayOutput)
}

// RemoteNetworkMapInput is an input type that accepts RemoteNetworkMap and RemoteNetworkMapOutput values.
// You can construct a concrete instance of `RemoteNetworkMapInput` via:
//
//	RemoteNetworkMap{ "key": RemoteNetworkArgs{...} }
type RemoteNetworkMapInput interface {
	pulumi.Input

	ToRemoteNetworkMapOutput() RemoteNetworkMapOutput
	ToRemoteNetworkMapOutputWithContext(context.Context) RemoteNetworkMapOutput
}

type RemoteNetworkMap map[string]RemoteNetworkInput

func (RemoteNetworkMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RemoteNetwork)(nil)).Elem()
}

func (i RemoteNetworkMap) ToRemoteNetworkMapOutput() RemoteNetworkMapOutput {
	return i.ToRemoteNetworkMapOutputWithContext(context.Background())
}

func (i RemoteNetworkMap) ToRemoteNetworkMapOutputWithContext(ctx context.Context) RemoteNetworkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoteNetworkMapOutput)
}

type RemoteNetworkOutput struct{ *pulumi.OutputState }

func (RemoteNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoteNetwork)(nil)).Elem()
}

func (o RemoteNetworkOutput) ToRemoteNetworkOutput() RemoteNetworkOutput {
	return o
}

func (o RemoteNetworkOutput) ToRemoteNetworkOutputWithContext(ctx context.Context) RemoteNetworkOutput {
	return o
}

// Ecmp load balancing
func (o RemoteNetworkOutput) EcmpLoadBalancing() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.EcmpLoadBalancing }).(pulumi.StringOutput)
}

// ecmp*tunnels is required when ecmp*load*balancing is enable
func (o RemoteNetworkOutput) EcmpTunnels() RemoteNetworkEcmpTunnelArrayOutput {
	return o.ApplyT(func(v *RemoteNetwork) RemoteNetworkEcmpTunnelArrayOutput { return v.EcmpTunnels }).(RemoteNetworkEcmpTunnelArrayOutput)
}

// Map of sensitive values returned from the API.
func (o RemoteNetworkOutput) EncryptedValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringMapOutput { return v.EncryptedValues }).(pulumi.StringMapOutput)
}

// The folder that contains the remote network
func (o RemoteNetworkOutput) Folder() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.Folder }).(pulumi.StringOutput)
}

// ipsec*tunnel is required when ecmp*load_balancing is disable
func (o RemoteNetworkOutput) IpsecTunnel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringPtrOutput { return v.IpsecTunnel }).(pulumi.StringPtrOutput)
}

// New customer will only be on aggregate bandwidth licensing
func (o RemoteNetworkOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.LicenseType }).(pulumi.StringOutput)
}

// The name of the remote network
func (o RemoteNetworkOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// setup the protocol when ecmp*load*balancing is disable
func (o RemoteNetworkOutput) Protocol() RemoteNetworkProtocolPtrOutput {
	return o.ApplyT(func(v *RemoteNetwork) RemoteNetworkProtocolPtrOutput { return v.Protocol }).(RemoteNetworkProtocolPtrOutput)
}

// Region
func (o RemoteNetworkOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// specify secondary ipsecTunnel if needed
func (o RemoteNetworkOutput) SecondaryIpsecTunnel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringPtrOutput { return v.SecondaryIpsecTunnel }).(pulumi.StringPtrOutput)
}

// spn-name is needed when licenseType is FWAAS-AGGREGATE
func (o RemoteNetworkOutput) SpnName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringPtrOutput { return v.SpnName }).(pulumi.StringPtrOutput)
}

// Subnets
func (o RemoteNetworkOutput) Subnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringArrayOutput { return v.Subnets }).(pulumi.StringArrayOutput)
}

func (o RemoteNetworkOutput) Tfid() pulumi.StringOutput {
	return o.ApplyT(func(v *RemoteNetwork) pulumi.StringOutput { return v.Tfid }).(pulumi.StringOutput)
}

type RemoteNetworkArrayOutput struct{ *pulumi.OutputState }

func (RemoteNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RemoteNetwork)(nil)).Elem()
}

func (o RemoteNetworkArrayOutput) ToRemoteNetworkArrayOutput() RemoteNetworkArrayOutput {
	return o
}

func (o RemoteNetworkArrayOutput) ToRemoteNetworkArrayOutputWithContext(ctx context.Context) RemoteNetworkArrayOutput {
	return o
}

func (o RemoteNetworkArrayOutput) Index(i pulumi.IntInput) RemoteNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RemoteNetwork {
		return vs[0].([]*RemoteNetwork)[vs[1].(int)]
	}).(RemoteNetworkOutput)
}

type RemoteNetworkMapOutput struct{ *pulumi.OutputState }

func (RemoteNetworkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RemoteNetwork)(nil)).Elem()
}

func (o RemoteNetworkMapOutput) ToRemoteNetworkMapOutput() RemoteNetworkMapOutput {
	return o
}

func (o RemoteNetworkMapOutput) ToRemoteNetworkMapOutputWithContext(ctx context.Context) RemoteNetworkMapOutput {
	return o
}

func (o RemoteNetworkMapOutput) MapIndex(k pulumi.StringInput) RemoteNetworkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RemoteNetwork {
		return vs[0].(map[string]*RemoteNetwork)[vs[1].(string)]
	}).(RemoteNetworkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RemoteNetworkInput)(nil)).Elem(), &RemoteNetwork{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoteNetworkArrayInput)(nil)).Elem(), RemoteNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoteNetworkMapInput)(nil)).Elem(), RemoteNetworkMap{})
	pulumi.RegisterOutputType(RemoteNetworkOutput{})
	pulumi.RegisterOutputType(RemoteNetworkArrayOutput{})
	pulumi.RegisterOutputType(RemoteNetworkMapOutput{})
}
