// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Scm
{
    /// <summary>
    /// ZoneProtectionProfile resource
    /// </summary>
    [ScmResourceType("scm:index/zoneProtectionProfile:ZoneProtectionProfile")]
    public partial class ZoneProtectionProfile : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
        /// * `Global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
        /// * `Drop` — Drop packets that contain an asymmetric path.
        /// * `Bypass` — Bypass scanning on packets that contain an asymmetric path.
        /// </summary>
        [Output("asymmetricPath")]
        public Output<string?> AsymmetricPath { get; private set; } = null!;

        /// <summary>
        /// The description of the profile
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The device in which the resource is defined
        /// </summary>
        [Output("device")]
        public Output<string?> Device { get; private set; } = null!;

        /// <summary>
        /// Discard ICMP packets that are embedded with an error message.
        /// </summary>
        [Output("discardIcmpEmbeddedError")]
        public Output<bool?> DiscardIcmpEmbeddedError { get; private set; } = null!;

        /// <summary>
        /// Flood
        /// </summary>
        [Output("flood")]
        public Output<Outputs.ZoneProtectionProfileFlood?> Flood { get; private set; } = null!;

        /// <summary>
        /// The folder in which the resource is defined
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// Discard fragmented IP packets.
        /// </summary>
        [Output("fragmentedTrafficDiscard")]
        public Output<bool?> FragmentedTrafficDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard packets that consist of ICMP fragments.
        /// </summary>
        [Output("icmpFragDiscard")]
        public Output<bool?> IcmpFragDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard ICMP packets that are larger than 1024 bytes.
        /// </summary>
        [Output("icmpLargePacketDiscard")]
        public Output<bool?> IcmpLargePacketDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard packets if the ICMP ping packet has an identifier value of 0.
        /// </summary>
        [Output("icmpPingZeroIdDiscard")]
        public Output<bool?> IcmpPingZeroIdDiscard { get; private set; } = null!;

        /// <summary>
        /// Ipv6
        /// </summary>
        [Output("ipv6")]
        public Output<Outputs.ZoneProtectionProfileIpv6?> Ipv6 { get; private set; } = null!;

        /// <summary>
        /// L2 sec group tag protection
        /// </summary>
        [Output("l2SecGroupTagProtection")]
        public Output<Outputs.ZoneProtectionProfileL2SecGroupTagProtection?> L2SecGroupTagProtection { get; private set; } = null!;

        /// <summary>
        /// Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
        /// </summary>
        [Output("looseSourceRoutingDiscard")]
        public Output<bool?> LooseSourceRoutingDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
        /// </summary>
        [Output("malformedOptionDiscard")]
        public Output<bool?> MalformedOptionDiscard { get; private set; } = null!;

        /// <summary>
        /// Drop packets with mismatched overlapping TCP segments.
        /// </summary>
        [Output("mismatchedOverlappingTcpSegmentDiscard")]
        public Output<bool?> MismatchedOverlappingTcpSegmentDiscard { get; private set; } = null!;

        /// <summary>
        /// MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
        /// * `No` — Enable MPTCP support (do not strip the MPTCP option).
        /// * `Yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
        /// * `Global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
        /// </summary>
        [Output("mptcpOptionStrip")]
        public Output<string> MptcpOptionStrip { get; private set; } = null!;

        /// <summary>
        /// The profile name
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Non ip protocol
        /// </summary>
        [Output("nonIpProtocol")]
        public Output<Outputs.ZoneProtectionProfileNonIpProtocol?> NonIpProtocol { get; private set; } = null!;

        /// <summary>
        /// Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
        /// </summary>
        [Output("recordRouteDiscard")]
        public Output<bool?> RecordRouteDiscard { get; private set; } = null!;

        /// <summary>
        /// Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
        /// * `Global` — Use system-wide setting that is assigned through the CLI.
        /// * `Yes` — Reject non-SYN TCP.
        /// * `No` — Accept non-SYN TCP.
        /// </summary>
        [Output("rejectNonSynTcp")]
        public Output<string?> RejectNonSynTcp { get; private set; } = null!;

        /// <summary>
        /// Scan white list
        /// </summary>
        [Output("scanWhiteLists")]
        public Output<ImmutableArray<Outputs.ZoneProtectionProfileScanWhiteList>> ScanWhiteLists { get; private set; } = null!;

        /// <summary>
        /// Scan
        /// </summary>
        [Output("scans")]
        public Output<ImmutableArray<Outputs.ZoneProtectionProfileScan>> Scans { get; private set; } = null!;

        /// <summary>
        /// Discard packets if the security option is defined.
        /// </summary>
        [Output("securityDiscard")]
        public Output<bool?> SecurityDiscard { get; private set; } = null!;

        /// <summary>
        /// The snippet in which the resource is defined
        /// </summary>
        [Output("snippet")]
        public Output<string?> Snippet { get; private set; } = null!;

        /// <summary>
        /// Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
        /// </summary>
        [Output("spoofedIpDiscard")]
        public Output<bool?> SpoofedIpDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard packets if the Stream ID option is defined.
        /// </summary>
        [Output("streamIdDiscard")]
        public Output<bool?> StreamIdDiscard { get; private set; } = null!;

        /// <summary>
        /// Check that both conditions are true:
        /// * The source IP address is not the subnet broadcast IP address of the ingress interface.
        /// * The source IP address is routable over the exact ingress interface.
        /// If either condition is not true, discard the packet.
        /// </summary>
        [Output("strictIpCheck")]
        public Output<bool?> StrictIpCheck { get; private set; } = null!;

        /// <summary>
        /// Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
        /// </summary>
        [Output("strictSourceRoutingDiscard")]
        public Output<bool?> StrictSourceRoutingDiscard { get; private set; } = null!;

        /// <summary>
        /// Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
        /// </summary>
        [Output("suppressIcmpNeedfrag")]
        public Output<bool?> SuppressIcmpNeedfrag { get; private set; } = null!;

        /// <summary>
        /// Stop sending ICMP TTL expired messages.
        /// </summary>
        [Output("suppressIcmpTimeexceeded")]
        public Output<bool?> SuppressIcmpTimeexceeded { get; private set; } = null!;

        /// <summary>
        /// Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
        /// </summary>
        [Output("tcpFastOpenAndDataStrip")]
        public Output<bool?> TcpFastOpenAndDataStrip { get; private set; } = null!;

        /// <summary>
        /// Drop packets with split handshakes.
        /// </summary>
        [Output("tcpHandshakeDiscard")]
        public Output<bool?> TcpHandshakeDiscard { get; private set; } = null!;

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
        /// </summary>
        [Output("tcpSynWithDataDiscard")]
        public Output<bool> TcpSynWithDataDiscard { get; private set; } = null!;

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
        /// </summary>
        [Output("tcpSynackWithDataDiscard")]
        public Output<bool> TcpSynackWithDataDiscard { get; private set; } = null!;

        /// <summary>
        /// Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
        /// </summary>
        [Output("tcpTimestampStrip")]
        public Output<bool?> TcpTimestampStrip { get; private set; } = null!;

        [Output("tfid")]
        public Output<string> Tfid { get; private set; } = null!;

        /// <summary>
        /// Discard packets with the Timestamp IP option set.
        /// </summary>
        [Output("timestampDiscard")]
        public Output<bool?> TimestampDiscard { get; private set; } = null!;

        /// <summary>
        /// Discard packets if the class and number are unknown.
        /// </summary>
        [Output("unknownOptionDiscard")]
        public Output<bool?> UnknownOptionDiscard { get; private set; } = null!;


        /// <summary>
        /// Create a ZoneProtectionProfile resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ZoneProtectionProfile(string name, ZoneProtectionProfileArgs? args = null, CustomResourceOptions? options = null)
            : base("scm:index/zoneProtectionProfile:ZoneProtectionProfile", name, args ?? new ZoneProtectionProfileArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ZoneProtectionProfile(string name, Input<string> id, ZoneProtectionProfileState? state = null, CustomResourceOptions? options = null)
            : base("scm:index/zoneProtectionProfile:ZoneProtectionProfile", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ZoneProtectionProfile resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ZoneProtectionProfile Get(string name, Input<string> id, ZoneProtectionProfileState? state = null, CustomResourceOptions? options = null)
        {
            return new ZoneProtectionProfile(name, id, state, options);
        }
    }

    public sealed class ZoneProtectionProfileArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
        /// * `Global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
        /// * `Drop` — Drop packets that contain an asymmetric path.
        /// * `Bypass` — Bypass scanning on packets that contain an asymmetric path.
        /// </summary>
        [Input("asymmetricPath")]
        public Input<string>? AsymmetricPath { get; set; }

        /// <summary>
        /// The description of the profile
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The device in which the resource is defined
        /// </summary>
        [Input("device")]
        public Input<string>? Device { get; set; }

        /// <summary>
        /// Discard ICMP packets that are embedded with an error message.
        /// </summary>
        [Input("discardIcmpEmbeddedError")]
        public Input<bool>? DiscardIcmpEmbeddedError { get; set; }

        /// <summary>
        /// Flood
        /// </summary>
        [Input("flood")]
        public Input<Inputs.ZoneProtectionProfileFloodArgs>? Flood { get; set; }

        /// <summary>
        /// The folder in which the resource is defined
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Discard fragmented IP packets.
        /// </summary>
        [Input("fragmentedTrafficDiscard")]
        public Input<bool>? FragmentedTrafficDiscard { get; set; }

        /// <summary>
        /// Discard packets that consist of ICMP fragments.
        /// </summary>
        [Input("icmpFragDiscard")]
        public Input<bool>? IcmpFragDiscard { get; set; }

        /// <summary>
        /// Discard ICMP packets that are larger than 1024 bytes.
        /// </summary>
        [Input("icmpLargePacketDiscard")]
        public Input<bool>? IcmpLargePacketDiscard { get; set; }

        /// <summary>
        /// Discard packets if the ICMP ping packet has an identifier value of 0.
        /// </summary>
        [Input("icmpPingZeroIdDiscard")]
        public Input<bool>? IcmpPingZeroIdDiscard { get; set; }

        /// <summary>
        /// Ipv6
        /// </summary>
        [Input("ipv6")]
        public Input<Inputs.ZoneProtectionProfileIpv6Args>? Ipv6 { get; set; }

        /// <summary>
        /// L2 sec group tag protection
        /// </summary>
        [Input("l2SecGroupTagProtection")]
        public Input<Inputs.ZoneProtectionProfileL2SecGroupTagProtectionArgs>? L2SecGroupTagProtection { get; set; }

        /// <summary>
        /// Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
        /// </summary>
        [Input("looseSourceRoutingDiscard")]
        public Input<bool>? LooseSourceRoutingDiscard { get; set; }

        /// <summary>
        /// Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
        /// </summary>
        [Input("malformedOptionDiscard")]
        public Input<bool>? MalformedOptionDiscard { get; set; }

        /// <summary>
        /// Drop packets with mismatched overlapping TCP segments.
        /// </summary>
        [Input("mismatchedOverlappingTcpSegmentDiscard")]
        public Input<bool>? MismatchedOverlappingTcpSegmentDiscard { get; set; }

        /// <summary>
        /// MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
        /// * `No` — Enable MPTCP support (do not strip the MPTCP option).
        /// * `Yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
        /// * `Global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
        /// </summary>
        [Input("mptcpOptionStrip")]
        public Input<string>? MptcpOptionStrip { get; set; }

        /// <summary>
        /// The profile name
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Non ip protocol
        /// </summary>
        [Input("nonIpProtocol")]
        public Input<Inputs.ZoneProtectionProfileNonIpProtocolArgs>? NonIpProtocol { get; set; }

        /// <summary>
        /// Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
        /// </summary>
        [Input("recordRouteDiscard")]
        public Input<bool>? RecordRouteDiscard { get; set; }

        /// <summary>
        /// Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
        /// * `Global` — Use system-wide setting that is assigned through the CLI.
        /// * `Yes` — Reject non-SYN TCP.
        /// * `No` — Accept non-SYN TCP.
        /// </summary>
        [Input("rejectNonSynTcp")]
        public Input<string>? RejectNonSynTcp { get; set; }

        [Input("scanWhiteLists")]
        private InputList<Inputs.ZoneProtectionProfileScanWhiteListArgs>? _scanWhiteLists;

        /// <summary>
        /// Scan white list
        /// </summary>
        public InputList<Inputs.ZoneProtectionProfileScanWhiteListArgs> ScanWhiteLists
        {
            get => _scanWhiteLists ?? (_scanWhiteLists = new InputList<Inputs.ZoneProtectionProfileScanWhiteListArgs>());
            set => _scanWhiteLists = value;
        }

        [Input("scans")]
        private InputList<Inputs.ZoneProtectionProfileScanArgs>? _scans;

        /// <summary>
        /// Scan
        /// </summary>
        public InputList<Inputs.ZoneProtectionProfileScanArgs> Scans
        {
            get => _scans ?? (_scans = new InputList<Inputs.ZoneProtectionProfileScanArgs>());
            set => _scans = value;
        }

        /// <summary>
        /// Discard packets if the security option is defined.
        /// </summary>
        [Input("securityDiscard")]
        public Input<bool>? SecurityDiscard { get; set; }

        /// <summary>
        /// The snippet in which the resource is defined
        /// </summary>
        [Input("snippet")]
        public Input<string>? Snippet { get; set; }

        /// <summary>
        /// Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
        /// </summary>
        [Input("spoofedIpDiscard")]
        public Input<bool>? SpoofedIpDiscard { get; set; }

        /// <summary>
        /// Discard packets if the Stream ID option is defined.
        /// </summary>
        [Input("streamIdDiscard")]
        public Input<bool>? StreamIdDiscard { get; set; }

        /// <summary>
        /// Check that both conditions are true:
        /// * The source IP address is not the subnet broadcast IP address of the ingress interface.
        /// * The source IP address is routable over the exact ingress interface.
        /// If either condition is not true, discard the packet.
        /// </summary>
        [Input("strictIpCheck")]
        public Input<bool>? StrictIpCheck { get; set; }

        /// <summary>
        /// Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
        /// </summary>
        [Input("strictSourceRoutingDiscard")]
        public Input<bool>? StrictSourceRoutingDiscard { get; set; }

        /// <summary>
        /// Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
        /// </summary>
        [Input("suppressIcmpNeedfrag")]
        public Input<bool>? SuppressIcmpNeedfrag { get; set; }

        /// <summary>
        /// Stop sending ICMP TTL expired messages.
        /// </summary>
        [Input("suppressIcmpTimeexceeded")]
        public Input<bool>? SuppressIcmpTimeexceeded { get; set; }

        /// <summary>
        /// Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
        /// </summary>
        [Input("tcpFastOpenAndDataStrip")]
        public Input<bool>? TcpFastOpenAndDataStrip { get; set; }

        /// <summary>
        /// Drop packets with split handshakes.
        /// </summary>
        [Input("tcpHandshakeDiscard")]
        public Input<bool>? TcpHandshakeDiscard { get; set; }

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
        /// </summary>
        [Input("tcpSynWithDataDiscard")]
        public Input<bool>? TcpSynWithDataDiscard { get; set; }

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
        /// </summary>
        [Input("tcpSynackWithDataDiscard")]
        public Input<bool>? TcpSynackWithDataDiscard { get; set; }

        /// <summary>
        /// Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
        /// </summary>
        [Input("tcpTimestampStrip")]
        public Input<bool>? TcpTimestampStrip { get; set; }

        /// <summary>
        /// Discard packets with the Timestamp IP option set.
        /// </summary>
        [Input("timestampDiscard")]
        public Input<bool>? TimestampDiscard { get; set; }

        /// <summary>
        /// Discard packets if the class and number are unknown.
        /// </summary>
        [Input("unknownOptionDiscard")]
        public Input<bool>? UnknownOptionDiscard { get; set; }

        public ZoneProtectionProfileArgs()
        {
        }
        public static new ZoneProtectionProfileArgs Empty => new ZoneProtectionProfileArgs();
    }

    public sealed class ZoneProtectionProfileState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
        /// * `Global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
        /// * `Drop` — Drop packets that contain an asymmetric path.
        /// * `Bypass` — Bypass scanning on packets that contain an asymmetric path.
        /// </summary>
        [Input("asymmetricPath")]
        public Input<string>? AsymmetricPath { get; set; }

        /// <summary>
        /// The description of the profile
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The device in which the resource is defined
        /// </summary>
        [Input("device")]
        public Input<string>? Device { get; set; }

        /// <summary>
        /// Discard ICMP packets that are embedded with an error message.
        /// </summary>
        [Input("discardIcmpEmbeddedError")]
        public Input<bool>? DiscardIcmpEmbeddedError { get; set; }

        /// <summary>
        /// Flood
        /// </summary>
        [Input("flood")]
        public Input<Inputs.ZoneProtectionProfileFloodGetArgs>? Flood { get; set; }

        /// <summary>
        /// The folder in which the resource is defined
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Discard fragmented IP packets.
        /// </summary>
        [Input("fragmentedTrafficDiscard")]
        public Input<bool>? FragmentedTrafficDiscard { get; set; }

        /// <summary>
        /// Discard packets that consist of ICMP fragments.
        /// </summary>
        [Input("icmpFragDiscard")]
        public Input<bool>? IcmpFragDiscard { get; set; }

        /// <summary>
        /// Discard ICMP packets that are larger than 1024 bytes.
        /// </summary>
        [Input("icmpLargePacketDiscard")]
        public Input<bool>? IcmpLargePacketDiscard { get; set; }

        /// <summary>
        /// Discard packets if the ICMP ping packet has an identifier value of 0.
        /// </summary>
        [Input("icmpPingZeroIdDiscard")]
        public Input<bool>? IcmpPingZeroIdDiscard { get; set; }

        /// <summary>
        /// Ipv6
        /// </summary>
        [Input("ipv6")]
        public Input<Inputs.ZoneProtectionProfileIpv6GetArgs>? Ipv6 { get; set; }

        /// <summary>
        /// L2 sec group tag protection
        /// </summary>
        [Input("l2SecGroupTagProtection")]
        public Input<Inputs.ZoneProtectionProfileL2SecGroupTagProtectionGetArgs>? L2SecGroupTagProtection { get; set; }

        /// <summary>
        /// Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
        /// </summary>
        [Input("looseSourceRoutingDiscard")]
        public Input<bool>? LooseSourceRoutingDiscard { get; set; }

        /// <summary>
        /// Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
        /// </summary>
        [Input("malformedOptionDiscard")]
        public Input<bool>? MalformedOptionDiscard { get; set; }

        /// <summary>
        /// Drop packets with mismatched overlapping TCP segments.
        /// </summary>
        [Input("mismatchedOverlappingTcpSegmentDiscard")]
        public Input<bool>? MismatchedOverlappingTcpSegmentDiscard { get; set; }

        /// <summary>
        /// MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
        /// * `No` — Enable MPTCP support (do not strip the MPTCP option).
        /// * `Yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
        /// * `Global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
        /// </summary>
        [Input("mptcpOptionStrip")]
        public Input<string>? MptcpOptionStrip { get; set; }

        /// <summary>
        /// The profile name
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Non ip protocol
        /// </summary>
        [Input("nonIpProtocol")]
        public Input<Inputs.ZoneProtectionProfileNonIpProtocolGetArgs>? NonIpProtocol { get; set; }

        /// <summary>
        /// Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
        /// </summary>
        [Input("recordRouteDiscard")]
        public Input<bool>? RecordRouteDiscard { get; set; }

        /// <summary>
        /// Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
        /// * `Global` — Use system-wide setting that is assigned through the CLI.
        /// * `Yes` — Reject non-SYN TCP.
        /// * `No` — Accept non-SYN TCP.
        /// </summary>
        [Input("rejectNonSynTcp")]
        public Input<string>? RejectNonSynTcp { get; set; }

        [Input("scanWhiteLists")]
        private InputList<Inputs.ZoneProtectionProfileScanWhiteListGetArgs>? _scanWhiteLists;

        /// <summary>
        /// Scan white list
        /// </summary>
        public InputList<Inputs.ZoneProtectionProfileScanWhiteListGetArgs> ScanWhiteLists
        {
            get => _scanWhiteLists ?? (_scanWhiteLists = new InputList<Inputs.ZoneProtectionProfileScanWhiteListGetArgs>());
            set => _scanWhiteLists = value;
        }

        [Input("scans")]
        private InputList<Inputs.ZoneProtectionProfileScanGetArgs>? _scans;

        /// <summary>
        /// Scan
        /// </summary>
        public InputList<Inputs.ZoneProtectionProfileScanGetArgs> Scans
        {
            get => _scans ?? (_scans = new InputList<Inputs.ZoneProtectionProfileScanGetArgs>());
            set => _scans = value;
        }

        /// <summary>
        /// Discard packets if the security option is defined.
        /// </summary>
        [Input("securityDiscard")]
        public Input<bool>? SecurityDiscard { get; set; }

        /// <summary>
        /// The snippet in which the resource is defined
        /// </summary>
        [Input("snippet")]
        public Input<string>? Snippet { get; set; }

        /// <summary>
        /// Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
        /// </summary>
        [Input("spoofedIpDiscard")]
        public Input<bool>? SpoofedIpDiscard { get; set; }

        /// <summary>
        /// Discard packets if the Stream ID option is defined.
        /// </summary>
        [Input("streamIdDiscard")]
        public Input<bool>? StreamIdDiscard { get; set; }

        /// <summary>
        /// Check that both conditions are true:
        /// * The source IP address is not the subnet broadcast IP address of the ingress interface.
        /// * The source IP address is routable over the exact ingress interface.
        /// If either condition is not true, discard the packet.
        /// </summary>
        [Input("strictIpCheck")]
        public Input<bool>? StrictIpCheck { get; set; }

        /// <summary>
        /// Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
        /// </summary>
        [Input("strictSourceRoutingDiscard")]
        public Input<bool>? StrictSourceRoutingDiscard { get; set; }

        /// <summary>
        /// Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
        /// </summary>
        [Input("suppressIcmpNeedfrag")]
        public Input<bool>? SuppressIcmpNeedfrag { get; set; }

        /// <summary>
        /// Stop sending ICMP TTL expired messages.
        /// </summary>
        [Input("suppressIcmpTimeexceeded")]
        public Input<bool>? SuppressIcmpTimeexceeded { get; set; }

        /// <summary>
        /// Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
        /// </summary>
        [Input("tcpFastOpenAndDataStrip")]
        public Input<bool>? TcpFastOpenAndDataStrip { get; set; }

        /// <summary>
        /// Drop packets with split handshakes.
        /// </summary>
        [Input("tcpHandshakeDiscard")]
        public Input<bool>? TcpHandshakeDiscard { get; set; }

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
        /// </summary>
        [Input("tcpSynWithDataDiscard")]
        public Input<bool>? TcpSynWithDataDiscard { get; set; }

        /// <summary>
        /// Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
        /// </summary>
        [Input("tcpSynackWithDataDiscard")]
        public Input<bool>? TcpSynackWithDataDiscard { get; set; }

        /// <summary>
        /// Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
        /// </summary>
        [Input("tcpTimestampStrip")]
        public Input<bool>? TcpTimestampStrip { get; set; }

        [Input("tfid")]
        public Input<string>? Tfid { get; set; }

        /// <summary>
        /// Discard packets with the Timestamp IP option set.
        /// </summary>
        [Input("timestampDiscard")]
        public Input<bool>? TimestampDiscard { get; set; }

        /// <summary>
        /// Discard packets if the class and number are unknown.
        /// </summary>
        [Input("unknownOptionDiscard")]
        public Input<bool>? UnknownOptionDiscard { get; set; }

        public ZoneProtectionProfileState()
        {
        }
        public static new ZoneProtectionProfileState Empty => new ZoneProtectionProfileState();
    }
}
