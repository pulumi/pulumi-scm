// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.scm.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataFlood;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataIpv6;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataL2SecGroupTagProtection;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataNonIpProtocol;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataScan;
import com.pulumi.scm.outputs.GetZoneProtectionProfileListDataScanWhiteList;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetZoneProtectionProfileListData {
    /**
     * @return Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    private String asymmetricPath;
    /**
     * @return The description of the profile
     * 
     */
    private String description;
    /**
     * @return The device in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    private String device;
    /**
     * @return Discard ICMP packets that are embedded with an error message.
     * 
     */
    private Boolean discardIcmpEmbeddedError;
    /**
     * @return Flood
     * 
     */
    private GetZoneProtectionProfileListDataFlood flood;
    /**
     * @return The folder in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    private String folder;
    /**
     * @return Discard fragmented IP packets.
     * 
     */
    private Boolean fragmentedTrafficDiscard;
    /**
     * @return Discard packets that consist of ICMP fragments.
     * 
     */
    private Boolean icmpFragDiscard;
    /**
     * @return Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    private Boolean icmpLargePacketDiscard;
    /**
     * @return Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    private Boolean icmpPingZeroIdDiscard;
    /**
     * @return UUID of the resource
     * 
     */
    private String id;
    /**
     * @return Ipv6
     * 
     */
    private GetZoneProtectionProfileListDataIpv6 ipv6;
    /**
     * @return L2 sec group tag protection
     * 
     */
    private GetZoneProtectionProfileListDataL2SecGroupTagProtection l2SecGroupTagProtection;
    /**
     * @return Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    private Boolean looseSourceRoutingDiscard;
    /**
     * @return Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    private Boolean malformedOptionDiscard;
    /**
     * @return Drop packets with mismatched overlapping TCP segments.
     * 
     */
    private Boolean mismatchedOverlappingTcpSegmentDiscard;
    /**
     * @return MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    private String mptcpOptionStrip;
    /**
     * @return The profile name
     * 
     */
    private String name;
    /**
     * @return Non ip protocol
     * 
     */
    private GetZoneProtectionProfileListDataNonIpProtocol nonIpProtocol;
    /**
     * @return Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    private Boolean recordRouteDiscard;
    /**
     * @return Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    private String rejectNonSynTcp;
    /**
     * @return Scan white list
     * 
     */
    private List<GetZoneProtectionProfileListDataScanWhiteList> scanWhiteLists;
    /**
     * @return Scan
     * 
     */
    private List<GetZoneProtectionProfileListDataScan> scans;
    /**
     * @return Discard packets if the security option is defined.
     * 
     */
    private Boolean securityDiscard;
    /**
     * @return The snippet in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    private String snippet;
    /**
     * @return Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    private Boolean spoofedIpDiscard;
    /**
     * @return Discard packets if the Stream ID option is defined.
     * 
     */
    private Boolean streamIdDiscard;
    /**
     * @return Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    private Boolean strictIpCheck;
    /**
     * @return Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    private Boolean strictSourceRoutingDiscard;
    /**
     * @return Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    private Boolean suppressIcmpNeedfrag;
    /**
     * @return Stop sending ICMP TTL expired messages.
     * 
     */
    private Boolean suppressIcmpTimeexceeded;
    /**
     * @return Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    private Boolean tcpFastOpenAndDataStrip;
    /**
     * @return Drop packets with split handshakes.
     * 
     */
    private Boolean tcpHandshakeDiscard;
    /**
     * @return Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    private Boolean tcpSynWithDataDiscard;
    /**
     * @return Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    private Boolean tcpSynackWithDataDiscard;
    /**
     * @return Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    private Boolean tcpTimestampStrip;
    private String tfid;
    /**
     * @return Discard packets with the Timestamp IP option set.
     * 
     */
    private Boolean timestampDiscard;
    /**
     * @return Discard packets if the class and number are unknown.
     * 
     */
    private Boolean unknownOptionDiscard;

    private GetZoneProtectionProfileListData() {}
    /**
     * @return Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    public String asymmetricPath() {
        return this.asymmetricPath;
    }
    /**
     * @return The description of the profile
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return The device in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public String device() {
        return this.device;
    }
    /**
     * @return Discard ICMP packets that are embedded with an error message.
     * 
     */
    public Boolean discardIcmpEmbeddedError() {
        return this.discardIcmpEmbeddedError;
    }
    /**
     * @return Flood
     * 
     */
    public GetZoneProtectionProfileListDataFlood flood() {
        return this.flood;
    }
    /**
     * @return The folder in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public String folder() {
        return this.folder;
    }
    /**
     * @return Discard fragmented IP packets.
     * 
     */
    public Boolean fragmentedTrafficDiscard() {
        return this.fragmentedTrafficDiscard;
    }
    /**
     * @return Discard packets that consist of ICMP fragments.
     * 
     */
    public Boolean icmpFragDiscard() {
        return this.icmpFragDiscard;
    }
    /**
     * @return Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    public Boolean icmpLargePacketDiscard() {
        return this.icmpLargePacketDiscard;
    }
    /**
     * @return Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    public Boolean icmpPingZeroIdDiscard() {
        return this.icmpPingZeroIdDiscard;
    }
    /**
     * @return UUID of the resource
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Ipv6
     * 
     */
    public GetZoneProtectionProfileListDataIpv6 ipv6() {
        return this.ipv6;
    }
    /**
     * @return L2 sec group tag protection
     * 
     */
    public GetZoneProtectionProfileListDataL2SecGroupTagProtection l2SecGroupTagProtection() {
        return this.l2SecGroupTagProtection;
    }
    /**
     * @return Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    public Boolean looseSourceRoutingDiscard() {
        return this.looseSourceRoutingDiscard;
    }
    /**
     * @return Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    public Boolean malformedOptionDiscard() {
        return this.malformedOptionDiscard;
    }
    /**
     * @return Drop packets with mismatched overlapping TCP segments.
     * 
     */
    public Boolean mismatchedOverlappingTcpSegmentDiscard() {
        return this.mismatchedOverlappingTcpSegmentDiscard;
    }
    /**
     * @return MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    public String mptcpOptionStrip() {
        return this.mptcpOptionStrip;
    }
    /**
     * @return The profile name
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Non ip protocol
     * 
     */
    public GetZoneProtectionProfileListDataNonIpProtocol nonIpProtocol() {
        return this.nonIpProtocol;
    }
    /**
     * @return Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    public Boolean recordRouteDiscard() {
        return this.recordRouteDiscard;
    }
    /**
     * @return Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    public String rejectNonSynTcp() {
        return this.rejectNonSynTcp;
    }
    /**
     * @return Scan white list
     * 
     */
    public List<GetZoneProtectionProfileListDataScanWhiteList> scanWhiteLists() {
        return this.scanWhiteLists;
    }
    /**
     * @return Scan
     * 
     */
    public List<GetZoneProtectionProfileListDataScan> scans() {
        return this.scans;
    }
    /**
     * @return Discard packets if the security option is defined.
     * 
     */
    public Boolean securityDiscard() {
        return this.securityDiscard;
    }
    /**
     * @return The snippet in which the resource is defined
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public String snippet() {
        return this.snippet;
    }
    /**
     * @return Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    public Boolean spoofedIpDiscard() {
        return this.spoofedIpDiscard;
    }
    /**
     * @return Discard packets if the Stream ID option is defined.
     * 
     */
    public Boolean streamIdDiscard() {
        return this.streamIdDiscard;
    }
    /**
     * @return Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    public Boolean strictIpCheck() {
        return this.strictIpCheck;
    }
    /**
     * @return Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    public Boolean strictSourceRoutingDiscard() {
        return this.strictSourceRoutingDiscard;
    }
    /**
     * @return Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    public Boolean suppressIcmpNeedfrag() {
        return this.suppressIcmpNeedfrag;
    }
    /**
     * @return Stop sending ICMP TTL expired messages.
     * 
     */
    public Boolean suppressIcmpTimeexceeded() {
        return this.suppressIcmpTimeexceeded;
    }
    /**
     * @return Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    public Boolean tcpFastOpenAndDataStrip() {
        return this.tcpFastOpenAndDataStrip;
    }
    /**
     * @return Drop packets with split handshakes.
     * 
     */
    public Boolean tcpHandshakeDiscard() {
        return this.tcpHandshakeDiscard;
    }
    /**
     * @return Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    public Boolean tcpSynWithDataDiscard() {
        return this.tcpSynWithDataDiscard;
    }
    /**
     * @return Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    public Boolean tcpSynackWithDataDiscard() {
        return this.tcpSynackWithDataDiscard;
    }
    /**
     * @return Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    public Boolean tcpTimestampStrip() {
        return this.tcpTimestampStrip;
    }
    public String tfid() {
        return this.tfid;
    }
    /**
     * @return Discard packets with the Timestamp IP option set.
     * 
     */
    public Boolean timestampDiscard() {
        return this.timestampDiscard;
    }
    /**
     * @return Discard packets if the class and number are unknown.
     * 
     */
    public Boolean unknownOptionDiscard() {
        return this.unknownOptionDiscard;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetZoneProtectionProfileListData defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String asymmetricPath;
        private String description;
        private String device;
        private Boolean discardIcmpEmbeddedError;
        private GetZoneProtectionProfileListDataFlood flood;
        private String folder;
        private Boolean fragmentedTrafficDiscard;
        private Boolean icmpFragDiscard;
        private Boolean icmpLargePacketDiscard;
        private Boolean icmpPingZeroIdDiscard;
        private String id;
        private GetZoneProtectionProfileListDataIpv6 ipv6;
        private GetZoneProtectionProfileListDataL2SecGroupTagProtection l2SecGroupTagProtection;
        private Boolean looseSourceRoutingDiscard;
        private Boolean malformedOptionDiscard;
        private Boolean mismatchedOverlappingTcpSegmentDiscard;
        private String mptcpOptionStrip;
        private String name;
        private GetZoneProtectionProfileListDataNonIpProtocol nonIpProtocol;
        private Boolean recordRouteDiscard;
        private String rejectNonSynTcp;
        private List<GetZoneProtectionProfileListDataScanWhiteList> scanWhiteLists;
        private List<GetZoneProtectionProfileListDataScan> scans;
        private Boolean securityDiscard;
        private String snippet;
        private Boolean spoofedIpDiscard;
        private Boolean streamIdDiscard;
        private Boolean strictIpCheck;
        private Boolean strictSourceRoutingDiscard;
        private Boolean suppressIcmpNeedfrag;
        private Boolean suppressIcmpTimeexceeded;
        private Boolean tcpFastOpenAndDataStrip;
        private Boolean tcpHandshakeDiscard;
        private Boolean tcpSynWithDataDiscard;
        private Boolean tcpSynackWithDataDiscard;
        private Boolean tcpTimestampStrip;
        private String tfid;
        private Boolean timestampDiscard;
        private Boolean unknownOptionDiscard;
        public Builder() {}
        public Builder(GetZoneProtectionProfileListData defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.asymmetricPath = defaults.asymmetricPath;
    	      this.description = defaults.description;
    	      this.device = defaults.device;
    	      this.discardIcmpEmbeddedError = defaults.discardIcmpEmbeddedError;
    	      this.flood = defaults.flood;
    	      this.folder = defaults.folder;
    	      this.fragmentedTrafficDiscard = defaults.fragmentedTrafficDiscard;
    	      this.icmpFragDiscard = defaults.icmpFragDiscard;
    	      this.icmpLargePacketDiscard = defaults.icmpLargePacketDiscard;
    	      this.icmpPingZeroIdDiscard = defaults.icmpPingZeroIdDiscard;
    	      this.id = defaults.id;
    	      this.ipv6 = defaults.ipv6;
    	      this.l2SecGroupTagProtection = defaults.l2SecGroupTagProtection;
    	      this.looseSourceRoutingDiscard = defaults.looseSourceRoutingDiscard;
    	      this.malformedOptionDiscard = defaults.malformedOptionDiscard;
    	      this.mismatchedOverlappingTcpSegmentDiscard = defaults.mismatchedOverlappingTcpSegmentDiscard;
    	      this.mptcpOptionStrip = defaults.mptcpOptionStrip;
    	      this.name = defaults.name;
    	      this.nonIpProtocol = defaults.nonIpProtocol;
    	      this.recordRouteDiscard = defaults.recordRouteDiscard;
    	      this.rejectNonSynTcp = defaults.rejectNonSynTcp;
    	      this.scanWhiteLists = defaults.scanWhiteLists;
    	      this.scans = defaults.scans;
    	      this.securityDiscard = defaults.securityDiscard;
    	      this.snippet = defaults.snippet;
    	      this.spoofedIpDiscard = defaults.spoofedIpDiscard;
    	      this.streamIdDiscard = defaults.streamIdDiscard;
    	      this.strictIpCheck = defaults.strictIpCheck;
    	      this.strictSourceRoutingDiscard = defaults.strictSourceRoutingDiscard;
    	      this.suppressIcmpNeedfrag = defaults.suppressIcmpNeedfrag;
    	      this.suppressIcmpTimeexceeded = defaults.suppressIcmpTimeexceeded;
    	      this.tcpFastOpenAndDataStrip = defaults.tcpFastOpenAndDataStrip;
    	      this.tcpHandshakeDiscard = defaults.tcpHandshakeDiscard;
    	      this.tcpSynWithDataDiscard = defaults.tcpSynWithDataDiscard;
    	      this.tcpSynackWithDataDiscard = defaults.tcpSynackWithDataDiscard;
    	      this.tcpTimestampStrip = defaults.tcpTimestampStrip;
    	      this.tfid = defaults.tfid;
    	      this.timestampDiscard = defaults.timestampDiscard;
    	      this.unknownOptionDiscard = defaults.unknownOptionDiscard;
        }

        @CustomType.Setter
        public Builder asymmetricPath(String asymmetricPath) {
            if (asymmetricPath == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "asymmetricPath");
            }
            this.asymmetricPath = asymmetricPath;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder device(String device) {
            if (device == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "device");
            }
            this.device = device;
            return this;
        }
        @CustomType.Setter
        public Builder discardIcmpEmbeddedError(Boolean discardIcmpEmbeddedError) {
            if (discardIcmpEmbeddedError == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "discardIcmpEmbeddedError");
            }
            this.discardIcmpEmbeddedError = discardIcmpEmbeddedError;
            return this;
        }
        @CustomType.Setter
        public Builder flood(GetZoneProtectionProfileListDataFlood flood) {
            if (flood == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "flood");
            }
            this.flood = flood;
            return this;
        }
        @CustomType.Setter
        public Builder folder(String folder) {
            if (folder == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "folder");
            }
            this.folder = folder;
            return this;
        }
        @CustomType.Setter
        public Builder fragmentedTrafficDiscard(Boolean fragmentedTrafficDiscard) {
            if (fragmentedTrafficDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "fragmentedTrafficDiscard");
            }
            this.fragmentedTrafficDiscard = fragmentedTrafficDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder icmpFragDiscard(Boolean icmpFragDiscard) {
            if (icmpFragDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "icmpFragDiscard");
            }
            this.icmpFragDiscard = icmpFragDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder icmpLargePacketDiscard(Boolean icmpLargePacketDiscard) {
            if (icmpLargePacketDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "icmpLargePacketDiscard");
            }
            this.icmpLargePacketDiscard = icmpLargePacketDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder icmpPingZeroIdDiscard(Boolean icmpPingZeroIdDiscard) {
            if (icmpPingZeroIdDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "icmpPingZeroIdDiscard");
            }
            this.icmpPingZeroIdDiscard = icmpPingZeroIdDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder ipv6(GetZoneProtectionProfileListDataIpv6 ipv6) {
            if (ipv6 == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "ipv6");
            }
            this.ipv6 = ipv6;
            return this;
        }
        @CustomType.Setter
        public Builder l2SecGroupTagProtection(GetZoneProtectionProfileListDataL2SecGroupTagProtection l2SecGroupTagProtection) {
            if (l2SecGroupTagProtection == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "l2SecGroupTagProtection");
            }
            this.l2SecGroupTagProtection = l2SecGroupTagProtection;
            return this;
        }
        @CustomType.Setter
        public Builder looseSourceRoutingDiscard(Boolean looseSourceRoutingDiscard) {
            if (looseSourceRoutingDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "looseSourceRoutingDiscard");
            }
            this.looseSourceRoutingDiscard = looseSourceRoutingDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder malformedOptionDiscard(Boolean malformedOptionDiscard) {
            if (malformedOptionDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "malformedOptionDiscard");
            }
            this.malformedOptionDiscard = malformedOptionDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder mismatchedOverlappingTcpSegmentDiscard(Boolean mismatchedOverlappingTcpSegmentDiscard) {
            if (mismatchedOverlappingTcpSegmentDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "mismatchedOverlappingTcpSegmentDiscard");
            }
            this.mismatchedOverlappingTcpSegmentDiscard = mismatchedOverlappingTcpSegmentDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder mptcpOptionStrip(String mptcpOptionStrip) {
            if (mptcpOptionStrip == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "mptcpOptionStrip");
            }
            this.mptcpOptionStrip = mptcpOptionStrip;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder nonIpProtocol(GetZoneProtectionProfileListDataNonIpProtocol nonIpProtocol) {
            if (nonIpProtocol == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "nonIpProtocol");
            }
            this.nonIpProtocol = nonIpProtocol;
            return this;
        }
        @CustomType.Setter
        public Builder recordRouteDiscard(Boolean recordRouteDiscard) {
            if (recordRouteDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "recordRouteDiscard");
            }
            this.recordRouteDiscard = recordRouteDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder rejectNonSynTcp(String rejectNonSynTcp) {
            if (rejectNonSynTcp == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "rejectNonSynTcp");
            }
            this.rejectNonSynTcp = rejectNonSynTcp;
            return this;
        }
        @CustomType.Setter
        public Builder scanWhiteLists(List<GetZoneProtectionProfileListDataScanWhiteList> scanWhiteLists) {
            if (scanWhiteLists == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "scanWhiteLists");
            }
            this.scanWhiteLists = scanWhiteLists;
            return this;
        }
        public Builder scanWhiteLists(GetZoneProtectionProfileListDataScanWhiteList... scanWhiteLists) {
            return scanWhiteLists(List.of(scanWhiteLists));
        }
        @CustomType.Setter
        public Builder scans(List<GetZoneProtectionProfileListDataScan> scans) {
            if (scans == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "scans");
            }
            this.scans = scans;
            return this;
        }
        public Builder scans(GetZoneProtectionProfileListDataScan... scans) {
            return scans(List.of(scans));
        }
        @CustomType.Setter
        public Builder securityDiscard(Boolean securityDiscard) {
            if (securityDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "securityDiscard");
            }
            this.securityDiscard = securityDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder snippet(String snippet) {
            if (snippet == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "snippet");
            }
            this.snippet = snippet;
            return this;
        }
        @CustomType.Setter
        public Builder spoofedIpDiscard(Boolean spoofedIpDiscard) {
            if (spoofedIpDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "spoofedIpDiscard");
            }
            this.spoofedIpDiscard = spoofedIpDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder streamIdDiscard(Boolean streamIdDiscard) {
            if (streamIdDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "streamIdDiscard");
            }
            this.streamIdDiscard = streamIdDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder strictIpCheck(Boolean strictIpCheck) {
            if (strictIpCheck == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "strictIpCheck");
            }
            this.strictIpCheck = strictIpCheck;
            return this;
        }
        @CustomType.Setter
        public Builder strictSourceRoutingDiscard(Boolean strictSourceRoutingDiscard) {
            if (strictSourceRoutingDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "strictSourceRoutingDiscard");
            }
            this.strictSourceRoutingDiscard = strictSourceRoutingDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder suppressIcmpNeedfrag(Boolean suppressIcmpNeedfrag) {
            if (suppressIcmpNeedfrag == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "suppressIcmpNeedfrag");
            }
            this.suppressIcmpNeedfrag = suppressIcmpNeedfrag;
            return this;
        }
        @CustomType.Setter
        public Builder suppressIcmpTimeexceeded(Boolean suppressIcmpTimeexceeded) {
            if (suppressIcmpTimeexceeded == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "suppressIcmpTimeexceeded");
            }
            this.suppressIcmpTimeexceeded = suppressIcmpTimeexceeded;
            return this;
        }
        @CustomType.Setter
        public Builder tcpFastOpenAndDataStrip(Boolean tcpFastOpenAndDataStrip) {
            if (tcpFastOpenAndDataStrip == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tcpFastOpenAndDataStrip");
            }
            this.tcpFastOpenAndDataStrip = tcpFastOpenAndDataStrip;
            return this;
        }
        @CustomType.Setter
        public Builder tcpHandshakeDiscard(Boolean tcpHandshakeDiscard) {
            if (tcpHandshakeDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tcpHandshakeDiscard");
            }
            this.tcpHandshakeDiscard = tcpHandshakeDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder tcpSynWithDataDiscard(Boolean tcpSynWithDataDiscard) {
            if (tcpSynWithDataDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tcpSynWithDataDiscard");
            }
            this.tcpSynWithDataDiscard = tcpSynWithDataDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder tcpSynackWithDataDiscard(Boolean tcpSynackWithDataDiscard) {
            if (tcpSynackWithDataDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tcpSynackWithDataDiscard");
            }
            this.tcpSynackWithDataDiscard = tcpSynackWithDataDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder tcpTimestampStrip(Boolean tcpTimestampStrip) {
            if (tcpTimestampStrip == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tcpTimestampStrip");
            }
            this.tcpTimestampStrip = tcpTimestampStrip;
            return this;
        }
        @CustomType.Setter
        public Builder tfid(String tfid) {
            if (tfid == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "tfid");
            }
            this.tfid = tfid;
            return this;
        }
        @CustomType.Setter
        public Builder timestampDiscard(Boolean timestampDiscard) {
            if (timestampDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "timestampDiscard");
            }
            this.timestampDiscard = timestampDiscard;
            return this;
        }
        @CustomType.Setter
        public Builder unknownOptionDiscard(Boolean unknownOptionDiscard) {
            if (unknownOptionDiscard == null) {
              throw new MissingRequiredPropertyException("GetZoneProtectionProfileListData", "unknownOptionDiscard");
            }
            this.unknownOptionDiscard = unknownOptionDiscard;
            return this;
        }
        public GetZoneProtectionProfileListData build() {
            final var _resultValue = new GetZoneProtectionProfileListData();
            _resultValue.asymmetricPath = asymmetricPath;
            _resultValue.description = description;
            _resultValue.device = device;
            _resultValue.discardIcmpEmbeddedError = discardIcmpEmbeddedError;
            _resultValue.flood = flood;
            _resultValue.folder = folder;
            _resultValue.fragmentedTrafficDiscard = fragmentedTrafficDiscard;
            _resultValue.icmpFragDiscard = icmpFragDiscard;
            _resultValue.icmpLargePacketDiscard = icmpLargePacketDiscard;
            _resultValue.icmpPingZeroIdDiscard = icmpPingZeroIdDiscard;
            _resultValue.id = id;
            _resultValue.ipv6 = ipv6;
            _resultValue.l2SecGroupTagProtection = l2SecGroupTagProtection;
            _resultValue.looseSourceRoutingDiscard = looseSourceRoutingDiscard;
            _resultValue.malformedOptionDiscard = malformedOptionDiscard;
            _resultValue.mismatchedOverlappingTcpSegmentDiscard = mismatchedOverlappingTcpSegmentDiscard;
            _resultValue.mptcpOptionStrip = mptcpOptionStrip;
            _resultValue.name = name;
            _resultValue.nonIpProtocol = nonIpProtocol;
            _resultValue.recordRouteDiscard = recordRouteDiscard;
            _resultValue.rejectNonSynTcp = rejectNonSynTcp;
            _resultValue.scanWhiteLists = scanWhiteLists;
            _resultValue.scans = scans;
            _resultValue.securityDiscard = securityDiscard;
            _resultValue.snippet = snippet;
            _resultValue.spoofedIpDiscard = spoofedIpDiscard;
            _resultValue.streamIdDiscard = streamIdDiscard;
            _resultValue.strictIpCheck = strictIpCheck;
            _resultValue.strictSourceRoutingDiscard = strictSourceRoutingDiscard;
            _resultValue.suppressIcmpNeedfrag = suppressIcmpNeedfrag;
            _resultValue.suppressIcmpTimeexceeded = suppressIcmpTimeexceeded;
            _resultValue.tcpFastOpenAndDataStrip = tcpFastOpenAndDataStrip;
            _resultValue.tcpHandshakeDiscard = tcpHandshakeDiscard;
            _resultValue.tcpSynWithDataDiscard = tcpSynWithDataDiscard;
            _resultValue.tcpSynackWithDataDiscard = tcpSynackWithDataDiscard;
            _resultValue.tcpTimestampStrip = tcpTimestampStrip;
            _resultValue.tfid = tfid;
            _resultValue.timestampDiscard = timestampDiscard;
            _resultValue.unknownOptionDiscard = unknownOptionDiscard;
            return _resultValue;
        }
    }
}
