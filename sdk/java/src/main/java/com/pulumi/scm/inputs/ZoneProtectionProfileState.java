// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.scm.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.scm.inputs.ZoneProtectionProfileFloodArgs;
import com.pulumi.scm.inputs.ZoneProtectionProfileIpv6Args;
import com.pulumi.scm.inputs.ZoneProtectionProfileL2SecGroupTagProtectionArgs;
import com.pulumi.scm.inputs.ZoneProtectionProfileNonIpProtocolArgs;
import com.pulumi.scm.inputs.ZoneProtectionProfileScanArgs;
import com.pulumi.scm.inputs.ZoneProtectionProfileScanWhiteListArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ZoneProtectionProfileState extends com.pulumi.resources.ResourceArgs {

    public static final ZoneProtectionProfileState Empty = new ZoneProtectionProfileState();

    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    @Import(name="asymmetricPath")
    private @Nullable Output<String> asymmetricPath;

    /**
     * @return Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    public Optional<Output<String>> asymmetricPath() {
        return Optional.ofNullable(this.asymmetricPath);
    }

    /**
     * The description of the profile
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the profile
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * The device in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    @Import(name="device")
    private @Nullable Output<String> device;

    /**
     * @return The device in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public Optional<Output<String>> device() {
        return Optional.ofNullable(this.device);
    }

    /**
     * Discard ICMP packets that are embedded with an error message.
     * 
     */
    @Import(name="discardIcmpEmbeddedError")
    private @Nullable Output<Boolean> discardIcmpEmbeddedError;

    /**
     * @return Discard ICMP packets that are embedded with an error message.
     * 
     */
    public Optional<Output<Boolean>> discardIcmpEmbeddedError() {
        return Optional.ofNullable(this.discardIcmpEmbeddedError);
    }

    /**
     * Flood
     * 
     */
    @Import(name="flood")
    private @Nullable Output<ZoneProtectionProfileFloodArgs> flood;

    /**
     * @return Flood
     * 
     */
    public Optional<Output<ZoneProtectionProfileFloodArgs>> flood() {
        return Optional.ofNullable(this.flood);
    }

    /**
     * The folder in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    @Import(name="folder")
    private @Nullable Output<String> folder;

    /**
     * @return The folder in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public Optional<Output<String>> folder() {
        return Optional.ofNullable(this.folder);
    }

    /**
     * Discard fragmented IP packets.
     * 
     */
    @Import(name="fragmentedTrafficDiscard")
    private @Nullable Output<Boolean> fragmentedTrafficDiscard;

    /**
     * @return Discard fragmented IP packets.
     * 
     */
    public Optional<Output<Boolean>> fragmentedTrafficDiscard() {
        return Optional.ofNullable(this.fragmentedTrafficDiscard);
    }

    /**
     * Discard packets that consist of ICMP fragments.
     * 
     */
    @Import(name="icmpFragDiscard")
    private @Nullable Output<Boolean> icmpFragDiscard;

    /**
     * @return Discard packets that consist of ICMP fragments.
     * 
     */
    public Optional<Output<Boolean>> icmpFragDiscard() {
        return Optional.ofNullable(this.icmpFragDiscard);
    }

    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    @Import(name="icmpLargePacketDiscard")
    private @Nullable Output<Boolean> icmpLargePacketDiscard;

    /**
     * @return Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    public Optional<Output<Boolean>> icmpLargePacketDiscard() {
        return Optional.ofNullable(this.icmpLargePacketDiscard);
    }

    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    @Import(name="icmpPingZeroIdDiscard")
    private @Nullable Output<Boolean> icmpPingZeroIdDiscard;

    /**
     * @return Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    public Optional<Output<Boolean>> icmpPingZeroIdDiscard() {
        return Optional.ofNullable(this.icmpPingZeroIdDiscard);
    }

    /**
     * Ipv6
     * 
     */
    @Import(name="ipv6")
    private @Nullable Output<ZoneProtectionProfileIpv6Args> ipv6;

    /**
     * @return Ipv6
     * 
     */
    public Optional<Output<ZoneProtectionProfileIpv6Args>> ipv6() {
        return Optional.ofNullable(this.ipv6);
    }

    /**
     * L2 sec group tag protection
     * 
     */
    @Import(name="l2SecGroupTagProtection")
    private @Nullable Output<ZoneProtectionProfileL2SecGroupTagProtectionArgs> l2SecGroupTagProtection;

    /**
     * @return L2 sec group tag protection
     * 
     */
    public Optional<Output<ZoneProtectionProfileL2SecGroupTagProtectionArgs>> l2SecGroupTagProtection() {
        return Optional.ofNullable(this.l2SecGroupTagProtection);
    }

    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    @Import(name="looseSourceRoutingDiscard")
    private @Nullable Output<Boolean> looseSourceRoutingDiscard;

    /**
     * @return Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    public Optional<Output<Boolean>> looseSourceRoutingDiscard() {
        return Optional.ofNullable(this.looseSourceRoutingDiscard);
    }

    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    @Import(name="malformedOptionDiscard")
    private @Nullable Output<Boolean> malformedOptionDiscard;

    /**
     * @return Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    public Optional<Output<Boolean>> malformedOptionDiscard() {
        return Optional.ofNullable(this.malformedOptionDiscard);
    }

    /**
     * Drop packets with mismatched overlapping TCP segments.
     * 
     */
    @Import(name="mismatchedOverlappingTcpSegmentDiscard")
    private @Nullable Output<Boolean> mismatchedOverlappingTcpSegmentDiscard;

    /**
     * @return Drop packets with mismatched overlapping TCP segments.
     * 
     */
    public Optional<Output<Boolean>> mismatchedOverlappingTcpSegmentDiscard() {
        return Optional.ofNullable(this.mismatchedOverlappingTcpSegmentDiscard);
    }

    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    @Import(name="mptcpOptionStrip")
    private @Nullable Output<String> mptcpOptionStrip;

    /**
     * @return MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    public Optional<Output<String>> mptcpOptionStrip() {
        return Optional.ofNullable(this.mptcpOptionStrip);
    }

    /**
     * The profile name
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The profile name
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Non ip protocol
     * 
     */
    @Import(name="nonIpProtocol")
    private @Nullable Output<ZoneProtectionProfileNonIpProtocolArgs> nonIpProtocol;

    /**
     * @return Non ip protocol
     * 
     */
    public Optional<Output<ZoneProtectionProfileNonIpProtocolArgs>> nonIpProtocol() {
        return Optional.ofNullable(this.nonIpProtocol);
    }

    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    @Import(name="recordRouteDiscard")
    private @Nullable Output<Boolean> recordRouteDiscard;

    /**
     * @return Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    public Optional<Output<Boolean>> recordRouteDiscard() {
        return Optional.ofNullable(this.recordRouteDiscard);
    }

    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    @Import(name="rejectNonSynTcp")
    private @Nullable Output<String> rejectNonSynTcp;

    /**
     * @return Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    public Optional<Output<String>> rejectNonSynTcp() {
        return Optional.ofNullable(this.rejectNonSynTcp);
    }

    /**
     * Scan white list
     * 
     */
    @Import(name="scanWhiteLists")
    private @Nullable Output<List<ZoneProtectionProfileScanWhiteListArgs>> scanWhiteLists;

    /**
     * @return Scan white list
     * 
     */
    public Optional<Output<List<ZoneProtectionProfileScanWhiteListArgs>>> scanWhiteLists() {
        return Optional.ofNullable(this.scanWhiteLists);
    }

    /**
     * Scan
     * 
     */
    @Import(name="scans")
    private @Nullable Output<List<ZoneProtectionProfileScanArgs>> scans;

    /**
     * @return Scan
     * 
     */
    public Optional<Output<List<ZoneProtectionProfileScanArgs>>> scans() {
        return Optional.ofNullable(this.scans);
    }

    /**
     * Discard packets if the security option is defined.
     * 
     */
    @Import(name="securityDiscard")
    private @Nullable Output<Boolean> securityDiscard;

    /**
     * @return Discard packets if the security option is defined.
     * 
     */
    public Optional<Output<Boolean>> securityDiscard() {
        return Optional.ofNullable(this.securityDiscard);
    }

    /**
     * The snippet in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    @Import(name="snippet")
    private @Nullable Output<String> snippet;

    /**
     * @return The snippet in which the resource is defined
     * 
     * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
     * 
     */
    public Optional<Output<String>> snippet() {
        return Optional.ofNullable(this.snippet);
    }

    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    @Import(name="spoofedIpDiscard")
    private @Nullable Output<Boolean> spoofedIpDiscard;

    /**
     * @return Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    public Optional<Output<Boolean>> spoofedIpDiscard() {
        return Optional.ofNullable(this.spoofedIpDiscard);
    }

    /**
     * Discard packets if the Stream ID option is defined.
     * 
     */
    @Import(name="streamIdDiscard")
    private @Nullable Output<Boolean> streamIdDiscard;

    /**
     * @return Discard packets if the Stream ID option is defined.
     * 
     */
    public Optional<Output<Boolean>> streamIdDiscard() {
        return Optional.ofNullable(this.streamIdDiscard);
    }

    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    @Import(name="strictIpCheck")
    private @Nullable Output<Boolean> strictIpCheck;

    /**
     * @return Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    public Optional<Output<Boolean>> strictIpCheck() {
        return Optional.ofNullable(this.strictIpCheck);
    }

    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    @Import(name="strictSourceRoutingDiscard")
    private @Nullable Output<Boolean> strictSourceRoutingDiscard;

    /**
     * @return Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    public Optional<Output<Boolean>> strictSourceRoutingDiscard() {
        return Optional.ofNullable(this.strictSourceRoutingDiscard);
    }

    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    @Import(name="suppressIcmpNeedfrag")
    private @Nullable Output<Boolean> suppressIcmpNeedfrag;

    /**
     * @return Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    public Optional<Output<Boolean>> suppressIcmpNeedfrag() {
        return Optional.ofNullable(this.suppressIcmpNeedfrag);
    }

    /**
     * Stop sending ICMP TTL expired messages.
     * 
     */
    @Import(name="suppressIcmpTimeexceeded")
    private @Nullable Output<Boolean> suppressIcmpTimeexceeded;

    /**
     * @return Stop sending ICMP TTL expired messages.
     * 
     */
    public Optional<Output<Boolean>> suppressIcmpTimeexceeded() {
        return Optional.ofNullable(this.suppressIcmpTimeexceeded);
    }

    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    @Import(name="tcpFastOpenAndDataStrip")
    private @Nullable Output<Boolean> tcpFastOpenAndDataStrip;

    /**
     * @return Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    public Optional<Output<Boolean>> tcpFastOpenAndDataStrip() {
        return Optional.ofNullable(this.tcpFastOpenAndDataStrip);
    }

    /**
     * Drop packets with split handshakes.
     * 
     */
    @Import(name="tcpHandshakeDiscard")
    private @Nullable Output<Boolean> tcpHandshakeDiscard;

    /**
     * @return Drop packets with split handshakes.
     * 
     */
    public Optional<Output<Boolean>> tcpHandshakeDiscard() {
        return Optional.ofNullable(this.tcpHandshakeDiscard);
    }

    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    @Import(name="tcpSynWithDataDiscard")
    private @Nullable Output<Boolean> tcpSynWithDataDiscard;

    /**
     * @return Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    public Optional<Output<Boolean>> tcpSynWithDataDiscard() {
        return Optional.ofNullable(this.tcpSynWithDataDiscard);
    }

    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    @Import(name="tcpSynackWithDataDiscard")
    private @Nullable Output<Boolean> tcpSynackWithDataDiscard;

    /**
     * @return Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    public Optional<Output<Boolean>> tcpSynackWithDataDiscard() {
        return Optional.ofNullable(this.tcpSynackWithDataDiscard);
    }

    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    @Import(name="tcpTimestampStrip")
    private @Nullable Output<Boolean> tcpTimestampStrip;

    /**
     * @return Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    public Optional<Output<Boolean>> tcpTimestampStrip() {
        return Optional.ofNullable(this.tcpTimestampStrip);
    }

    @Import(name="tfid")
    private @Nullable Output<String> tfid;

    public Optional<Output<String>> tfid() {
        return Optional.ofNullable(this.tfid);
    }

    /**
     * Discard packets with the Timestamp IP option set.
     * 
     */
    @Import(name="timestampDiscard")
    private @Nullable Output<Boolean> timestampDiscard;

    /**
     * @return Discard packets with the Timestamp IP option set.
     * 
     */
    public Optional<Output<Boolean>> timestampDiscard() {
        return Optional.ofNullable(this.timestampDiscard);
    }

    /**
     * Discard packets if the class and number are unknown.
     * 
     */
    @Import(name="unknownOptionDiscard")
    private @Nullable Output<Boolean> unknownOptionDiscard;

    /**
     * @return Discard packets if the class and number are unknown.
     * 
     */
    public Optional<Output<Boolean>> unknownOptionDiscard() {
        return Optional.ofNullable(this.unknownOptionDiscard);
    }

    private ZoneProtectionProfileState() {}

    private ZoneProtectionProfileState(ZoneProtectionProfileState $) {
        this.asymmetricPath = $.asymmetricPath;
        this.description = $.description;
        this.device = $.device;
        this.discardIcmpEmbeddedError = $.discardIcmpEmbeddedError;
        this.flood = $.flood;
        this.folder = $.folder;
        this.fragmentedTrafficDiscard = $.fragmentedTrafficDiscard;
        this.icmpFragDiscard = $.icmpFragDiscard;
        this.icmpLargePacketDiscard = $.icmpLargePacketDiscard;
        this.icmpPingZeroIdDiscard = $.icmpPingZeroIdDiscard;
        this.ipv6 = $.ipv6;
        this.l2SecGroupTagProtection = $.l2SecGroupTagProtection;
        this.looseSourceRoutingDiscard = $.looseSourceRoutingDiscard;
        this.malformedOptionDiscard = $.malformedOptionDiscard;
        this.mismatchedOverlappingTcpSegmentDiscard = $.mismatchedOverlappingTcpSegmentDiscard;
        this.mptcpOptionStrip = $.mptcpOptionStrip;
        this.name = $.name;
        this.nonIpProtocol = $.nonIpProtocol;
        this.recordRouteDiscard = $.recordRouteDiscard;
        this.rejectNonSynTcp = $.rejectNonSynTcp;
        this.scanWhiteLists = $.scanWhiteLists;
        this.scans = $.scans;
        this.securityDiscard = $.securityDiscard;
        this.snippet = $.snippet;
        this.spoofedIpDiscard = $.spoofedIpDiscard;
        this.streamIdDiscard = $.streamIdDiscard;
        this.strictIpCheck = $.strictIpCheck;
        this.strictSourceRoutingDiscard = $.strictSourceRoutingDiscard;
        this.suppressIcmpNeedfrag = $.suppressIcmpNeedfrag;
        this.suppressIcmpTimeexceeded = $.suppressIcmpTimeexceeded;
        this.tcpFastOpenAndDataStrip = $.tcpFastOpenAndDataStrip;
        this.tcpHandshakeDiscard = $.tcpHandshakeDiscard;
        this.tcpSynWithDataDiscard = $.tcpSynWithDataDiscard;
        this.tcpSynackWithDataDiscard = $.tcpSynackWithDataDiscard;
        this.tcpTimestampStrip = $.tcpTimestampStrip;
        this.tfid = $.tfid;
        this.timestampDiscard = $.timestampDiscard;
        this.unknownOptionDiscard = $.unknownOptionDiscard;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ZoneProtectionProfileState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ZoneProtectionProfileState $;

        public Builder() {
            $ = new ZoneProtectionProfileState();
        }

        public Builder(ZoneProtectionProfileState defaults) {
            $ = new ZoneProtectionProfileState(Objects.requireNonNull(defaults));
        }

        /**
         * @param asymmetricPath Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
         * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
         * * `drop` — Drop packets that contain an asymmetric path.
         * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
         * 
         * @return builder
         * 
         */
        public Builder asymmetricPath(@Nullable Output<String> asymmetricPath) {
            $.asymmetricPath = asymmetricPath;
            return this;
        }

        /**
         * @param asymmetricPath Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
         * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
         * * `drop` — Drop packets that contain an asymmetric path.
         * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
         * 
         * @return builder
         * 
         */
        public Builder asymmetricPath(String asymmetricPath) {
            return asymmetricPath(Output.of(asymmetricPath));
        }

        /**
         * @param description The description of the profile
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the profile
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param device The device in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder device(@Nullable Output<String> device) {
            $.device = device;
            return this;
        }

        /**
         * @param device The device in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder device(String device) {
            return device(Output.of(device));
        }

        /**
         * @param discardIcmpEmbeddedError Discard ICMP packets that are embedded with an error message.
         * 
         * @return builder
         * 
         */
        public Builder discardIcmpEmbeddedError(@Nullable Output<Boolean> discardIcmpEmbeddedError) {
            $.discardIcmpEmbeddedError = discardIcmpEmbeddedError;
            return this;
        }

        /**
         * @param discardIcmpEmbeddedError Discard ICMP packets that are embedded with an error message.
         * 
         * @return builder
         * 
         */
        public Builder discardIcmpEmbeddedError(Boolean discardIcmpEmbeddedError) {
            return discardIcmpEmbeddedError(Output.of(discardIcmpEmbeddedError));
        }

        /**
         * @param flood Flood
         * 
         * @return builder
         * 
         */
        public Builder flood(@Nullable Output<ZoneProtectionProfileFloodArgs> flood) {
            $.flood = flood;
            return this;
        }

        /**
         * @param flood Flood
         * 
         * @return builder
         * 
         */
        public Builder flood(ZoneProtectionProfileFloodArgs flood) {
            return flood(Output.of(flood));
        }

        /**
         * @param folder The folder in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder folder(@Nullable Output<String> folder) {
            $.folder = folder;
            return this;
        }

        /**
         * @param folder The folder in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder folder(String folder) {
            return folder(Output.of(folder));
        }

        /**
         * @param fragmentedTrafficDiscard Discard fragmented IP packets.
         * 
         * @return builder
         * 
         */
        public Builder fragmentedTrafficDiscard(@Nullable Output<Boolean> fragmentedTrafficDiscard) {
            $.fragmentedTrafficDiscard = fragmentedTrafficDiscard;
            return this;
        }

        /**
         * @param fragmentedTrafficDiscard Discard fragmented IP packets.
         * 
         * @return builder
         * 
         */
        public Builder fragmentedTrafficDiscard(Boolean fragmentedTrafficDiscard) {
            return fragmentedTrafficDiscard(Output.of(fragmentedTrafficDiscard));
        }

        /**
         * @param icmpFragDiscard Discard packets that consist of ICMP fragments.
         * 
         * @return builder
         * 
         */
        public Builder icmpFragDiscard(@Nullable Output<Boolean> icmpFragDiscard) {
            $.icmpFragDiscard = icmpFragDiscard;
            return this;
        }

        /**
         * @param icmpFragDiscard Discard packets that consist of ICMP fragments.
         * 
         * @return builder
         * 
         */
        public Builder icmpFragDiscard(Boolean icmpFragDiscard) {
            return icmpFragDiscard(Output.of(icmpFragDiscard));
        }

        /**
         * @param icmpLargePacketDiscard Discard ICMP packets that are larger than 1024 bytes.
         * 
         * @return builder
         * 
         */
        public Builder icmpLargePacketDiscard(@Nullable Output<Boolean> icmpLargePacketDiscard) {
            $.icmpLargePacketDiscard = icmpLargePacketDiscard;
            return this;
        }

        /**
         * @param icmpLargePacketDiscard Discard ICMP packets that are larger than 1024 bytes.
         * 
         * @return builder
         * 
         */
        public Builder icmpLargePacketDiscard(Boolean icmpLargePacketDiscard) {
            return icmpLargePacketDiscard(Output.of(icmpLargePacketDiscard));
        }

        /**
         * @param icmpPingZeroIdDiscard Discard packets if the ICMP ping packet has an identifier value of 0.
         * 
         * @return builder
         * 
         */
        public Builder icmpPingZeroIdDiscard(@Nullable Output<Boolean> icmpPingZeroIdDiscard) {
            $.icmpPingZeroIdDiscard = icmpPingZeroIdDiscard;
            return this;
        }

        /**
         * @param icmpPingZeroIdDiscard Discard packets if the ICMP ping packet has an identifier value of 0.
         * 
         * @return builder
         * 
         */
        public Builder icmpPingZeroIdDiscard(Boolean icmpPingZeroIdDiscard) {
            return icmpPingZeroIdDiscard(Output.of(icmpPingZeroIdDiscard));
        }

        /**
         * @param ipv6 Ipv6
         * 
         * @return builder
         * 
         */
        public Builder ipv6(@Nullable Output<ZoneProtectionProfileIpv6Args> ipv6) {
            $.ipv6 = ipv6;
            return this;
        }

        /**
         * @param ipv6 Ipv6
         * 
         * @return builder
         * 
         */
        public Builder ipv6(ZoneProtectionProfileIpv6Args ipv6) {
            return ipv6(Output.of(ipv6));
        }

        /**
         * @param l2SecGroupTagProtection L2 sec group tag protection
         * 
         * @return builder
         * 
         */
        public Builder l2SecGroupTagProtection(@Nullable Output<ZoneProtectionProfileL2SecGroupTagProtectionArgs> l2SecGroupTagProtection) {
            $.l2SecGroupTagProtection = l2SecGroupTagProtection;
            return this;
        }

        /**
         * @param l2SecGroupTagProtection L2 sec group tag protection
         * 
         * @return builder
         * 
         */
        public Builder l2SecGroupTagProtection(ZoneProtectionProfileL2SecGroupTagProtectionArgs l2SecGroupTagProtection) {
            return l2SecGroupTagProtection(Output.of(l2SecGroupTagProtection));
        }

        /**
         * @param looseSourceRoutingDiscard Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
         * 
         * @return builder
         * 
         */
        public Builder looseSourceRoutingDiscard(@Nullable Output<Boolean> looseSourceRoutingDiscard) {
            $.looseSourceRoutingDiscard = looseSourceRoutingDiscard;
            return this;
        }

        /**
         * @param looseSourceRoutingDiscard Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
         * 
         * @return builder
         * 
         */
        public Builder looseSourceRoutingDiscard(Boolean looseSourceRoutingDiscard) {
            return looseSourceRoutingDiscard(Output.of(looseSourceRoutingDiscard));
        }

        /**
         * @param malformedOptionDiscard Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
         * 
         * @return builder
         * 
         */
        public Builder malformedOptionDiscard(@Nullable Output<Boolean> malformedOptionDiscard) {
            $.malformedOptionDiscard = malformedOptionDiscard;
            return this;
        }

        /**
         * @param malformedOptionDiscard Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
         * 
         * @return builder
         * 
         */
        public Builder malformedOptionDiscard(Boolean malformedOptionDiscard) {
            return malformedOptionDiscard(Output.of(malformedOptionDiscard));
        }

        /**
         * @param mismatchedOverlappingTcpSegmentDiscard Drop packets with mismatched overlapping TCP segments.
         * 
         * @return builder
         * 
         */
        public Builder mismatchedOverlappingTcpSegmentDiscard(@Nullable Output<Boolean> mismatchedOverlappingTcpSegmentDiscard) {
            $.mismatchedOverlappingTcpSegmentDiscard = mismatchedOverlappingTcpSegmentDiscard;
            return this;
        }

        /**
         * @param mismatchedOverlappingTcpSegmentDiscard Drop packets with mismatched overlapping TCP segments.
         * 
         * @return builder
         * 
         */
        public Builder mismatchedOverlappingTcpSegmentDiscard(Boolean mismatchedOverlappingTcpSegmentDiscard) {
            return mismatchedOverlappingTcpSegmentDiscard(Output.of(mismatchedOverlappingTcpSegmentDiscard));
        }

        /**
         * @param mptcpOptionStrip MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
         * * `no` — Enable MPTCP support (do not strip the MPTCP option).
         * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
         * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
         * 
         * @return builder
         * 
         */
        public Builder mptcpOptionStrip(@Nullable Output<String> mptcpOptionStrip) {
            $.mptcpOptionStrip = mptcpOptionStrip;
            return this;
        }

        /**
         * @param mptcpOptionStrip MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
         * * `no` — Enable MPTCP support (do not strip the MPTCP option).
         * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
         * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
         * 
         * @return builder
         * 
         */
        public Builder mptcpOptionStrip(String mptcpOptionStrip) {
            return mptcpOptionStrip(Output.of(mptcpOptionStrip));
        }

        /**
         * @param name The profile name
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The profile name
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nonIpProtocol Non ip protocol
         * 
         * @return builder
         * 
         */
        public Builder nonIpProtocol(@Nullable Output<ZoneProtectionProfileNonIpProtocolArgs> nonIpProtocol) {
            $.nonIpProtocol = nonIpProtocol;
            return this;
        }

        /**
         * @param nonIpProtocol Non ip protocol
         * 
         * @return builder
         * 
         */
        public Builder nonIpProtocol(ZoneProtectionProfileNonIpProtocolArgs nonIpProtocol) {
            return nonIpProtocol(Output.of(nonIpProtocol));
        }

        /**
         * @param recordRouteDiscard Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
         * 
         * @return builder
         * 
         */
        public Builder recordRouteDiscard(@Nullable Output<Boolean> recordRouteDiscard) {
            $.recordRouteDiscard = recordRouteDiscard;
            return this;
        }

        /**
         * @param recordRouteDiscard Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
         * 
         * @return builder
         * 
         */
        public Builder recordRouteDiscard(Boolean recordRouteDiscard) {
            return recordRouteDiscard(Output.of(recordRouteDiscard));
        }

        /**
         * @param rejectNonSynTcp Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
         * * `global` — Use system-wide setting that is assigned through the CLI.
         * * `yes` — Reject non-SYN TCP.
         * * `no` — Accept non-SYN TCP.
         * 
         * @return builder
         * 
         */
        public Builder rejectNonSynTcp(@Nullable Output<String> rejectNonSynTcp) {
            $.rejectNonSynTcp = rejectNonSynTcp;
            return this;
        }

        /**
         * @param rejectNonSynTcp Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
         * * `global` — Use system-wide setting that is assigned through the CLI.
         * * `yes` — Reject non-SYN TCP.
         * * `no` — Accept non-SYN TCP.
         * 
         * @return builder
         * 
         */
        public Builder rejectNonSynTcp(String rejectNonSynTcp) {
            return rejectNonSynTcp(Output.of(rejectNonSynTcp));
        }

        /**
         * @param scanWhiteLists Scan white list
         * 
         * @return builder
         * 
         */
        public Builder scanWhiteLists(@Nullable Output<List<ZoneProtectionProfileScanWhiteListArgs>> scanWhiteLists) {
            $.scanWhiteLists = scanWhiteLists;
            return this;
        }

        /**
         * @param scanWhiteLists Scan white list
         * 
         * @return builder
         * 
         */
        public Builder scanWhiteLists(List<ZoneProtectionProfileScanWhiteListArgs> scanWhiteLists) {
            return scanWhiteLists(Output.of(scanWhiteLists));
        }

        /**
         * @param scanWhiteLists Scan white list
         * 
         * @return builder
         * 
         */
        public Builder scanWhiteLists(ZoneProtectionProfileScanWhiteListArgs... scanWhiteLists) {
            return scanWhiteLists(List.of(scanWhiteLists));
        }

        /**
         * @param scans Scan
         * 
         * @return builder
         * 
         */
        public Builder scans(@Nullable Output<List<ZoneProtectionProfileScanArgs>> scans) {
            $.scans = scans;
            return this;
        }

        /**
         * @param scans Scan
         * 
         * @return builder
         * 
         */
        public Builder scans(List<ZoneProtectionProfileScanArgs> scans) {
            return scans(Output.of(scans));
        }

        /**
         * @param scans Scan
         * 
         * @return builder
         * 
         */
        public Builder scans(ZoneProtectionProfileScanArgs... scans) {
            return scans(List.of(scans));
        }

        /**
         * @param securityDiscard Discard packets if the security option is defined.
         * 
         * @return builder
         * 
         */
        public Builder securityDiscard(@Nullable Output<Boolean> securityDiscard) {
            $.securityDiscard = securityDiscard;
            return this;
        }

        /**
         * @param securityDiscard Discard packets if the security option is defined.
         * 
         * @return builder
         * 
         */
        public Builder securityDiscard(Boolean securityDiscard) {
            return securityDiscard(Output.of(securityDiscard));
        }

        /**
         * @param snippet The snippet in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder snippet(@Nullable Output<String> snippet) {
            $.snippet = snippet;
            return this;
        }

        /**
         * @param snippet The snippet in which the resource is defined
         * 
         * &gt; ℹ️ **Note:** You must specify exactly one of `device`, `folder`, and `snippet`.
         * 
         * @return builder
         * 
         */
        public Builder snippet(String snippet) {
            return snippet(Output.of(snippet));
        }

        /**
         * @param spoofedIpDiscard Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
         * 
         * @return builder
         * 
         */
        public Builder spoofedIpDiscard(@Nullable Output<Boolean> spoofedIpDiscard) {
            $.spoofedIpDiscard = spoofedIpDiscard;
            return this;
        }

        /**
         * @param spoofedIpDiscard Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
         * 
         * @return builder
         * 
         */
        public Builder spoofedIpDiscard(Boolean spoofedIpDiscard) {
            return spoofedIpDiscard(Output.of(spoofedIpDiscard));
        }

        /**
         * @param streamIdDiscard Discard packets if the Stream ID option is defined.
         * 
         * @return builder
         * 
         */
        public Builder streamIdDiscard(@Nullable Output<Boolean> streamIdDiscard) {
            $.streamIdDiscard = streamIdDiscard;
            return this;
        }

        /**
         * @param streamIdDiscard Discard packets if the Stream ID option is defined.
         * 
         * @return builder
         * 
         */
        public Builder streamIdDiscard(Boolean streamIdDiscard) {
            return streamIdDiscard(Output.of(streamIdDiscard));
        }

        /**
         * @param strictIpCheck Check that both conditions are true:
         * * The source IP address is not the subnet broadcast IP address of the ingress interface.
         * * The source IP address is routable over the exact ingress interface.
         *   If either condition is not true, discard the packet.
         * 
         * @return builder
         * 
         */
        public Builder strictIpCheck(@Nullable Output<Boolean> strictIpCheck) {
            $.strictIpCheck = strictIpCheck;
            return this;
        }

        /**
         * @param strictIpCheck Check that both conditions are true:
         * * The source IP address is not the subnet broadcast IP address of the ingress interface.
         * * The source IP address is routable over the exact ingress interface.
         *   If either condition is not true, discard the packet.
         * 
         * @return builder
         * 
         */
        public Builder strictIpCheck(Boolean strictIpCheck) {
            return strictIpCheck(Output.of(strictIpCheck));
        }

        /**
         * @param strictSourceRoutingDiscard Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
         * 
         * @return builder
         * 
         */
        public Builder strictSourceRoutingDiscard(@Nullable Output<Boolean> strictSourceRoutingDiscard) {
            $.strictSourceRoutingDiscard = strictSourceRoutingDiscard;
            return this;
        }

        /**
         * @param strictSourceRoutingDiscard Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
         * 
         * @return builder
         * 
         */
        public Builder strictSourceRoutingDiscard(Boolean strictSourceRoutingDiscard) {
            return strictSourceRoutingDiscard(Output.of(strictSourceRoutingDiscard));
        }

        /**
         * @param suppressIcmpNeedfrag Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
         * 
         * @return builder
         * 
         */
        public Builder suppressIcmpNeedfrag(@Nullable Output<Boolean> suppressIcmpNeedfrag) {
            $.suppressIcmpNeedfrag = suppressIcmpNeedfrag;
            return this;
        }

        /**
         * @param suppressIcmpNeedfrag Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
         * 
         * @return builder
         * 
         */
        public Builder suppressIcmpNeedfrag(Boolean suppressIcmpNeedfrag) {
            return suppressIcmpNeedfrag(Output.of(suppressIcmpNeedfrag));
        }

        /**
         * @param suppressIcmpTimeexceeded Stop sending ICMP TTL expired messages.
         * 
         * @return builder
         * 
         */
        public Builder suppressIcmpTimeexceeded(@Nullable Output<Boolean> suppressIcmpTimeexceeded) {
            $.suppressIcmpTimeexceeded = suppressIcmpTimeexceeded;
            return this;
        }

        /**
         * @param suppressIcmpTimeexceeded Stop sending ICMP TTL expired messages.
         * 
         * @return builder
         * 
         */
        public Builder suppressIcmpTimeexceeded(Boolean suppressIcmpTimeexceeded) {
            return suppressIcmpTimeexceeded(Output.of(suppressIcmpTimeexceeded));
        }

        /**
         * @param tcpFastOpenAndDataStrip Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpFastOpenAndDataStrip(@Nullable Output<Boolean> tcpFastOpenAndDataStrip) {
            $.tcpFastOpenAndDataStrip = tcpFastOpenAndDataStrip;
            return this;
        }

        /**
         * @param tcpFastOpenAndDataStrip Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpFastOpenAndDataStrip(Boolean tcpFastOpenAndDataStrip) {
            return tcpFastOpenAndDataStrip(Output.of(tcpFastOpenAndDataStrip));
        }

        /**
         * @param tcpHandshakeDiscard Drop packets with split handshakes.
         * 
         * @return builder
         * 
         */
        public Builder tcpHandshakeDiscard(@Nullable Output<Boolean> tcpHandshakeDiscard) {
            $.tcpHandshakeDiscard = tcpHandshakeDiscard;
            return this;
        }

        /**
         * @param tcpHandshakeDiscard Drop packets with split handshakes.
         * 
         * @return builder
         * 
         */
        public Builder tcpHandshakeDiscard(Boolean tcpHandshakeDiscard) {
            return tcpHandshakeDiscard(Output.of(tcpHandshakeDiscard));
        }

        /**
         * @param tcpSynWithDataDiscard Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpSynWithDataDiscard(@Nullable Output<Boolean> tcpSynWithDataDiscard) {
            $.tcpSynWithDataDiscard = tcpSynWithDataDiscard;
            return this;
        }

        /**
         * @param tcpSynWithDataDiscard Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpSynWithDataDiscard(Boolean tcpSynWithDataDiscard) {
            return tcpSynWithDataDiscard(Output.of(tcpSynWithDataDiscard));
        }

        /**
         * @param tcpSynackWithDataDiscard Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpSynackWithDataDiscard(@Nullable Output<Boolean> tcpSynackWithDataDiscard) {
            $.tcpSynackWithDataDiscard = tcpSynackWithDataDiscard;
            return this;
        }

        /**
         * @param tcpSynackWithDataDiscard Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
         * 
         * @return builder
         * 
         */
        public Builder tcpSynackWithDataDiscard(Boolean tcpSynackWithDataDiscard) {
            return tcpSynackWithDataDiscard(Output.of(tcpSynackWithDataDiscard));
        }

        /**
         * @param tcpTimestampStrip Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
         * 
         * @return builder
         * 
         */
        public Builder tcpTimestampStrip(@Nullable Output<Boolean> tcpTimestampStrip) {
            $.tcpTimestampStrip = tcpTimestampStrip;
            return this;
        }

        /**
         * @param tcpTimestampStrip Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
         * 
         * @return builder
         * 
         */
        public Builder tcpTimestampStrip(Boolean tcpTimestampStrip) {
            return tcpTimestampStrip(Output.of(tcpTimestampStrip));
        }

        public Builder tfid(@Nullable Output<String> tfid) {
            $.tfid = tfid;
            return this;
        }

        public Builder tfid(String tfid) {
            return tfid(Output.of(tfid));
        }

        /**
         * @param timestampDiscard Discard packets with the Timestamp IP option set.
         * 
         * @return builder
         * 
         */
        public Builder timestampDiscard(@Nullable Output<Boolean> timestampDiscard) {
            $.timestampDiscard = timestampDiscard;
            return this;
        }

        /**
         * @param timestampDiscard Discard packets with the Timestamp IP option set.
         * 
         * @return builder
         * 
         */
        public Builder timestampDiscard(Boolean timestampDiscard) {
            return timestampDiscard(Output.of(timestampDiscard));
        }

        /**
         * @param unknownOptionDiscard Discard packets if the class and number are unknown.
         * 
         * @return builder
         * 
         */
        public Builder unknownOptionDiscard(@Nullable Output<Boolean> unknownOptionDiscard) {
            $.unknownOptionDiscard = unknownOptionDiscard;
            return this;
        }

        /**
         * @param unknownOptionDiscard Discard packets if the class and number are unknown.
         * 
         * @return builder
         * 
         */
        public Builder unknownOptionDiscard(Boolean unknownOptionDiscard) {
            return unknownOptionDiscard(Output.of(unknownOptionDiscard));
        }

        public ZoneProtectionProfileState build() {
            return $;
        }
    }

}
