// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.scm;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.scm.Utilities;
import com.pulumi.scm.ZoneProtectionProfileArgs;
import com.pulumi.scm.inputs.ZoneProtectionProfileState;
import com.pulumi.scm.outputs.ZoneProtectionProfileFlood;
import com.pulumi.scm.outputs.ZoneProtectionProfileIpv6;
import com.pulumi.scm.outputs.ZoneProtectionProfileL2SecGroupTagProtection;
import com.pulumi.scm.outputs.ZoneProtectionProfileNonIpProtocol;
import com.pulumi.scm.outputs.ZoneProtectionProfileScan;
import com.pulumi.scm.outputs.ZoneProtectionProfileScanWhiteList;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ZoneProtectionProfile resource
 * 
 */
@ResourceType(type="scm:index/zoneProtectionProfile:ZoneProtectionProfile")
public class ZoneProtectionProfile extends com.pulumi.resources.CustomResource {
    /**
     * Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    @Export(name="asymmetricPath", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> asymmetricPath;

    /**
     * @return Determine whether to drop or bypass packets that contain out-of-sync ACKs or out-of-window sequence numbers:
     * * `global` — Use system-wide setting that is assigned through TCP Settings or the CLI.
     * * `drop` — Drop packets that contain an asymmetric path.
     * * `bypass` — Bypass scanning on packets that contain an asymmetric path.
     * 
     */
    public Output<Optional<String>> asymmetricPath() {
        return Codegen.optional(this.asymmetricPath);
    }
    /**
     * The description of the profile
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the profile
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * The device in which the resource is defined
     * 
     */
    @Export(name="device", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> device;

    /**
     * @return The device in which the resource is defined
     * 
     */
    public Output<Optional<String>> device() {
        return Codegen.optional(this.device);
    }
    /**
     * Discard ICMP packets that are embedded with an error message.
     * 
     */
    @Export(name="discardIcmpEmbeddedError", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> discardIcmpEmbeddedError;

    /**
     * @return Discard ICMP packets that are embedded with an error message.
     * 
     */
    public Output<Optional<Boolean>> discardIcmpEmbeddedError() {
        return Codegen.optional(this.discardIcmpEmbeddedError);
    }
    /**
     * Flood
     * 
     */
    @Export(name="flood", refs={ZoneProtectionProfileFlood.class}, tree="[0]")
    private Output</* @Nullable */ ZoneProtectionProfileFlood> flood;

    /**
     * @return Flood
     * 
     */
    public Output<Optional<ZoneProtectionProfileFlood>> flood() {
        return Codegen.optional(this.flood);
    }
    /**
     * The folder in which the resource is defined
     * 
     */
    @Export(name="folder", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> folder;

    /**
     * @return The folder in which the resource is defined
     * 
     */
    public Output<Optional<String>> folder() {
        return Codegen.optional(this.folder);
    }
    /**
     * Discard fragmented IP packets.
     * 
     */
    @Export(name="fragmentedTrafficDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> fragmentedTrafficDiscard;

    /**
     * @return Discard fragmented IP packets.
     * 
     */
    public Output<Optional<Boolean>> fragmentedTrafficDiscard() {
        return Codegen.optional(this.fragmentedTrafficDiscard);
    }
    /**
     * Discard packets that consist of ICMP fragments.
     * 
     */
    @Export(name="icmpFragDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> icmpFragDiscard;

    /**
     * @return Discard packets that consist of ICMP fragments.
     * 
     */
    public Output<Optional<Boolean>> icmpFragDiscard() {
        return Codegen.optional(this.icmpFragDiscard);
    }
    /**
     * Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    @Export(name="icmpLargePacketDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> icmpLargePacketDiscard;

    /**
     * @return Discard ICMP packets that are larger than 1024 bytes.
     * 
     */
    public Output<Optional<Boolean>> icmpLargePacketDiscard() {
        return Codegen.optional(this.icmpLargePacketDiscard);
    }
    /**
     * Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    @Export(name="icmpPingZeroIdDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> icmpPingZeroIdDiscard;

    /**
     * @return Discard packets if the ICMP ping packet has an identifier value of 0.
     * 
     */
    public Output<Optional<Boolean>> icmpPingZeroIdDiscard() {
        return Codegen.optional(this.icmpPingZeroIdDiscard);
    }
    /**
     * Ipv6
     * 
     */
    @Export(name="ipv6", refs={ZoneProtectionProfileIpv6.class}, tree="[0]")
    private Output</* @Nullable */ ZoneProtectionProfileIpv6> ipv6;

    /**
     * @return Ipv6
     * 
     */
    public Output<Optional<ZoneProtectionProfileIpv6>> ipv6() {
        return Codegen.optional(this.ipv6);
    }
    /**
     * L2 sec group tag protection
     * 
     */
    @Export(name="l2SecGroupTagProtection", refs={ZoneProtectionProfileL2SecGroupTagProtection.class}, tree="[0]")
    private Output</* @Nullable */ ZoneProtectionProfileL2SecGroupTagProtection> l2SecGroupTagProtection;

    /**
     * @return L2 sec group tag protection
     * 
     */
    public Output<Optional<ZoneProtectionProfileL2SecGroupTagProtection>> l2SecGroupTagProtection() {
        return Codegen.optional(this.l2SecGroupTagProtection);
    }
    /**
     * Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    @Export(name="looseSourceRoutingDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> looseSourceRoutingDiscard;

    /**
     * @return Discard packets with the Loose Source Routing IP option set. Loose Source Routing is an option whereby a source of a datagram provides routing information and a gateway or host is allowed to choose any route of a number of intermediate gateways to get the datagram to the next address in the route.
     * 
     */
    public Output<Optional<Boolean>> looseSourceRoutingDiscard() {
        return Codegen.optional(this.looseSourceRoutingDiscard);
    }
    /**
     * Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    @Export(name="malformedOptionDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> malformedOptionDiscard;

    /**
     * @return Discard packets if they have incorrect combinations of class, number, and length based on RFCs 791, 1108, 1393, and 2113.
     * 
     */
    public Output<Optional<Boolean>> malformedOptionDiscard() {
        return Codegen.optional(this.malformedOptionDiscard);
    }
    /**
     * Drop packets with mismatched overlapping TCP segments.
     * 
     */
    @Export(name="mismatchedOverlappingTcpSegmentDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> mismatchedOverlappingTcpSegmentDiscard;

    /**
     * @return Drop packets with mismatched overlapping TCP segments.
     * 
     */
    public Output<Optional<Boolean>> mismatchedOverlappingTcpSegmentDiscard() {
        return Codegen.optional(this.mismatchedOverlappingTcpSegmentDiscard);
    }
    /**
     * MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    @Export(name="mptcpOptionStrip", refs={String.class}, tree="[0]")
    private Output<String> mptcpOptionStrip;

    /**
     * @return MPTCP is an extension of TCP that allows a client to maintain a connection by simultaneously using multiple paths to connect to the destination host. By default, MPTCP support is disabled, based on the global MPTCP setting.  Review or adjust the MPTCP settings for the security zones associated with this profile:
     * * `no` — Enable MPTCP support (do not strip the MPTCP option).
     * * `yes` — Disable MPTCP support (strip the MPTCP option). With this configured, MPTCP connections are converted to standard TCP connections, as MPTCP is backwards compatible with TCP.
     * * `global` — Support MPTCP based on the global MPTCP setting. By default, the global MPTCP setting is set to yes so that MPTCP is disabled (the MPTCP option is stripped from the packet).
     * 
     */
    public Output<String> mptcpOptionStrip() {
        return this.mptcpOptionStrip;
    }
    /**
     * The profile name
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The profile name
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Non ip protocol
     * 
     */
    @Export(name="nonIpProtocol", refs={ZoneProtectionProfileNonIpProtocol.class}, tree="[0]")
    private Output</* @Nullable */ ZoneProtectionProfileNonIpProtocol> nonIpProtocol;

    /**
     * @return Non ip protocol
     * 
     */
    public Output<Optional<ZoneProtectionProfileNonIpProtocol>> nonIpProtocol() {
        return Codegen.optional(this.nonIpProtocol);
    }
    /**
     * Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    @Export(name="recordRouteDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> recordRouteDiscard;

    /**
     * @return Discard packets with the Record Route IP option set. When a datagram has this option, each router that routes the datagram adds its own IP address to the header, thus providing the path to the recipient.
     * 
     */
    public Output<Optional<Boolean>> recordRouteDiscard() {
        return Codegen.optional(this.recordRouteDiscard);
    }
    /**
     * Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    @Export(name="rejectNonSynTcp", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rejectNonSynTcp;

    /**
     * @return Determine whether to reject the packet if the first packet for the TCP session setup is not a SYN packet:
     * * `global` — Use system-wide setting that is assigned through the CLI.
     * * `yes` — Reject non-SYN TCP.
     * * `no` — Accept non-SYN TCP.
     * 
     */
    public Output<Optional<String>> rejectNonSynTcp() {
        return Codegen.optional(this.rejectNonSynTcp);
    }
    /**
     * Scan white list
     * 
     */
    @Export(name="scanWhiteLists", refs={List.class,ZoneProtectionProfileScanWhiteList.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ZoneProtectionProfileScanWhiteList>> scanWhiteLists;

    /**
     * @return Scan white list
     * 
     */
    public Output<Optional<List<ZoneProtectionProfileScanWhiteList>>> scanWhiteLists() {
        return Codegen.optional(this.scanWhiteLists);
    }
    /**
     * Scan
     * 
     */
    @Export(name="scans", refs={List.class,ZoneProtectionProfileScan.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ZoneProtectionProfileScan>> scans;

    /**
     * @return Scan
     * 
     */
    public Output<Optional<List<ZoneProtectionProfileScan>>> scans() {
        return Codegen.optional(this.scans);
    }
    /**
     * Discard packets if the security option is defined.
     * 
     */
    @Export(name="securityDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> securityDiscard;

    /**
     * @return Discard packets if the security option is defined.
     * 
     */
    public Output<Optional<Boolean>> securityDiscard() {
        return Codegen.optional(this.securityDiscard);
    }
    /**
     * The snippet in which the resource is defined
     * 
     */
    @Export(name="snippet", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> snippet;

    /**
     * @return The snippet in which the resource is defined
     * 
     */
    public Output<Optional<String>> snippet() {
        return Codegen.optional(this.snippet);
    }
    /**
     * Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    @Export(name="spoofedIpDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> spoofedIpDiscard;

    /**
     * @return Check that the source IP address of the ingress packet is routable and the routing interface is in the same zone as the ingress interface. If either condition is not true, discard the packet.
     * 
     */
    public Output<Optional<Boolean>> spoofedIpDiscard() {
        return Codegen.optional(this.spoofedIpDiscard);
    }
    /**
     * Discard packets if the Stream ID option is defined.
     * 
     */
    @Export(name="streamIdDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> streamIdDiscard;

    /**
     * @return Discard packets if the Stream ID option is defined.
     * 
     */
    public Output<Optional<Boolean>> streamIdDiscard() {
        return Codegen.optional(this.streamIdDiscard);
    }
    /**
     * Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    @Export(name="strictIpCheck", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> strictIpCheck;

    /**
     * @return Check that both conditions are true:
     * * The source IP address is not the subnet broadcast IP address of the ingress interface.
     * * The source IP address is routable over the exact ingress interface.
     *   If either condition is not true, discard the packet.
     * 
     */
    public Output<Optional<Boolean>> strictIpCheck() {
        return Codegen.optional(this.strictIpCheck);
    }
    /**
     * Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    @Export(name="strictSourceRoutingDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> strictSourceRoutingDiscard;

    /**
     * @return Discard packets with the Strict Source Routing IP option set. Strict Source Routing is an option whereby a source of a datagram provides routing information through which a gateway or host must send the datagram.
     * 
     */
    public Output<Optional<Boolean>> strictSourceRoutingDiscard() {
        return Codegen.optional(this.strictSourceRoutingDiscard);
    }
    /**
     * Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    @Export(name="suppressIcmpNeedfrag", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> suppressIcmpNeedfrag;

    /**
     * @return Stop sending ICMP fragmentation needed messages in response to packets that exceed the interface MTU and have the do not fragment (DF) bit set. This setting will interfere with the PMTUD process performed by hosts behind the firewall.
     * 
     */
    public Output<Optional<Boolean>> suppressIcmpNeedfrag() {
        return Codegen.optional(this.suppressIcmpNeedfrag);
    }
    /**
     * Stop sending ICMP TTL expired messages.
     * 
     */
    @Export(name="suppressIcmpTimeexceeded", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> suppressIcmpTimeexceeded;

    /**
     * @return Stop sending ICMP TTL expired messages.
     * 
     */
    public Output<Optional<Boolean>> suppressIcmpTimeexceeded() {
        return Codegen.optional(this.suppressIcmpTimeexceeded);
    }
    /**
     * Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    @Export(name="tcpFastOpenAndDataStrip", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tcpFastOpenAndDataStrip;

    /**
     * @return Strip the TCP Fast Open option (and data payload, if any) from the TCP SYN or SYN-ACK packet during a TCP three-way handshake.
     * 
     */
    public Output<Optional<Boolean>> tcpFastOpenAndDataStrip() {
        return Codegen.optional(this.tcpFastOpenAndDataStrip);
    }
    /**
     * Drop packets with split handshakes.
     * 
     */
    @Export(name="tcpHandshakeDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tcpHandshakeDiscard;

    /**
     * @return Drop packets with split handshakes.
     * 
     */
    public Output<Optional<Boolean>> tcpHandshakeDiscard() {
        return Codegen.optional(this.tcpHandshakeDiscard);
    }
    /**
     * Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    @Export(name="tcpSynWithDataDiscard", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> tcpSynWithDataDiscard;

    /**
     * @return Prevent a TCP session from being established if the TCP SYN packet contains data during a three-way handshake.
     * 
     */
    public Output<Boolean> tcpSynWithDataDiscard() {
        return this.tcpSynWithDataDiscard;
    }
    /**
     * Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    @Export(name="tcpSynackWithDataDiscard", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> tcpSynackWithDataDiscard;

    /**
     * @return Prevent a TCP session from being established if the TCP SYN-ACK packet contains data during a three-way handshake.
     * 
     */
    public Output<Boolean> tcpSynackWithDataDiscard() {
        return this.tcpSynackWithDataDiscard;
    }
    /**
     * Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    @Export(name="tcpTimestampStrip", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tcpTimestampStrip;

    /**
     * @return Determine whether the packet has a TCP timestamp in the header and, if it does, strip the timestamp from the header.
     * 
     */
    public Output<Optional<Boolean>> tcpTimestampStrip() {
        return Codegen.optional(this.tcpTimestampStrip);
    }
    @Export(name="tfid", refs={String.class}, tree="[0]")
    private Output<String> tfid;

    public Output<String> tfid() {
        return this.tfid;
    }
    /**
     * Discard packets with the Timestamp IP option set.
     * 
     */
    @Export(name="timestampDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> timestampDiscard;

    /**
     * @return Discard packets with the Timestamp IP option set.
     * 
     */
    public Output<Optional<Boolean>> timestampDiscard() {
        return Codegen.optional(this.timestampDiscard);
    }
    /**
     * Discard packets if the class and number are unknown.
     * 
     */
    @Export(name="unknownOptionDiscard", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> unknownOptionDiscard;

    /**
     * @return Discard packets if the class and number are unknown.
     * 
     */
    public Output<Optional<Boolean>> unknownOptionDiscard() {
        return Codegen.optional(this.unknownOptionDiscard);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ZoneProtectionProfile(java.lang.String name) {
        this(name, ZoneProtectionProfileArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ZoneProtectionProfile(java.lang.String name, @Nullable ZoneProtectionProfileArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ZoneProtectionProfile(java.lang.String name, @Nullable ZoneProtectionProfileArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("scm:index/zoneProtectionProfile:ZoneProtectionProfile", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ZoneProtectionProfile(java.lang.String name, Output<java.lang.String> id, @Nullable ZoneProtectionProfileState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("scm:index/zoneProtectionProfile:ZoneProtectionProfile", name, state, makeResourceOptions(options, id), false);
    }

    private static ZoneProtectionProfileArgs makeArgs(@Nullable ZoneProtectionProfileArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ZoneProtectionProfileArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ZoneProtectionProfile get(java.lang.String name, Output<java.lang.String> id, @Nullable ZoneProtectionProfileState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ZoneProtectionProfile(name, id, state, options);
    }
}
